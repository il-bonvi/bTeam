/**
 * Races Route Module - GPX Visualizer tab (embedded)
 * FILE: webapp/modules/races/races-route.js
 */

const ROUTE_VISUALIZER_HTML = `<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@raruto/leaflet-elevation@2.2.5/dist/leaflet-elevation.css" />
    <script src="https://unpkg.com/@raruto/leaflet-elevation@2.2.5/dist/leaflet-elevation.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: #f8f9fa;
            color: #1a1a1a;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0.5rem;
        }
        
        header {
            background: white;
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            margin-bottom: 0.4rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        h1 {
            font-size: 1.75rem;
            font-weight: 700;
            color: #fc5200;
        }
        input[type="file"] {
            display: none;
        }
        
        .stats-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.3rem;
            margin-bottom: 0.4rem;
        }
        
        .stat-card {
            background: white;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .stat-label {
            color: #6b7280;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }
        
        .stat-value {
            font-size: 1.75rem;
            font-weight: 700;
        }
        
        .stat-unit {
            font-size: 1rem;
            color: #6b7280;
            font-weight: 400;
            margin-left: 0.25rem;
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
            margin-bottom: 0.4rem;
        }
        
        .panel-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #e5e7eb;
            background: #f9fafb;
        }
        
        .panel-title {
            font-size: 1rem;
            font-weight: 600;
        }
        
        #map {
            height: 450px;
            width: 100%;
        }
        

        
        .gradient-legend {
            display: flex;
            gap: 1rem;
            padding: 1rem 1.25rem;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            font-size: 0.85rem;
            align-items: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-color {
            width: 200px;
            height: 20px;
            border-radius: 3px;
        }
        
        #elevation-chart {
            position: relative;
            background: #ffffff;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            -webkit-touch-callout: none;
            /* aspect-ratio: forza altezza proporzionale alla larghezza, no spazio vuoto */
            aspect-ratio: 900 / 290;
        }

        #elevation-chart svg text {
            fill: #6b7280;
        }
        #elevation-chart svg .domain {
            stroke: #d1d5db;
        }
        #elevation-chart svg .tick line {
            stroke: #d1d5db;
        }
        
        .elevation-div .grid-y line,
        .elevation-div .grid-x line {
            stroke: #e5e7eb;
        }
        
        #data-content {
            display: block;
        }

        /* Climb Detection Styles */
        .climbs-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 0.4rem;
            overflow: hidden;
        }

        .climbs-header {
            padding: 1rem 1.25rem;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .climbs-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .climbs-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
            padding: 1.25rem;
        }

        .climb-card {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .climb-card:hover {
            border-color: #fc5200;
            box-shadow: 0 2px 8px rgba(252, 82, 0, 0.1);
            transform: translateY(-2px);
        }

        .climb-card.highlighted {
            border-color: #fc5200;
            box-shadow: 0 2px 12px rgba(252, 82, 0, 0.2);
        }

        .climb-number {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: #fc5200;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.85rem;
        }

        .climb-difficulty {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.85rem;
            margin-bottom: 0.75rem;
            color: white;
        }

        .climb-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .climb-stat {
            font-size: 0.85rem;
        }

        .climb-stat-label {
            color: #6b7280;
            font-size: 0.75rem;
        }

        .climb-stat-value {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .no-climbs {
            padding: 2rem;
            text-align: center;
            color: #6b7280;
        }

        .difficulty-legend {
            padding: 1rem 1.25rem;
            border-top: 1px solid #e5e7eb;
            background: #f9fafb;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            font-size: 0.8rem;
        }

        .difficulty-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .difficulty-legend-color {
            width: 30px;
            height: 16px;
            border-radius: 3px;
        }

        /* Mini elevation chart for selected climb */
        .climb-detail-chart {
            display: none;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 0.4rem;
            overflow: hidden;
        }

        .climb-detail-chart.active {
            display: block;
        }

        .climb-detail-header {
            padding: 1rem 1.25rem;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        .climb-detail-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .climb-detail-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .slider-label {
            font-size: 0.85rem;
            color: #6b7280;
            white-space: nowrap;
        }

        .sections-slider {
            width: 150px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #d1d5db;
            border-radius: 3px;
            outline: none;
        }

        .sections-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #fc5200;
            border-radius: 50%;
            cursor: pointer;
        }

        .sections-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #fc5200;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            font-size: 0.85rem;
            font-weight: 600;
            color: #fc5200;
            min-width: 30px;
            text-align: center;
        }

        .climb-detail-close {
            cursor: pointer;
            color: #6b7280;
            font-size: 1.2rem;
            font-weight: bold;
            padding: 0 0.5rem;
        }

        .climb-detail-close:hover {
            color: #fc5200;
        }

        #climb-detail-svg {
            width: 100%;
            height: 220px;
            display: block;
        }

        /* ‚îÄ‚îÄ Layout wrapper per push ‚îÄ‚îÄ */
        #app-layout {
            display: flex;
            transition: none;
            width: 100%;
        }
        #main-content {
            flex: 1;
            min-width: 0;
            transition: all 0.35s cubic-bezier(0.4,0,0.2,1);
        }

        /* ‚îÄ‚îÄ Street View Side Panel ‚îÄ‚îÄ */
        #sv-panel {
            display: none;
            width: 0;
            min-width: 0;
            overflow: hidden;
            flex-shrink: 0;
            transition: width 0.35s cubic-bezier(0.4,0,0.2,1);
            background: white;
            box-shadow: -4px 0 24px rgba(0,0,0,0.18);
            flex-direction: column;
            font-family: 'Inter', sans-serif;
            height: 100vh;
            position: sticky;
            top: 0;
        }
        #sv-panel.open {
            display: flex;
            width: 420px;
            min-width: 420px;
        }

        #sv-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: #1a1a1a;
            color: white;
            flex-shrink: 0;
        }
        #sv-panel-header h3 {
            font-size: 0.95rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #sv-close {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 1.4rem;
            cursor: pointer;
            line-height: 1;
            padding: 0 4px;
            transition: color 0.2s;
        }
        #sv-close:hover { color: white; }

        #sv-minimap {
            width: 100%;
            height: 260px;
            flex-shrink: 0;
        }

        #sv-info {
            padding: 16px;
            border-bottom: 1px solid #e5e7eb;
            flex-shrink: 0;
        }
        #sv-coords {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-bottom: 10px;
            font-family: monospace;
        }
        #sv-stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 14px;
        }
        .sv-stat {
            background: #f9fafb;
            border-radius: 6px;
            padding: 8px 10px;
            text-align: center;
        }
        .sv-stat-label {
            font-size: 0.65rem;
            color: #6b7280;
            text-transform: uppercase;
            font-weight: 500;
            margin-bottom: 2px;
        }
        .sv-stat-value {
            font-size: 1rem;
            font-weight: 700;
            color: #1a1a1a;
        }
        #sv-open-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 12px;
            background: #fc5200;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            transition: background 0.2s;
        }
        #sv-open-btn:hover { background: #e04800; }

        #sv-hint {
            padding: 12px 16px;
            background: #fff7ed;
            border-top: 1px solid #fed7aa;
            font-size: 0.78rem;
            color: #92400e;
            flex-shrink: 0;
        }

        #sv-gradient-bar {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        .sv-gradient-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 10px;
        }
        #sv-gradient-chart {
            width: 100%;
            height: 100px;
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           MOBILE RESPONSIVE
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        @media (max-width: 768px) {
            .container { padding: 0.3rem; }
            .stats-row { grid-template-columns: repeat(3, 1fr); gap: 0.25rem; margin-bottom: 0.3rem; }
            .stat-card { padding: 0.5rem 0.6rem; }
            .stat-label { font-size: 0.65rem; margin-bottom: 0.2rem; }
            .stat-value { font-size: 1.2rem; }
            .stat-unit  { font-size: 0.75rem; }
            #map { height: 55vw; min-height: 220px; max-height: 350px; }
            /* elevation-chart height: gestita dal viewBox SVG */
        .gradient-legend { padding: 0.5rem 0.75rem; font-size: 0.75rem; flex-wrap: wrap; gap: 0.5rem; }
            .climbs-list { grid-template-columns: 1fr; padding: 0.75rem; }
            .climbs-header, .difficulty-legend { padding: 0.75rem; }
            .climb-detail-header { flex-wrap: wrap; gap: 0.5rem; padding: 0.75rem; }
            #climb-detail-svg { height: 160px; }
            #app-layout { flex-direction: column; }
            #sv-panel {
                position: fixed !important;
                top: 0; left: 0; right: 0; bottom: 0;
                width: 100% !important;
                min-width: 0 !important;
                height: 100dvh !important;
                z-index: 9999;
                transform: translateY(100%);
                transition: transform 0.35s cubic-bezier(0.4,0,0.2,1) !important;
                display: flex !important;
            }
            #sv-panel.open { transform: translateY(0); }
            #sv-minimap { height: 200px; }
            #sv-hint { font-size: 0.72rem; padding: 8px 12px; }
            #mobile-sv-hint { display: block !important; }
        }
        @media (min-width: 769px) { #mobile-sv-hint { display: none !important; } }
        #mobile-sv-hint { display: none; }


        .sv-hint {
            display: none;
            text-align: center;
            font-size: 0.82rem;
            color: #2c3e57;
            background: #f3f4f6;
            border-left: 3px solid #fc5200;
            padding: 8px 16px;
            margin: 8px 16px 4px;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            line-height: 1.5;
        }
        @media (min-width: 769px) {
            .sv-hint { display: block; }
        }
        </style>
</head>
<body>
    <!-- Layout wrapper: contenuto principale + pannello SV affiancati -->
    <div id="app-layout">
    <div id="main-content">
    <div class="container">
        <div id="data-content" style="display:none">
            <div class="stats-row">
                <div class="stat-card">
                    <div class="stat-label">Total Length</div>
                    <div class="stat-value" id="stat-distance">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Time</div>
                    <div class="stat-value" id="stat-time">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Min Altitude</div>
                    <div class="stat-value" id="stat-min-alt">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Max Altitude</div>
                    <div class="stat-value" id="stat-max-alt">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Avg Altitude</div>
                    <div class="stat-value" id="stat-avg-alt">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Elevation Gain</div>
                    <div class="stat-value" id="stat-gain">--</div>
                </div>
            </div>
            
            <div class="panel">
                <div id="map"></div>
            </div>
            <div id="mobile-sv-hint">üëÜ Tieni premuto sulla mappa per esplorare il punto in Street View. Attenzione, l'orientamento potrebbe essere errato.</div>
            
            <div class="panel">
                <div id="elevation-chart"></div>
                <div class="gradient-legend">
                    <div id="selection-stats" style="display:flex;gap:2rem;align-items:center;width:100%;font-size:0.85rem;">
                        <span style="color:#6b7280;font-size:0.8rem;" id="sel-label">Trascina sul grafico per selezionare una sezione</span>
                        <span id="sel-dist" style="display:none">üìè <strong id="sel-dist-val">--</strong></span>
                        <span id="sel-gain" style="display:none">‚Üë <strong id="sel-gain-val" style="color:#16a34a">--</strong></span>
                        <span id="sel-loss" style="display:none">‚Üì <strong id="sel-loss-val" style="color:#2563eb">--</strong></span>
                        <span id="sel-grade" style="display:none">‚õ∞ <strong id="sel-grade-val">--</strong> media</span>
                    </div>
                </div>
            </div>

            <!-- Climb Detail Chart -->
            <div class="climb-detail-chart" id="climb-detail-chart">
                <div class="climb-detail-header">
                    <div class="climb-detail-title" id="climb-detail-title">Profilo Salita</div>
                    <div class="climb-detail-controls">
                        <div class="slider-container">
                            <span class="slider-label">Dettaglio:</span>
                            <input type="range" id="sections-slider" class="sections-slider" min="3" max="20" value="8" step="1">
                            <span class="slider-value" id="slider-value">8</span>
                        </div>
                    </div>
                    <div class="climb-detail-close" onclick="closeClimbDetail()">√ó</div>
                </div>
                <svg id="climb-detail-svg"></svg>
            </div>

            <!-- Climbs Section -->
            <div class="climbs-section" id="climbs-section" style="display: none;">
                <div class="climbs-header">
                    <div class="climbs-title">‚õ∞Ô∏è Salite Rilevate <span id="climbs-count" style="color: #6b7280; font-weight: 400; font-size: 0.9rem;"></span></div>
                </div>
                <div id="climbs-list" class="climbs-list"></div>
                <div class="difficulty-legend">
                    <strong>Scala Difficolt√†:</strong>
                    <div class="difficulty-legend-item">
                        <div class="difficulty-legend-color" style="background: #9aca3c;"></div>
                        <span>20-75 (Facile)</span>
                    </div>
                    <div class="difficulty-legend-item">
                        <div class="difficulty-legend-color" style="background: #ffa500;"></div>
                        <span>75-150 (Moderata)</span>
                    </div>
                    <div class="difficulty-legend-item">
                        <div class="difficulty-legend-color" style="background: #ff8c00;"></div>
                        <span>150-300 (Impegnativa)</span>
                    </div>
                    <div class="difficulty-legend-item">
                        <div class="difficulty-legend-color" style="background: #ff4500;"></div>
                        <span>300-600 (Difficile)</span>
                    </div>
                    <div class="difficulty-legend-item">
                        <div class="difficulty-legend-color" style="background: #b22222;"></div>
                        <span>600-900 (Estrema)</span>
                    </div>
                    <div class="difficulty-legend-item">
                        <div class="difficulty-legend-color" style="background: #800000;"></div>
                        <span>900-1200 (HC)</span>
                    </div>
                    <div class="difficulty-legend-item">
                        <div class="difficulty-legend-color" style="background: #000000;"></div>
                        <span>1200+ (Leggendaria)</span>
                    </div>
                </div>
            </div>
        </div>
</div><!-- /container -->
    </div><!-- /main-content -->

    <!-- Street View Side Panel (dentro app-layout, affiancato) -->
    <div id="sv-panel">
        <div id="sv-panel-header">
            <h3>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="#fc5200"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>
                Esplora Punto
            </h3>
            <button id="sv-close">√ó</button>
        </div>

        <div id="sv-minimap"></div>

        <div id="sv-info">
            <div id="sv-coords">--</div>
            <div id="sv-stats">
                <div class="sv-stat">
                    <div class="sv-stat-label">Km percorso</div>
                    <div class="sv-stat-value" id="sv-km">--</div>
                </div>
                <div class="sv-stat">
                    <div class="sv-stat-label">Quota</div>
                    <div class="sv-stat-value" id="sv-ele">--</div>
                </div>
                <div class="sv-stat">
                    <div class="sv-stat-label">Pendenza</div>
                    <div class="sv-stat-value" id="sv-grade">--</div>
                </div>
            </div>
            <a id="sv-open-btn" href="#" target="_blank" rel="noopener">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="white"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>
                Apri in Google Street View
            </a>
        </div>

        <div id="sv-hint">
            üí° <strong>Trascina il marker</strong> sulla mini-mappa per esplorare altri punti del percorso<br><span style="font-size:0.7rem;opacity:0.8">Su mobile: tocca e trascina il marker</span>
        </div>

        <div id="sv-gradient-bar">
            <div class="sv-gradient-title">Profilo altimetrico zona</div>
            <svg id="sv-gradient-chart"></svg>
        </div>
    </div><!-- /sv-panel -->
    </div><!-- /app-layout -->

    <script>
let map;
        let elevationControl;
        let routeData = null;
        let _hoverMapMarker = null;   // marker arancione hover sul chart
        let _zoomStartMarker = null;  // marker inizio zoom
        let _zoomEndMarker = null;    // marker fine zoom
        let detectedClimbs = [];
        let climbPolylines = [];
        
        const dataContent = document.getElementById('data-content');
        // Auto-load GPX from parent app via postMessage
        window.addEventListener('message', function(e) {
            if (e.data && e.data.type === 'loadGpxPoints' && e.data.points) {
                const pts = e.data.points;
                let gpx = '<?xml version="1.0" encoding="UTF-8"?>';
                gpx += '<gpx version="1.1" creator="bTeam"><trk><trkseg>';
                for (const p of pts) {
                    gpx += '<trkpt lat="' + p[0] + '" lon="' + p[1] + '"><ele>' + p[2] + '</ele></trkpt>';
                }
                gpx += '</trkseg></trk></gpx>';
                parseGPX(gpx);
            }
        });

        
        function parseGPX(gpxText) {
            const parser = new DOMParser();
            const xml = parser.parseFromString(gpxText, 'text/xml');
            
            const points = [];
            xml.querySelectorAll('trkpt').forEach(pt => {
                points.push({
                    lat: parseFloat(pt.getAttribute('lat')),
                    lon: parseFloat(pt.getAttribute('lon')),
                    ele: parseFloat(pt.querySelector('ele')?.textContent || 0)
                });
            });
            
            if (points.length > 0) processRoute(points, gpxText);
        }
        
        function getGradientColor(gradient) {
            const g = Math.max(-20, Math.min(20, gradient));
            
            if (g < -15) {
                // -20% to -15%: quasi nero-blu a blu scurissimo
                const t = (g + 20) / 5;
                return interpolateColor('#0f172a', '#1e3a8a', t);
            } else if (g < -10) {
                // -15% to -10%: blu scurissimo a blu
                const t = (g + 15) / 5;
                return interpolateColor('#1e3a8a', '#3b82f6', t);
            } else if (g < -5) {
                // -10% to -5%: blu a azzurro
                const t = (g + 10) / 5;
                return interpolateColor('#3b82f6', '#60a5fa', t);
            } else if (g < 0) {
                // -5% to 0%: azzurro a VERDE
                const t = (g + 5) / 5;
                return interpolateColor('#60a5fa', '#22c55e', t);
            } else if (g < 5) {
                // 0% to 5%: VERDE a GIALLO
                const t = g / 5;
                return interpolateColor('#22c55e', '#fbbf24', t);
            } else if (g < 8) {
                // 5% to 8%: GIALLO a ARANCIONE
                const t = (g - 5) / 3;
                return interpolateColor('#fbbf24', '#f97316', t);
            } else if (g < 11) {
                // 8% to 11%: ARANCIONE a ROSSO
                const t = (g - 8) / 3;
                return interpolateColor('#f97316', '#dc2626', t);
            } else if (g < 15) {
                // 11% to 15%: ROSSO a ROSSO SCURO
                const t = (g - 11) / 4;
                return interpolateColor('#dc2626', '#991b1b', t);
            } else {
                // 15% to 20%: ROSSO SCURO a ROSSO QUASI NERO
                const t = (g - 15) / 5;
                return interpolateColor('#991b1b', '#450a0a', t);
            }
        }
        
        function interpolateColor(color1, color2, t) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            
            const r = Math.round(c1.r + (c2.r - c1.r) * t);
            const g = Math.round(c1.g + (c2.g - c1.g) * t);
            const b = Math.round(c1.b + (c2.b - c1.b) * t);
            
            return rgbToHex(r, g, b);
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        function smoothGradient(gradients, windowSize = 6) {
            const smoothed = [];
            for (let i = 0; i < gradients.length; i++) {
                let sum = 0;
                let count = 0;
                const start = Math.max(0, i - windowSize);
                const end = Math.min(gradients.length - 1, i + windowSize);
                
                for (let j = start; j <= end; j++) {
                    sum += gradients[j];
                    count++;
                }
                smoothed.push(sum / count);
            }
            return smoothed;
        }
        
        function processRoute(points, gpxText) {
            let distance = 0;
            let elevationGain = 0;
            let maxElevation = points[0].ele;
            let minElevation = points[0].ele;
            let sumElevation = points[0].ele;
            
            const processedPoints = [{ ...points[0], dist: 0, gradient: 0 }];
            
            for (let i = 1; i < points.length; i++) {
                const prev = processedPoints[i - 1];
                const curr = points[i];
                
                const R = 6371000;
                const dLat = (curr.lat - prev.lat) * Math.PI / 180;
                const dLon = (curr.lon - prev.lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(prev.lat * Math.PI / 180) * Math.cos(curr.lat * Math.PI / 180) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const segDist = R * c;
                
                distance += segDist;
                
                const elevDiff = curr.ele - prev.ele;
                if (elevDiff > 0) elevationGain += elevDiff;
                
                if (curr.ele > maxElevation) maxElevation = curr.ele;
                if (curr.ele < minElevation) minElevation = curr.ele;
                sumElevation += curr.ele;
                
                const gradient = segDist > 0 ? (elevDiff / segDist) * 100 : 0;
                
                processedPoints.push({
                    ...curr,
                    dist: distance,
                    gradient: gradient
                });
            }
            
            routeData = {
                points: processedPoints,
                distance: distance / 1000,
                elevationGain,
                maxElevation,
                minElevation,
                avgElevation: sumElevation / points.length
            };
            
            updateStats();
            
            dataContent.style.display = 'block';
            
            setTimeout(() => {
                initMap(gpxText);
            }, 100);
        }
        
        function updateStats() {
            const AVG_SPEED_KMH = 38;
            const totalTimeHours = routeData.distance / AVG_SPEED_KMH;
            const hours = Math.floor(totalTimeHours);
            const minutes = Math.floor((totalTimeHours - hours) * 60);
            const seconds = Math.floor(((totalTimeHours - hours) * 60 - minutes) * 60);
            const timeString = \`\${hours}:\${minutes.toString().padStart(2, '0')}'\${seconds.toString().padStart(2, '0')}"\`;
            
            // Top stats
            document.getElementById('stat-distance').innerHTML = 
                \`\${routeData.distance.toFixed(2)}<span class="stat-unit">km</span>\`;
            document.getElementById('stat-time').innerHTML = 
                \`\${timeString}\`;
            document.getElementById('stat-max-alt').innerHTML = 
                \`\${Math.round(routeData.maxElevation)}<span class="stat-unit">m</span>\`;
            document.getElementById('stat-min-alt').innerHTML = 
                \`\${Math.round(routeData.minElevation)}<span class="stat-unit">m</span>\`;
            document.getElementById('stat-avg-alt').innerHTML = 
                \`\${Math.round(routeData.avgElevation)}<span class="stat-unit">m</span>\`;
            document.getElementById('stat-gain').innerHTML = 
                \`\${Math.round(routeData.elevationGain)}<span class="stat-unit">m</span>\`;
        }
        
        function initMap(gpxText) {
            map = L.map('map');
            L.control.scale({ imperial: false, position: 'bottomleft' }).addTo(map);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap'
            }).addTo(map);
            
            // Draw gradient-colored polyline
            const gradients = routeData.points.map(p => p.gradient);
            const smoothedGradients = smoothGradient(gradients, 6);
            
            for (let i = 1; i < routeData.points.length; i++) {
                const p1 = routeData.points[i-1];
                const p2 = routeData.points[i];
                const color = getGradientColor(smoothedGradients[i]);
                
                L.polyline([[p1.lat, p1.lon], [p2.lat, p2.lon]], {
                    color: color,
                    weight: 4,
                    opacity: 0.9
                }).addTo(map);
            }

            
            
            const latlngs = routeData.points.map(p => [p.lat, p.lon]);
            const routeBounds = L.latLngBounds(latlngs);
            
            // Aspetta che la mappa abbia le dimensioni corrette prima di centrare
            setTimeout(() => {
                map.invalidateSize();
                map.fitBounds(routeBounds, { padding: [40, 40] });
            }, 100);

            // ‚îÄ‚îÄ Bottone "Recentra" ‚Äî aggiunto al bar zoom esistente ‚îÄ‚îÄ
            map.whenReady(() => {
                setTimeout(() => {
                    const zoomBar = document.querySelector('#map .leaflet-control-zoom');
                    if (zoomBar) {
                        const btn = document.createElement('a');
                        btn.href = '#';
                        btn.title = 'Recentra sul percorso';
                        btn.innerHTML = '‚åñ';
                        btn.style.fontSize = '18px';
                        btn.onclick = (e) => {
                            e.preventDefault();
                            map.fitBounds(routeBounds, { padding: [30, 30], animate: true });
                        };
                        zoomBar.appendChild(btn);
                    }
                }, 200);
            });

            // Marker inizio (verde) e fine (rosso)
            const startPt = routeData.points[0];
            const endPt   = routeData.points[routeData.points.length - 1];

            const startIcon = L.divIcon({
                className: '',
                html: \`<div style="width:14px;height:14px;background:#22c55e;border:2px solid #fff;border-radius:50%;box-shadow:0 1px 4px rgba(0,0,0,0.4)"></div>\`,
                iconSize: [14, 14],
                iconAnchor: [7, 7]
            });
            const endIcon = L.divIcon({
                className: '',
                html: \`<div style="font-size:20px;line-height:1;filter:drop-shadow(0 1px 2px rgba(0,0,0,0.5))">üèÅ</div>\`,
                iconSize: [20, 20],
                iconAnchor: [4, 20]
            });

            L.marker([startPt.lat, startPt.lon], { icon: startIcon })
                .addTo(map)
                .bindPopup(\`<b>üö¶ Partenza</b><br>Quota: \${Math.round(startPt.ele)} m\`);

            L.marker([endPt.lat, endPt.lon], { icon: endIcon })
                .addTo(map)
                .bindPopup(\`<b>üèÅ Arrivo</b><br>Quota: \${Math.round(endPt.ele)} m<br>Distanza totale: \${routeData.distance.toFixed(2)} km\`);
            
                        initSVPanel(); // wire up contextmenu + mobile touch

            // ‚îÄ‚îÄ Chart altimetrico D3 puro (no leaflet-elevation) ‚îÄ‚îÄ
            buildElevationChart();
            
            // Detect climbs
            setTimeout(() => detectAndDisplayClimbs(), 100);
        }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GLOBAL SV PANEL STATE & FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let svMiniMap = null;
        let svMarker = null;
        let svPolyline = null;
        let svMainMarker = null;

        const svMainIcon = L.divIcon({
            className: '',
            html: \`<div style="width:16px;height:16px;background:#fc5200;border:3px solid white;border-radius:50%;box-shadow:0 2px 8px rgba(252,82,0,0.6);"></div>\`,
            iconSize: [16, 16],
            iconAnchor: [8, 8]
        });

        window._elevXScale = null;
        window._elevYScale = null;
        window._elevG = null;
        window._elevMargin = null;

        function findNearestPoint(lat, lng) {
            if (!routeData) return null;
            let nearest = null;
            let minDist = Infinity;
            routeData.points.forEach(p => {
                const d = (p.lat - lat) ** 2 + (p.lon - lng) ** 2;
                if (d < minDist) { minDist = d; nearest = p; }
            });
            return nearest;
        }

        function findNearestPointByDist(distKm) {
            if (!routeData) return null;
            let nearest = null;
            let minDiff = Infinity;
            routeData.points.forEach(p => {
                const diff = Math.abs(p.dist / 1000 - distKm);
                if (diff < minDiff) { minDiff = diff; nearest = p; }
            });
            return nearest;
        }
        window._findNearestPointByDist = findNearestPointByDist;

        function drawSVGradientChart(centerPoint) {
            if (!routeData) return;
            const centerDist = centerPoint.dist / 1000;
            const range = 2;
            const pts = routeData.points.filter(p => {
                const d = p.dist / 1000;
                return d >= centerDist - range && d <= centerDist + range;
            });
            if (pts.length < 2) return;

            const svg = document.getElementById('sv-gradient-chart');
            const W = svg.parentElement.clientWidth - 32;
            const H = 100;
            svg.setAttribute('width', W);
            svg.setAttribute('height', H);
            svg.innerHTML = '';

            const margin = { top: 8, right: 8, bottom: 20, left: 36 };
            const cW = W - margin.left - margin.right;
            const cH = H - margin.top - margin.bottom;

            const dists = pts.map(p => p.dist / 1000);
            const eles = pts.map(p => p.ele);
            const minD = Math.min(...dists), maxD = Math.max(...dists);
            const minE = Math.min(...eles), maxE = Math.max(...eles);
            const padE = (maxE - minE) * 0.15 || 5;

            const xS = v => margin.left + ((v - minD) / (maxD - minD || 1)) * cW;
            const yS = v => margin.top + cH - ((v - (minE - padE)) / ((maxE + padE) - (minE - padE))) * cH;

            const ns = 'http://www.w3.org/2000/svg';

            const areaPoints = [\`\${xS(dists[0])},\${margin.top + cH}\`];
            pts.forEach((p, i) => areaPoints.push(\`\${xS(dists[i])},\${yS(p.ele)}\`));
            areaPoints.push(\`\${xS(dists[dists.length-1])},\${margin.top + cH}\`);

            const area = document.createElementNS(ns, 'polygon');
            area.setAttribute('points', areaPoints.join(' '));
            area.setAttribute('fill', '#fc5200');
            area.setAttribute('opacity', '0.15');
            svg.appendChild(area);

            const linePoints = pts.map((p, i) => \`\${xS(dists[i])},\${yS(p.ele)}\`).join(' ');
            const polyline = document.createElementNS(ns, 'polyline');
            polyline.setAttribute('points', linePoints);
            polyline.setAttribute('fill', 'none');
            polyline.setAttribute('stroke', '#fc5200');
            polyline.setAttribute('stroke-width', '2');
            svg.appendChild(polyline);

            const cx = xS(centerDist);
            const cy = yS(centerPoint.ele);
            const circle = document.createElementNS(ns, 'circle');
            circle.setAttribute('cx', cx); circle.setAttribute('cy', cy);
            circle.setAttribute('r', 5); circle.setAttribute('fill', '#fc5200');
            circle.setAttribute('stroke', 'white'); circle.setAttribute('stroke-width', 2);
            svg.appendChild(circle);

            const line = document.createElementNS(ns, 'line');
            line.setAttribute('x1', cx); line.setAttribute('y1', margin.top);
            line.setAttribute('x2', cx); line.setAttribute('y2', margin.top + cH);
            line.setAttribute('stroke', '#fc5200'); line.setAttribute('stroke-width', 1);
            line.setAttribute('stroke-dasharray', '3,3');
            svg.appendChild(line);

            const text = document.createElementNS(ns, 'text');
            text.setAttribute('x', Math.min(cx + 6, W - 40));
            text.setAttribute('y', cy - 6);
            text.setAttribute('font-size', '10'); text.setAttribute('fill', '#fc5200');
            text.setAttribute('font-weight', 'bold');
            text.textContent = Math.round(centerPoint.ele) + ' m';
            svg.appendChild(text);

            [{ v: minE, label: Math.round(minE) + ' m' }, { v: maxE, label: Math.round(maxE) + ' m' }].forEach(tick => {
                const t = document.createElementNS(ns, 'text');
                t.setAttribute('x', margin.left - 4); t.setAttribute('y', yS(tick.v) + 4);
                t.setAttribute('font-size', '9'); t.setAttribute('fill', '#9ca3af');
                t.setAttribute('text-anchor', 'end'); t.textContent = tick.label;
                svg.appendChild(t);
            });
        }

        function updateSVPanel(point) {
            const lat = point.lat.toFixed(6);
            const lng = point.lon.toFixed(6);
            const distKm = (point.dist / 1000).toFixed(2);
            const ele = Math.round(point.ele);
            const grade = point.gradient ? point.gradient.toFixed(1) + '%' : '0%';

            document.getElementById('sv-coords').textContent = \`\${lat}, \${lng}\`;
            document.getElementById('sv-km').textContent = distKm + ' km';
            document.getElementById('sv-ele').textContent = ele + ' m';
            document.getElementById('sv-grade').textContent = grade;

            const svUrl = \`https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=\${lat},\${lng}\`;
            document.getElementById('sv-open-btn').href = svUrl;

            if (svMiniMap && svMarker) {
                svMarker.setLatLng([point.lat, point.lon]);
                svMiniMap.panTo([point.lat, point.lon], { animate: true, duration: 0.4 });
            }

            if (!svMainMarker) {
                svMainMarker = L.marker([point.lat, point.lon], { icon: svMainIcon, zIndexOffset: 500 }).addTo(map);
            } else {
                svMainMarker.setLatLng([point.lat, point.lon]);
            }

            if (window._elevXScale && window._elevYScale && window._elevG) {
                const xS = window._elevXScale;
                const yS = window._elevYScale;
                const g = window._elevG;
                const cx = xS(point.dist / 1000);
                const cy = yS(point.ele);
                const H = window._elevMargin ? (290 - window._elevMargin.top - window._elevMargin.bottom) : 235;
                g.selectAll('.sv-elev-line, .sv-elev-dot, .sv-elev-label').remove();
                g.append('line').attr('class', 'sv-elev-line')
                    .attr('x1', cx).attr('x2', cx).attr('y1', 0).attr('y2', H)
                    .attr('stroke', '#fc5200').attr('stroke-width', 2)
                    .attr('stroke-dasharray', '4,3').attr('opacity', 0.9);
                g.append('circle').attr('class', 'sv-elev-dot')
                    .attr('cx', cx).attr('cy', cy).attr('r', 6)
                    .attr('fill', '#fc5200').attr('stroke', 'white').attr('stroke-width', 2);
                g.append('text').attr('class', 'sv-elev-label')
                    .attr('x', cx + 8).attr('y', cy - 8)
                    .attr('font-size', '11px').attr('font-weight', 'bold')
                    .attr('fill', '#fc5200')
                    .text(Math.round(point.ele) + ' m');
            }

            drawSVGradientChart(point);
        }

        function openSVPanel(nearestPoint) {
            const panel = document.getElementById('sv-panel');
            panel.classList.add('open');
            setTimeout(() => { if (map) map.invalidateSize(); }, 380);

            if (!svMiniMap) {
                svMiniMap = L.map('sv-minimap', { zoomControl: true, attributionControl: false });
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    maxZoom: 19
                }).addTo(svMiniMap);

                const latlngs = routeData.points.map(p => [p.lat, p.lon]);
                svPolyline = L.polyline(latlngs, { color: '#fc5200', weight: 3, opacity: 0.9 }).addTo(svMiniMap);

                const dragIcon = L.divIcon({
                    className: '',
                    html: \`<div style="width:18px;height:18px;background:#fc5200;border:3px solid white;border-radius:50%;box-shadow:0 2px 8px rgba(0,0,0,0.4);cursor:grab;"></div>\`,
                    iconSize: [18, 18], iconAnchor: [9, 9]
                });
                svMarker = L.marker([nearestPoint.lat, nearestPoint.lon], {
                    icon: dragIcon, draggable: true
                }).addTo(svMiniMap);

                svMarker.on('drag', function(e) {
                    const p = findNearestPoint(e.latlng.lat, e.latlng.lng);
                    svMarker.setLatLng([p.lat, p.lon]);
                    updateSVPanel(p);
                });
                svMarker.on('dragend', function() {
                    const ll = svMarker.getLatLng();
                    const p = findNearestPoint(ll.lat, ll.lng);
                    svMarker.setLatLng([p.lat, p.lon]);
                    updateSVPanel(p);
                });

                setTimeout(() => svMiniMap.invalidateSize(), 100);
            }

            svMarker.setLatLng([nearestPoint.lat, nearestPoint.lon]);
            svMiniMap.setView([nearestPoint.lat, nearestPoint.lon], 16);
            updateSVPanel(nearestPoint);
        }
        window._openSVPanel = openSVPanel;

        // ‚îÄ‚îÄ sv-close button ‚îÄ‚îÄ
        document.getElementById('sv-close').addEventListener('click', () => {
            document.getElementById('sv-panel').classList.remove('open');
            setTimeout(() => { if (map) map.invalidateSize(); }, 380);
            if (svMainMarker) { map.removeLayer(svMainMarker); svMainMarker = null; }
            if (window._elevG) window._elevG.selectAll('.sv-elev-line, .sv-elev-dot, .sv-elev-label').remove();
        });

        // ‚îÄ‚îÄ Touch: long-press su mappa e altimetria ‚îÄ‚îÄ
        function setupMobileTouch() {
            // Long-press sulla mappa
            let lpTimer = null, lpMoved = false;
            const mapContainer = document.getElementById('map');

            mapContainer.addEventListener('touchstart', function(e) {
                if (e.touches.length !== 1) return;
                lpMoved = false;
                const touch = e.touches[0];
                lpTimer = setTimeout(() => {
                    if (lpMoved) return;
                    const rect = mapContainer.getBoundingClientRect();
                    const latlng = map.containerPointToLatLng([
                        touch.clientX - rect.left,
                        touch.clientY - rect.top
                    ]);
                    const nearest = findNearestPoint(latlng.lat, latlng.lng);
                    if (nearest) {
                        if (navigator.vibrate) navigator.vibrate(40);
                        openSVPanel(nearest);
                    }
                }, 600);
            }, { passive: true });
            mapContainer.addEventListener('touchmove',  () => { lpMoved = true; clearTimeout(lpTimer); }, { passive: true });
            mapContainer.addEventListener('touchend',   () => clearTimeout(lpTimer), { passive: true });

            // Touch sull'altimetria: drag per hover, sparisce al touchend
            const elevContainer = document.getElementById('elevation-chart');

            // Usa named functions per poter fare removeEventListener corretto
            function onElevTouchMove(e) {
                if (e.touches.length !== 1) return;
                e.preventDefault();
                if (!window._elevXScale || !window._elevMargin || !window._updateElevHover) return;
                const touch = e.touches[0];
                const rect = elevContainer.getBoundingClientRect();
                const scaleX = 900 / (rect.width || 900);
                const mx = (touch.clientX - rect.left) * scaleX - window._elevMargin.left;
                const maxX = 900 - window._elevMargin.left - window._elevMargin.right;
                if (mx >= 0 && mx <= maxX) {
                    window._updateElevHover(touch.clientX, touch.clientY, mx);
                }
            }
            function onElevTouchEnd() {
                if (window._clearElevHover) window._clearElevHover();
            }

            // Rimuovi eventuali listener precedenti prima di aggiungerne di nuovi
            if (elevContainer._onElevTouchMove) {
                elevContainer.removeEventListener('touchmove', elevContainer._onElevTouchMove);
                elevContainer.removeEventListener('touchend', elevContainer._onElevTouchEnd);
                elevContainer.removeEventListener('touchcancel', elevContainer._onElevTouchEnd);
            }
            elevContainer._onElevTouchMove = onElevTouchMove;
            elevContainer._onElevTouchEnd  = onElevTouchEnd;

            elevContainer.addEventListener('touchmove',   onElevTouchMove, { passive: false });
            elevContainer.addEventListener('touchend',    onElevTouchEnd,  { passive: true });
            elevContainer.addEventListener('touchcancel', onElevTouchEnd,  { passive: true });
        }

        // Chiamato dopo initMap
        function initSVPanel() {
            // Contextmenu (desktop right-click) sulla mappa principale
            map.on('contextmenu', function(e) {
                const p = findNearestPoint(e.latlng.lat, e.latlng.lng);
                if (p) openSVPanel(p);
            });
            setupMobileTouch();
        }


              function buildElevationChart(zoomDomain) {
            const pts = routeData.points;
            if (!pts || pts.length < 2) return;

            const container = document.getElementById('elevation-chart');
            container.innerHTML = '';

            // Rimuovi marker precedenti dalla mappa
            if (_hoverMapMarker) { map.removeLayer(_hoverMapMarker); _hoverMapMarker = null; }
            if (_zoomStartMarker) { map.removeLayer(_zoomStartMarker); _zoomStartMarker = null; }
            if (_zoomEndMarker)   { map.removeLayer(_zoomEndMarker);   _zoomEndMarker = null; }

            const totalW = 900;
            const totalH = 290;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const W = totalW - margin.left - margin.right;
            const H = totalH - margin.top - margin.bottom;

            // Dati: dist in km, ele in m
            const fullData = pts.map(p => ({ dist: p.dist / 1000, ele: p.ele }));
            const fullMaxDist = d3.max(fullData, d => d.dist);
            const isZoomed = !!zoomDomain;

            // Filtro dati per il dominio attuale
            const [d0, d1] = zoomDomain || [0, fullMaxDist];
            const data = fullData.filter(d => d.dist >= d0 && d.dist <= d1);
            if (data.length < 2) return;

            // Gradienti smoothed sull'intero dataset
            const rawG = [0];
            for (let i = 1; i < pts.length; i++) {
                const dDist = pts[i].dist - pts[i-1].dist;
                const dEle  = pts[i].ele  - pts[i-1].ele;
                rawG.push(dDist > 0 ? (dEle / dDist) * 100 : 0);
            }
            const smG = smoothGradient(rawG, 6);

            const xScale = d3.scaleLinear().domain([d0, d1]).range([0, W]);

            const minEle = d3.min(data, d => d.ele);
            const maxEle = d3.max(data, d => d.ele);
            const padTop = (maxEle - minEle) * 0.12 || 5;
            const yScale = d3.scaleLinear()
                .domain([minEle, maxEle + padTop])
                .range([H, 0]);

            const svg = d3.select(container).append('svg')
                .attr('viewBox', \`0 0 \${totalW} \${totalH}\`)
                .attr('preserveAspectRatio', 'xMidYMid meet')
                .style('width', '100%')
                .style('height', 'auto')
                .style('display', 'block')
                .style('vertical-align', 'bottom');

            // Clip-path per non sforare
            svg.append('defs').append('clipPath').attr('id', 'elev-clip')
                .append('rect').attr('width', W).attr('height', H);

            const g = svg.append('g')
                .attr('transform', \`translate(\${margin.left},\${margin.top})\`);

            // Assi
            const xAxisG = g.append('g').attr('transform', \`translate(0,\${H})\`);
            xAxisG.call(d3.axisBottom(xScale).ticks(10).tickFormat(d => d.toFixed(1) + ' km'))
                .selectAll('text').style('font-size', '11px');

            const yAxisG = g.append('g');
            yAxisG.call(d3.axisLeft(yScale).ticks(6).tickFormat(d => d + ' m'))
                .selectAll('text').style('font-size', '11px');

            g.append('text').attr('transform', 'rotate(-90)')
                .attr('x', -H/2).attr('y', -48)
                .attr('text-anchor', 'middle')
                .style('font-size', '11px').style('fill', '#6b7280').text('m');

            // Griglia
            const gridG = g.append('g').attr('class', 'grid');
            gridG.call(d3.axisLeft(yScale).ticks(6).tickSize(-W).tickFormat(''))
                .selectAll('line').style('stroke', '#e5e7eb').style('stroke-dasharray', '3,3');
            gridG.select('.domain').remove();

            // Area + linea colorate ‚Äî solo punti nel range visibile
            const chartG = g.append('g').attr('clip-path', 'url(#elev-clip)');

            // Indici nel dataset originale corrispondenti al range
            const startOrigIdx = fullData.findIndex(d => d.dist >= d0);
            const endOrigIdx   = fullData.findIndex(d => d.dist >  d1);
            const iEnd = endOrigIdx === -1 ? fullData.length : endOrigIdx;

            for (let i = Math.max(1, startOrigIdx); i < iEnd; i++) {
                const p1 = fullData[i-1], p2 = fullData[i];
                const color = getGradientColor(smG[i]);
                const path = \`M\${xScale(p1.dist)},\${yScale(p1.ele)} L\${xScale(p2.dist)},\${yScale(p2.ele)} L\${xScale(p2.dist)},\${H} L\${xScale(p1.dist)},\${H} Z\`;
                chartG.append('path').attr('d', path).attr('fill', color).attr('opacity', 0.7).style('pointer-events','none');
                chartG.append('line')
                    .attr('x1', xScale(p1.dist)).attr('y1', yScale(p1.ele))
                    .attr('x2', xScale(p2.dist)).attr('y2', yScale(p2.ele))
                    .attr('stroke', color).attr('stroke-width', 1.5).style('pointer-events','none');
            }

            // ‚îÄ‚îÄ Reset button rimosso ‚Äî doppio clic per reset ‚îÄ‚îÄ
            container.style.position = 'relative';
            if (isZoomed) {
                // Hint testuale piccolo
                const hint = document.createElement('div');
                hint.textContent = 'Doppio clic per reset zoom';
                hint.style.cssText = 'position:absolute;top:6px;right:8px;font-size:10px;color:#9ca3af;font-family:Inter,sans-serif;pointer-events:none;';
                container.appendChild(hint);
            }

            // ‚îÄ‚îÄ Tooltip e hover ‚îÄ‚îÄ
            // Riusa tooltip esistente se gi√† nel DOM (evita duplicati su rebuild)
            let tooltip = document.getElementById('elev-hover-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'elev-hover-tooltip';
                tooltip.style.cssText = 'position:fixed;pointer-events:none;display:none;background:rgba(15,15,15,0.92);color:#fff;padding:6px 12px;border-radius:6px;font-size:13px;font-weight:500;font-family:Inter,sans-serif;z-index:99999;white-space:nowrap;box-shadow:0 2px 10px rgba(0,0,0,0.35);border-left:3px solid #fc5200;';
                document.body.appendChild(tooltip);
            }
            tooltip.style.display = 'none'; // nascondi sempre al rebuild

            const hoverLine = g.append('line')
                .attr('y1', 0).attr('y2', H)
                .attr('stroke', '#555').attr('stroke-width', 1)
                .attr('stroke-dasharray', '4,3').attr('opacity', 0)
                .style('pointer-events', 'none');

            const hoverDot = g.append('circle')
                .attr('r', 5).attr('fill', '#fc5200')
                .attr('stroke', '#fff').attr('stroke-width', 2)
                .attr('opacity', 0).style('pointer-events', 'none');

            // Marker mappa hover (globale)
            _hoverMapMarker = L.circleMarker([0,0], {
                radius: 8, color: '#fc5200', fillColor: '#fc5200',
                fillOpacity: 0.9, weight: 2, opacity: 0
            }).addTo(map);

            // Marker inizio/fine zoom sulla mappa
            if (isZoomed) {
                // Trova i punti GPS corrispondenti a d0 e d1
                const startZoomIdx = fullData.findIndex(d => d.dist >= d0);
                let endZoomIdx = fullData.findIndex(d => d.dist >= d1);
                if (endZoomIdx === -1) endZoomIdx = fullData.length - 1;

                const spGPS = routeData.points[startZoomIdx];
                const epGPS = routeData.points[endZoomIdx];

                const zoomIconStart = L.divIcon({
                    className: '',
                    html: \`<div style="width:12px;height:12px;background:#3b82f6;border:2px solid #fff;border-radius:50%;box-shadow:0 1px 4px rgba(0,0,0,0.5)"></div>\`,
                    iconSize: [12, 12], iconAnchor: [6, 6]
                });
                const zoomIconEnd = L.divIcon({
                    className: '',
                    html: \`<div style="width:12px;height:12px;background:#8b5cf6;border:2px solid #fff;border-radius:50%;box-shadow:0 1px 4px rgba(0,0,0,0.5)"></div>\`,
                    iconSize: [12, 12], iconAnchor: [6, 6]
                });

                _zoomStartMarker = L.marker([spGPS.lat, spGPS.lon], { icon: zoomIconStart })
                    .addTo(map)
                    .bindTooltip(\`Inizio selezione: \${d0.toFixed(2)} km\`, { permanent: false });
                _zoomEndMarker = L.marker([epGPS.lat, epGPS.lon], { icon: zoomIconEnd })
                    .addTo(map)
                    .bindTooltip(\`Fine selezione: \${d1.toFixed(2)} km\`, { permanent: false });

                // Centra mappa sul tratto selezionato
                const zoomBounds = routeData.points
                    .slice(startZoomIdx, endZoomIdx + 1)
                    .map(p => [p.lat, p.lon]);
                map.fitBounds(zoomBounds, { padding: [40, 40] });
            }

            // Funzione condivisa per aggiornare hover
            function updateHover(clientX, clientY, svgX) {
                const dist = xScale.invert(svgX);
                // Binary search su fullData
                let lo = 0, hi = fullData.length - 1;
                while (lo < hi - 1) {
                    const mid = (lo + hi) >> 1;
                    if (fullData[mid].dist < dist) lo = mid; else hi = mid;
                }
                const ptIdx = Math.abs(fullData[lo].dist - dist) < Math.abs(fullData[hi].dist - dist) ? lo : hi;
                const pt = fullData[ptIdx];

                // Solo se il punto √® nel range visibile
                if (pt.dist < d0 || pt.dist > d1) return;

                const cx = xScale(pt.dist), cy = yScale(pt.ele);
                hoverLine.attr('x1', cx).attr('x2', cx).attr('opacity', 0.7);
                hoverDot.attr('cx', cx).attr('cy', cy).attr('opacity', 1);

                // Gradiente smoothed al punto corrente
                const grade = smG[ptIdx];
                const gradeColor = getGradientColor(grade);
                const gradeSign = grade > 0.05 ? '+' : '';
                const gradeBadge = \`<span style="display:inline-block;padding:1px 6px;border-radius:3px;background:\${gradeColor};color:#fff;font-size:11px;font-weight:700;margin-left:6px;">\${gradeSign}\${grade.toFixed(1)}%</span>\`;

                tooltip.innerHTML = '‚Üë <b>' + pt.ele.toFixed(0) + ' m</b> &nbsp;¬∑&nbsp; ' + pt.dist.toFixed(2) + ' km' + gradeBadge;
                tooltip.style.display = 'block';
                let tx = clientX + 16, ty = clientY - 38;
                if (tx + 200 > window.innerWidth) tx = clientX - 210;
                if (ty < 0) ty = clientY + 12;
                tooltip.style.left = tx + 'px';
                tooltip.style.top  = ty + 'px';

                const gp = routeData.points[ptIdx];
                _hoverMapMarker.setLatLng([gp.lat, gp.lon]);
                _hoverMapMarker.setStyle({ opacity: 1, fillOpacity: 0.9 });
            }

            function clearHover() {
                hoverLine.attr('opacity', 0);
                hoverDot.attr('opacity', 0);
                tooltip.style.display = 'none';
                if (_hoverMapMarker) _hoverMapMarker.setStyle({ opacity: 0, fillOpacity: 0 });
            }

            // Esponi hover per touch mobile
            window._updateElevHover = updateHover;
            window._clearElevHover = clearHover;

            // ‚îÄ‚îÄ Pannello statistiche selezione ‚îÄ‚îÄ
            const selPanel = document.createElement('div');
            selPanel.style.cssText = 'position:absolute;top:8px;left:50%;transform:translateX(-50%);display:none;background:rgba(15,15,15,0.92);color:#fff;padding:7px 16px;border-radius:8px;font-size:13px;font-family:Inter,sans-serif;z-index:9999;white-space:nowrap;box-shadow:0 2px 10px rgba(0,0,0,0.35);gap:18px;align-items:center;pointer-events:none;';
            container.appendChild(selPanel);

            function showSelectionStats(x0, x1) {
                const selD0 = xScale.invert(Math.min(x0, x1));
                const selD1 = xScale.invert(Math.max(x0, x1));

                let i0 = fullData.findIndex(d => d.dist >= selD0);
                let i1 = fullData.findIndex(d => d.dist >= selD1);
                if (i0 < 0) i0 = 0;
                if (i1 < 0) i1 = fullData.length - 1;
                if (i1 <= i0) return;

                const distKm = selD1 - selD0;
                let gain = 0, loss = 0;
                for (let i = i0 + 1; i <= i1; i++) {
                    const dEle = fullData[i].ele - fullData[i-1].ele;
                    if (dEle > 0) gain += dEle; else loss += Math.abs(dEle);
                }
                const distM = distKm * 1000;
                const netEle = fullData[i1].ele - fullData[i0].ele;
                const avgGrade = distM > 0 ? (netEle / distM) * 100 : 0;
                const gradeSign = avgGrade > 0 ? '+' : '';
                const gradeColor = getGradientColor(avgGrade);

                // Aggiorna pannello flottante sopra il chart
                selPanel.style.display = 'flex';
                selPanel.innerHTML = \`
                    <span>üìè <b>\${distKm.toFixed(2)} km</b></span>
                    <span style="color:#aaa">|</span>
                    <span>‚Üë <b style="color:#4ade80">+\${gain.toFixed(0)} m</b></span>
                    <span style="color:#aaa">|</span>
                    <span>‚Üì <b style="color:#60a5fa">-\${loss.toFixed(0)} m</b></span>
                    <span style="color:#aaa">|</span>
                    <span>‚õ∞ <b style="color:\${gradeColor}">\${gradeSign}\${avgGrade.toFixed(1)}%</b> media</span>
                \`;

                // Aggiorna anche la barra sotto il grafico
                const label = document.getElementById('sel-label');
                if (label) label.style.display = 'none';
                const sd = document.getElementById('sel-dist');
                const sg = document.getElementById('sel-gain');
                const sl = document.getElementById('sel-loss');
                const sgr = document.getElementById('sel-grade');
                if (sd) { sd.style.display = 'inline'; document.getElementById('sel-dist-val').textContent = distKm.toFixed(2) + ' km'; }
                if (sg) { sg.style.display = 'inline'; document.getElementById('sel-gain-val').textContent = '+' + gain.toFixed(0) + ' m'; }
                if (sl) { sl.style.display = 'inline'; document.getElementById('sel-loss-val').textContent = '-' + loss.toFixed(0) + ' m'; }
                if (sgr) { sgr.style.display = 'inline'; document.getElementById('sel-grade-val').style.color = gradeColor; document.getElementById('sel-grade-val').textContent = gradeSign + avgGrade.toFixed(1) + '%'; }
            }

            // ‚îÄ‚îÄ Brush per drag-to-zoom ‚îÄ‚îÄ
            const brushG = g.append('g').attr('class', 'brush');
            let isBrushing = false;

            const brush = d3.brushX()
                .extent([[0, 0], [W, H]])
                .on('start', () => { isBrushing = true; tooltip.style.display = 'none'; })
                .on('brush', function(event) {
                    if (!event.selection) return;
                    showSelectionStats(event.selection[0], event.selection[1]);
                })
                .on('end', function(event) {
                    isBrushing = false;
                    selPanel.style.display = 'none'; // nasconde pannello flottante
                    if (!event.selection) return;
                    const [x0, x1] = event.selection;
                    const newD0 = xScale.invert(x0);
                    const newD1 = xScale.invert(x1);
                    brushG.call(brush.move, null);
                    if (newD1 - newD0 > 0.1) buildElevationChart([newD0, newD1]);
                });

            brushG.call(brush);

            // Stile brush
            brushG.select('.selection')
                .style('fill', 'rgba(252,82,0,0.15)')
                .style('stroke', '#fc5200')
                .style('stroke-width', '1px');

            // Doppio clic = reset zoom
            brushG.on('dblclick', function() {
                buildElevationChart(null);
            });

            // ‚îÄ‚îÄ Esponi scale per il marker SV ‚îÄ‚îÄ
            window._elevXScale = xScale;
            window._elevYScale = yScale;
            window._elevG = g;
            window._elevMargin = margin;

            // ‚îÄ‚îÄ Click destro sull'altimetria ‚Üí apre pannello SV (solo desktop) ‚îÄ‚îÄ
            const svgNode = svg.node();
            svgNode.removeEventListener('contextmenu', svgNode._svContextMenu || null);
            svgNode._svContextMenu = function(event) {
                // Ignora completamente su touch/mobile
                if (event.pointerType === 'touch') { event.preventDefault(); return; }
                event.preventDefault();
                event.stopPropagation();
                const rect = svgNode.getBoundingClientRect();
                const scaleX = 900 / (rect.width || 900);
                const mx = (event.clientX - rect.left) * scaleX - margin.left;
                if (mx < 0 || mx > W) return;
                const distKm = xScale.invert(mx);
                const point = window._findNearestPointByDist && window._findNearestPointByDist(distKm);
                if (point && window._openSVPanel) window._openSVPanel(point);
            };
            svgNode.addEventListener('contextmenu', svgNode._svContextMenu);



            // Hover ‚Äî solo mouse, mai touch
            brushG.on('mousemove', function(event) {
                if (isBrushing) return;
                // Blocca qualsiasi evento touch simulato come mouse
                if (event.pointerType === 'touch' || event.pointerType === 'pen') return;
                if (event.sourceCapabilities && event.sourceCapabilities.firesTouchEvents) return;
                const [mx] = d3.pointer(event, g.node());
                updateHover(event.clientX, event.clientY, mx);
            })
            .on('mouseleave', function(event) {
                if (event.pointerType === 'touch' || event.pointerType === 'pen') return;
                clearHover();
            });

            // Blocca contextmenu da long-press mobile sull'SVG
            svgNode.addEventListener('contextmenu', function(e) { e.preventDefault(); }, { once: false });
        }

        
        // Climb Detection Functions
        function detectAndDisplayClimbs() {
            if (!routeData || !routeData.points) return;
            
            const SECTION_LENGTH = 50; // meters
            const MIN_SEGMENTS = 7; 
            const MIN_GRADE = 3;
            const MAX_GRADE_END = 1;
            const MAX_GAP_SEGMENTS = 5;
            const MIN_DIFFICULTY = 20;
            
            const sections = [];
            let currentStartIndex = 0;
            
            for (let i = 1; i < routeData.points.length; i++) {
                // dist is in METERS
                const distDiffMeters = routeData.points[i].dist - routeData.points[currentStartIndex].dist;
                
                if (distDiffMeters >= SECTION_LENGTH || i === routeData.points.length - 1) {
                    const altDiff = routeData.points[i].ele - routeData.points[currentStartIndex].ele;
                    const sectionGrade = distDiffMeters > 0 ? (altDiff / distDiffMeters) * 100 : 0;
                    
                    sections.push({
                        sectionIndex: sections.length,
                        startIndex: currentStartIndex,
                        endIndex: i,
                        distance: distDiffMeters,
                        elevation: altDiff,
                        grade: sectionGrade
                    });
                    
                    currentStartIndex = i;
                }
            }
            
            let climbs = [];
            let currentClimb = { startSegment: null, endSegment: null };
            
            sections.forEach((section, index) => {
                if (currentClimb.startSegment === null && section.grade >= MIN_GRADE) {
                    currentClimb.startSegment = section.sectionIndex;
                } else if (currentClimb.startSegment !== null && 
                          (section.grade < MAX_GRADE_END || index === sections.length - 1)) {
                    currentClimb.endSegment = section.sectionIndex - 1;
                    
                    if (currentClimb.endSegment >= currentClimb.startSegment &&
                        currentClimb.endSegment - currentClimb.startSegment >= MIN_SEGMENTS) {
                        climbs.push({ ...currentClimb });
                    }
                    
                    currentClimb = { startSegment: null, endSegment: null };
                }
            });
            
            for (let i = 1; i < climbs.length; i++) {
                const prevClimb = climbs[i - 1];
                const currentClimb = climbs[i];
                const gapSegments = currentClimb.startSegment - prevClimb.endSegment;
                
                if (gapSegments <= MAX_GAP_SEGMENTS) {
                    prevClimb.endSegment = currentClimb.endSegment;
                    climbs.splice(i, 1);
                    i--;
                }
            }
            
            detectedClimbs = [];
            climbs.forEach((climb, idx) => {
                const startIndex = sections[climb.startSegment].startIndex;
                const endIndex = sections[climb.endSegment].endIndex;
                
                const distMeters = routeData.points[endIndex].dist - routeData.points[startIndex].dist;
                const elevationGain = routeData.points[endIndex].ele - routeData.points[startIndex].ele;
                const avgGrade = (elevationGain / distMeters) * 100;
                const difficultyCoefficient = Math.pow(avgGrade, 2) * (distMeters / 1000);
                
                if (difficultyCoefficient < MIN_DIFFICULTY) return;
                
                // Get max gradient from sections (not individual points to avoid GPS noise)
                let maxGrade = 0;
                for (let s = climb.startSegment; s <= climb.endSegment; s++) {
                    if (sections[s].grade > maxGrade) maxGrade = sections[s].grade;
                }
                
                const coords = [];
                for (let i = startIndex; i <= endIndex; i++) {
                    coords.push([routeData.points[i].lat, routeData.points[i].lon]);
                }
                
                detectedClimbs.push({
                    startIndex,
                    endIndex,
                    startSegment: climb.startSegment,
                    endSegment: climb.endSegment,
                    distance: distMeters / 1000,
                    elevation: elevationGain,
                    avgGrade: avgGrade,
                    maxGrade: maxGrade,
                    difficulty: difficultyCoefficient,
                    coordinates: coords
                });
            });
            
            if (detectedClimbs.length > 0) {
                displayClimbsUI(sections);
                drawClimbsOnMap();
                document.getElementById('climbs-section').style.display = 'block';
            }
        }
        
        function getDifficultyColor(difficulty) {
            if (difficulty < 75) return '#9aca3c';
            if (difficulty < 150) return '#ffa500';
            if (difficulty < 300) return '#ff8c00';
            if (difficulty < 600) return '#ff4500';
            if (difficulty < 900) return '#b22222';
            if (difficulty < 1200) return '#800000';
            return '#000000';
        }
        
        function getDifficultyLabel(difficulty) {
            if (difficulty < 75) return 'Facile';
            if (difficulty < 150) return 'Moderata';
            if (difficulty < 300) return 'Impegnativa';
            if (difficulty < 600) return 'Difficile';
            if (difficulty < 900) return 'Estrema';
            if (difficulty < 1200) return 'HC';
            return 'Leggendaria';
        }
        
        function displayClimbsUI(sections) {
            const climbsList = document.getElementById('climbs-list');
            const climbsCount = document.getElementById('climbs-count');
            
            climbsCount.textContent = \`(\${detectedClimbs.length} \${detectedClimbs.length === 1 ? 'salita' : 'salite'})\`;
            climbsList.innerHTML = '';
            
            detectedClimbs.forEach((climb, index) => {
                const card = document.createElement('div');
                card.className = 'climb-card';
                
                const color = getDifficultyColor(climb.difficulty);
                
                card.innerHTML = \`
                    <div class="climb-number">\${index + 1}</div>
                    <div class="climb-difficulty" style="background-color: \${color}">
                        Difficolt√†: \${climb.difficulty.toFixed(0)}
                    </div>
                    <div class="climb-stats">
                        <div class="climb-stat">
                            <div class="climb-stat-label">Distanza</div>
                            <div class="climb-stat-value">\${climb.distance.toFixed(2)} km</div>
                        </div>
                        <div class="climb-stat">
                            <div class="climb-stat-label">Dislivello</div>
                            <div class="climb-stat-value">\${climb.elevation.toFixed(0)} m</div>
                        </div>
                        <div class="climb-stat">
                            <div class="climb-stat-label">Pendenza Media</div>
                            <div class="climb-stat-value">\${climb.avgGrade.toFixed(1)}%</div>
                        </div>
                        <div class="climb-stat">
                            <div class="climb-stat-label">Pendenza Max</div>
                            <div class="climb-stat-value">\${climb.maxGrade.toFixed(1)}%</div>
                        </div>
                    </div>
                \`;
                
                card.addEventListener('click', () => {
                    // Check if this card is already highlighted - if so, deselect
                    const wasHighlighted = card.classList.contains('highlighted');
                    
                    // Remove previous highlights and markers
                    document.querySelectorAll('.climb-card').forEach(c => c.classList.remove('highlighted'));
                    climbPolylines.forEach(marker => map.removeLayer(marker));
                    climbPolylines = [];
                    
                    // Remove elevation markers
                    const svg = d3.select('#elevation-chart svg');
                    svg.selectAll('.climb-elevation-marker').remove();
                    
                    // Hide detail chart
                    document.getElementById('climb-detail-chart').classList.remove('active');
                    
                    // If was already highlighted, just deselect and return
                    if (wasHighlighted) {
                        return;
                    }
                    
                    // Highlight this card
                    card.classList.add('highlighted');
                    
                    // Draw the detail chart for this climb
                    drawClimbDetailChart(climb, index, sections);
                    
                    // Zoom to climb area
                    const bounds = L.latLngBounds(climb.coordinates);
                    map.fitBounds(bounds, { padding: [50, 50] });
                    
                    // Add start marker with original gradient color
                    const startPoint = routeData.points[climb.startIndex];
                    const startGradient = smoothGradient(routeData.points.map(p => p.gradient), 6)[climb.startIndex];
                    const startColor = getGradientColor(startGradient);
                    
                    const startMarker = L.circleMarker([startPoint.lat, startPoint.lon], {
                        radius: 8,
                        fillColor: startColor,
                        color: '#000',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.9
                    }).addTo(map);
                    startMarker.bindPopup(\`<strong>Inizio Salita \${index + 1}</strong><br>Quota: \${startPoint.ele.toFixed(0)} m\`);
                    climbPolylines.push(startMarker);
                    
                    // Add end marker with original gradient color
                    const endPoint = routeData.points[climb.endIndex];
                    const endGradient = smoothGradient(routeData.points.map(p => p.gradient), 6)[climb.endIndex];
                    const endColor = getGradientColor(endGradient);
                    
                    const endMarker = L.circleMarker([endPoint.lat, endPoint.lon], {
                        radius: 8,
                        fillColor: endColor,
                        color: '#000',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.9
                    }).addTo(map);
                    endMarker.bindPopup(\`<strong>Fine Salita \${index + 1}</strong><br>Quota: \${endPoint.ele.toFixed(0)} m\`);
                    climbPolylines.push(endMarker);
                    
                    // Add markers on elevation chart using the current (possibly zoomed) scales
                    setTimeout(() => {
                        const svg = d3.select('#elevation-chart svg');
                        if (!svg.node()) return;
                        const chartGroup = svg.select('g');
                        if (!chartGroup.node()) return;

                        // Usa le scale globali aggiornate da buildElevationChart (zoom-aware)
                        const xS = window._elevXScale;
                        const yS = window._elevYScale;
                        if (!xS || !yS) return;

                        const pts = routeData.points;
                        const startPt = pts[climb.startIndex];
                        const endPt   = pts[climb.endIndex];

                        const [d0, d1] = xS.domain();

                        // Disegna solo se il punto √® nel dominio visibile
                        if (startPt.dist / 1000 >= d0 && startPt.dist / 1000 <= d1) {
                            chartGroup.append('circle')
                                .attr('class', 'climb-elevation-marker')
                                .attr('cx', xS(startPt.dist / 1000))
                                .attr('cy', yS(startPt.ele))
                                .attr('r', 7).attr('fill', startColor)
                                .attr('stroke', '#fff').attr('stroke-width', 2)
                                .style('pointer-events', 'none');
                        }

                        if (endPt.dist / 1000 >= d0 && endPt.dist / 1000 <= d1) {
                            chartGroup.append('circle')
                                .attr('class', 'climb-elevation-marker')
                                .attr('cx', xS(endPt.dist / 1000))
                                .attr('cy', yS(endPt.ele))
                                .attr('r', 7).attr('fill', endColor)
                                .attr('stroke', '#fff').attr('stroke-width', 2)
                                .style('pointer-events', 'none');
                        }
                    }, 100);
                });
                
                climbsList.appendChild(card);
            });
        }
        
        function drawClimbsOnMap() {
            // Non disegniamo pi√π le polyline colorate
            // Le salite saranno visualizzate solo quando selezionate
            climbPolylines = [];
        }

        function closeClimbDetail() {
            document.getElementById('climb-detail-chart').classList.remove('active');
            document.querySelectorAll('.climb-card').forEach(c => c.classList.remove('highlighted'));
            climbPolylines.forEach(marker => map.removeLayer(marker));
            climbPolylines = [];
            const svg = d3.select('#elevation-chart svg');
            svg.selectAll('.climb-elevation-marker').remove();
        }

        let currentClimbData = null; // Memorizza i dati della salita corrente
        
        function drawClimbDetailChart(climb, climbIndex, sections) {
            // Salva i dati per il ridisegno con lo slider
            currentClimbData = { climb, climbIndex, sections };
            
            // Get climb sections
            const climbSections = [];
            for (let s = climb.startSegment; s <= climb.endSegment; s++) {
                climbSections.push(sections[s]);
            }
            
            if (climbSections.length === 0) return;
            
            // CONFIGURA LO SLIDER in base alla lunghezza della salita
            const slider = document.getElementById('sections-slider');
            const totalSections = climbSections.length;
            
            const minBlocks = 2;
            const maxBlocks = totalSections;
            
            slider.min = minBlocks;
            slider.max = maxBlocks;
            
            if (!slider.hasAttribute('data-initialized')) {
                slider.value = Math.max(4, Math.ceil(maxBlocks / 3));
                slider.setAttribute('data-initialized', 'true');
            }
            
            const numBlocks = parseInt(slider.value);
            document.getElementById('slider-value').textContent = numBlocks;
            
            // DISTRIBUZIONE UNIFORME
            const groupedSections = [];
            
            if (numBlocks >= totalSections) {
                climbSections.forEach(s => {
                    groupedSections.push({
                        distance: s.distance,
                        elevation: s.elevation,
                        grade: s.grade
                    });
                });
            } else {
                const step = totalSections / numBlocks;
                
                for (let i = 0; i < numBlocks; i++) {
                    const startIdx = Math.floor(i * step);
                    const endIdx = Math.min(Math.floor((i + 1) * step), totalSections);
                    
                    const group = climbSections.slice(startIdx, endIdx);
                    
                    let totalDist = 0;
                    let weightedGrade = 0;
                    let totalEle = 0;
                    
                    group.forEach(s => {
                        totalDist += s.distance;
                        weightedGrade += s.grade * s.distance;
                        totalEle += s.elevation;
                    });
                    
                    const avgGrade = totalDist > 0 ? weightedGrade / totalDist : 0;
                    
                    groupedSections.push({
                        distance: totalDist,
                        elevation: totalEle,
                        grade: avgGrade
                    });
                }
            }
            
            const svg = d3.select('#climb-detail-svg');
            svg.selectAll('*').remove();
            
            const container = document.getElementById('climb-detail-svg');
            const width = container.clientWidth || 1200;
            const height = 220;
            const margin = { top: 20, right: 80, bottom: 50, left: 80 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            document.getElementById('climb-detail-title').textContent = 
                \`Salita \${climbIndex + 1} - \${climb.distance.toFixed(2)} km, \${climb.elevation.toFixed(0)} m, \${climb.avgGrade.toFixed(1)}%\`;
            
            // Prepara i dati - USA ALTITUDINI REALI non cumulative
            const sectionData = [];
            
            for (let i = 0; i < groupedSections.length; i++) {
                const section = groupedSections[i];
                
                // Trova gli indici delle sezioni originali
                let sectionStartIdx, sectionEndIdx;
                
                if (numBlocks >= totalSections) {
                    // Usa tutte le sezioni originali
                    const origSection = climbSections[i];
                    sectionStartIdx = origSection.startIndex;
                    sectionEndIdx = origSection.endIndex;
                } else {
                    // Trova l'intervallo per questo blocco raggruppato
                    const step = totalSections / numBlocks;
                    const startSectionIdx = Math.floor(i * step);
                    let endSectionIdx = Math.min(Math.floor((i + 1) * step) - 1, totalSections - 1);
                    
                    // FORZA l'ultimo blocco ad arrivare fino alla fine
                    if (i === groupedSections.length - 1) {
                        endSectionIdx = totalSections - 1;
                    }
                    
                    sectionStartIdx = climbSections[startSectionIdx].startIndex;
                    sectionEndIdx = climbSections[endSectionIdx].endIndex;
                }
                
                // Ottieni altitudini reali dai punti GPS
                const startEle = routeData.points[sectionStartIdx].ele;
                
                // Per l'ultimo blocco, usa SEMPRE climb.endIndex
                const actualEndIdx = (i === groupedSections.length - 1) ? climb.endIndex : sectionEndIdx;
                const endEle = routeData.points[actualEndIdx].ele;
                
                const startDist = (routeData.points[sectionStartIdx].dist - routeData.points[climb.startIndex].dist) / 1000;
                let endDist = (routeData.points[actualEndIdx].dist - routeData.points[climb.startIndex].dist) / 1000;
                
                // FORZA l'ultimo blocco ad arrivare esattamente a climb.distance
                if (i === groupedSections.length - 1) {
                    console.log('LAST BLOCK DEBUG:');
                    console.log('- actualEndIdx:', actualEndIdx);
                    console.log('- climb.endIndex:', climb.endIndex);
                    console.log('- endDist calculated:', endDist);
                    console.log('- climb.distance:', climb.distance);
                    endDist = climb.distance;
                    console.log('- endDist FORCED to:', endDist);
                }
                
                sectionData.push({
                    index: i,
                    startDist: startDist,
                    endDist: endDist,
                    startEle: startEle,
                    endEle: endEle,
                    grade: section.grade,
                    distance: section.distance / 1000
                });
            }
            
            const totalDist = climb.distance; // Usa la lunghezza TOTALE della salita per riempire tutto
            const minEle = Math.min(...sectionData.map(s => Math.min(s.startEle, s.endEle)));
            const maxEle = Math.max(...sectionData.map(s => Math.max(s.startEle, s.endEle)));
            const eleRange = maxEle - minEle;
            
            // SCALES - USA TUTTA LA LARGHEZZA con la distanza totale della salita
            const xScale = d3.scaleLinear()
                .domain([0, totalDist])
                .range([0, chartWidth]);
            
            const yScale = d3.scaleLinear()
                .domain([minEle - eleRange * 0.05, maxEle + eleRange * 0.1])
                .range([chartHeight, 0]);
            
            const g = svg.append('g')
                .attr('transform', \`translate(\${margin.left},\${margin.top})\`);
            
            // Background
            const bgGradient = svg.append('defs')
                .append('linearGradient')
                .attr('id', 'bgGradient')
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '0%').attr('y2', '100%');
            
            bgGradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#ffffff');
            
            bgGradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#ffffff');
            
            g.append('rect')
                .attr('width', chartWidth)
                .attr('height', chartHeight)
                .attr('fill', 'url(#bgGradient)');
            
            // Clip-path per evitare che il grafico esca dall'area
            svg.select('defs').append('clipPath')
                .attr('id', 'chart-clip')
                .append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', chartWidth)
                .attr('height', chartHeight);
            
            // Gruppo con clip-path per tutti gli elementi del grafico
            const clippedG = g.append('g')
                .attr('clip-path', 'url(#chart-clip)');
            
            // Parametri 3D
            const depth = 35;
            const perspectiveAngle = 15;
            const offsetX = depth * Math.cos(perspectiveAngle * Math.PI / 180);
            const offsetY = depth * Math.sin(perspectiveAngle * Math.PI / 180);
            
            // Disegna ogni blocco stile Parlasco (profilo continuo pulito)
            sectionData.forEach((section, idx) => {
                const color = getGradientColor(section.grade);
                
                const x1 = xScale(section.startDist);
                const x2 = xScale(section.endDist);
                const y1 = yScale(section.startEle);
                const y2 = yScale(section.endEle);
                
                // DEBUG ultimo blocco
                if (idx === sectionData.length - 1) {
                    console.log('DRAW LAST BLOCK:');
                    console.log('- section.endDist:', section.endDist);
                    console.log('- totalDist:', totalDist);
                    console.log('- xScale domain:', xScale.domain());
                    console.log('- xScale range:', xScale.range());
                    console.log('- x2 calculated:', x2);
                    console.log('- chartWidth:', chartWidth);
                }
                
                // Per l'ULTIMO blocco, estendi x2 fino al bordo (compensando l'offset 3D)
                const x2Final = (idx === sectionData.length - 1) ? x2 + offsetX : x2;
                
                // FACCIA FRONTALE - tutto il blocco colorato
                const frontPath = \`M \${x1},\${chartHeight} L \${x1},\${y1} L \${x2Final},\${y2} L \${x2Final},\${chartHeight} Z\`;
                
                clippedG.append('path')
                    .attr('d', frontPath)
                    .attr('fill', color)
                    .attr('stroke', 'none');
                
                // FACCIA SUPERIORE - pi√π chiara
                const topPath = \`M \${x1},\${y1} L \${x2Final},\${y2} L \${x2Final - offsetX},\${y2 - offsetY} L \${x1 - offsetX},\${y1 - offsetY} Z\`;
                
                clippedG.append('path')
                    .attr('d', topPath)
                    .attr('fill', d3.color(color).brighter(0.4))
                    .attr('stroke', 'none');
                
                // FACCIA LATERALE DESTRA solo per l'ULTIMO blocco
                if (idx === sectionData.length - 1) {
                    const rightSidePath = \`M \${x2Final},\${y2} L \${x2Final},\${chartHeight} L \${x2Final - offsetX},\${chartHeight - offsetY} L \${x2Final - offsetX},\${y2 - offsetY} Z\`;
                    
                    clippedG.append('path')
                        .attr('d', rightSidePath)
                        .attr('fill', d3.color(color).darker(1.0))
                        .attr('stroke', 'none');
                }
                
                // PERCENTUALE IN BASSO
                const midX = (x1 + x2) / 2;
                
                g.append('text')
                    .attr('x', midX)
                    .attr('y', chartHeight + 20)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#444')
                    .attr('font-size', '11px')
                    .attr('font-weight', 'bold')
                    .text(\`\${section.grade.toFixed(1)}%\`);
            });
            
            // MARKER DI DISTANZA ogni 500m + finale
            const markers = [];
            for (let dist = 0; dist <= totalDist; dist += 0.5) {
                if (dist <= totalDist) markers.push(dist);
            }
            if (markers[markers.length - 1] !== totalDist) {
                markers.push(totalDist);
            }
            
            markers.forEach(dist => {
                const x = xScale(dist);
                let ele = minEle;
                for (const section of sectionData) {
                    if (dist >= section.startDist && dist <= section.endDist) {
                        const ratio = (dist - section.startDist) / (section.endDist - section.startDist);
                        ele = section.startEle + ratio * (section.endEle - section.startEle);
                        break;
                    }
                }
                const y = yScale(ele);
                
                // Linea tratteggiata
                g.append('line')
                    .attr('x1', x).attr('y1', y)
                    .attr('x2', x).attr('y2', chartHeight)
                    .attr('stroke', '#aaa')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '2,3')
                    .attr('opacity', 0.6);
                
                // Label distanza
                g.append('text')
                    .attr('x', x)
                    .attr('y', chartHeight + 38)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#888')
                    .attr('font-size', '9px')
                    .text(dist.toFixed(1));
            });
            
            // SCALA GRADIENTE a destra
            const legendWidth = 20;
            const legendHeight = 120;
            const legendX = chartWidth + 20;
            const legendY = (chartHeight - legendHeight) / 2;
            
            // Crea gradiente per la legenda
            const legendGradient = svg.select('defs').append('linearGradient')
                .attr('id', 'legendGradient')
                .attr('x1', '0%').attr('y1', '100%')
                .attr('x2', '0%').attr('y2', '0%');
            
            // Aggiungi colori della scala
            const gradientStops = [
                { offset: 0, grade: -5 },
                { offset: 20, grade: 0 },
                { offset: 40, grade: 3 },
                { offset: 60, grade: 6 },
                { offset: 80, grade: 10 },
                { offset: 100, grade: 15 }
            ];
            
            gradientStops.forEach(stop => {
                legendGradient.append('stop')
                    .attr('offset', \`\${stop.offset}%\`)
                    .attr('stop-color', getGradientColor(stop.grade));
            });
            
            // Disegna rettangolo legenda
            g.append('rect')
                .attr('x', legendX)
                .attr('y', legendY)
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .attr('fill', 'url(#legendGradient)')
                .attr('stroke', '#999')
                .attr('stroke-width', 1);
            
            // Aggiungi etichette percentuali
            const legendLabels = [
                { y: legendY + legendHeight, text: '0%' },
                { y: legendY + legendHeight * 0.67, text: '5%' },
                { y: legendY + legendHeight * 0.33, text: '10%' },
                { y: legendY, text: '15%+' }
            ];
            
            legendLabels.forEach(label => {
                g.append('text')
                    .attr('x', legendX + legendWidth + 8)
                    .attr('y', label.y + 4)
                    .attr('fill', '#666')
                    .attr('font-size', '10px')
                    .text(label.text);
            });
            
            // Titolo legenda
            g.append('text')
                .attr('x', legendX + legendWidth / 2)
                .attr('y', legendY - 10)
                .attr('text-anchor', 'middle')
                .attr('fill', '#444')
                .attr('font-size', '10px')
                .attr('font-weight', 'bold')
                .text('Pendenza');
            
            // Asse Y
            const yAxis = d3.axisLeft(yScale)
                .ticks(6)
                .tickFormat(d => Math.round(d) + ' m');
            
            g.append('g')
                .call(yAxis)
                .style('font-size', '10px');
            
            // Linea base
            g.append('line')
                .attr('x1', 0).attr('y1', chartHeight)
                .attr('x2', chartWidth).attr('y2', chartHeight)
                .attr('stroke', '#333')
                .attr('stroke-width', 2);
            
            document.getElementById('climb-detail-chart').classList.add('active');
        }
        
        // Event listener per lo slider
        document.addEventListener('DOMContentLoaded', () => {
            const slider = document.getElementById('sections-slider');
            if (slider) {
                slider.addEventListener('input', (e) => {
                    document.getElementById('slider-value').textContent = e.target.value;
                    if (currentClimbData) {
                        drawClimbDetailChart(
                            currentClimbData.climb, 
                            currentClimbData.climbIndex, 
                            currentClimbData.sections
                        );
                    }
                });
            }
        });
</script>
</body>
</html>`;

function buildRouteTab(race) {
    return `
        <div id="route-tab-container" style="
            margin: -20px;
            height: calc(100vh - 140px);
            display: flex;
            flex-direction: column;
        ">
            <iframe
                id="route-visualizer-iframe"
                style="flex: 1; width: 100%; border: none; display: block;"
                title="Route Visualizer"
            ></iframe>
        </div>
    `;
}

window.initRouteTab = function() {
    const iframe = document.getElementById('route-visualizer-iframe');
    if (!iframe) return;

    if (iframe.dataset.loaded === 'true') return;
    iframe.dataset.loaded = 'true';

    const blob = new Blob([ROUTE_VISUALIZER_HTML], { type: 'text/html' });
    iframe.src = URL.createObjectURL(blob);

    iframe.onload = function() {
        const gpx = window.gpxTraceData;
        if (gpx && gpx.points) {
            setTimeout(() => {
                iframe.contentWindow.postMessage({
                    type: 'loadGpxPoints',
                    points: gpx.points
                }, '*');
            }, 300);
        }
    };
};

window.buildRouteTab = buildRouteTab;