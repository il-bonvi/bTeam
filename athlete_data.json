{
  "id": "i115436",
  "name": "Andrea Bonvicin",
  "firstname": "Andrea",
  "lastname": "Bonvicin",
  "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/41478503-e393-4981-a067-2afde35a2200",
  "measurement_preference": "meters",
  "weight_pref_lb": false,
  "fahrenheit": false,
  "wind_speed": "KMH",
  "rain": "MM",
  "weight": null,
  "email": "bonvicinandrea96@gmail.com",
  "sex": "M",
  "city": "Trento",
  "state": "Trentino",
  "country": "Italy",
  "bikes": [
    {
      "id": "b5685794",
      "name": "Bsr",
      "distance": 1639762.0,
      "primary": false
    },
    {
      "id": "b12920635",
      "name": "Ergo",
      "distance": 0.0,
      "primary": false
    },
    {
      "id": "b14930372",
      "name": "Nebula ",
      "distance": 14149839.0,
      "primary": false
    }
  ],
  "shoes": [
    {
      "id": "g9320444",
      "name": "ASICS GT-1000",
      "distance": 25569.0,
      "primary": false
    },
    {
      "id": "g9320446",
      "name": "PUMA Velociy Nitro",
      "distance": 25156.0,
      "primary": false
    },
    {
      "id": "g26185723",
      "name": "La Sportiva Ultra Raptor II",
      "distance": 0.0,
      "primary": false
    },
    {
      "id": "g26185730",
      "name": "Adidas Terrex Skychaser",
      "distance": 48178.0,
      "primary": false
    },
    {
      "id": "g26185746",
      "name": "Scarpa rubata",
      "distance": 39714.0,
      "primary": false
    }
  ],
  "timezone": "Europe/Rome",
  "locale": "en",
  "date_format": "EEE_dd_MMM_yyyy",
  "time_format": "HH_mm",
  "visibility": "PRIVATE",
  "icu_last_seen": "2026-01-30T19:50:11.324+00:00",
  "status": "ACTIVE",
  "status_updated": null,
  "icu_resting_hr": 47,
  "icu_weight": 90.4,
  "icu_weight_sync": "NONE",
  "icu_activated": "2023-03-15T00:00:00.000+00:00",
  "icu_queue_pos": null,
  "icu_admin": null,
  "icu_friend_invite_token": "1zcibc1bq2jpdouh",
  "icu_permission": "WRITE",
  "icu_effort_secs": [
    1,
    3,
    5,
    8,
    10,
    15,
    20,
    30,
    40,
    50,
    60,
    120,
    180,
    240,
    300,
    360,
    480,
    570,
    600,
    720,
    900,
    1200,
    1800,
    2400,
    3600,
    5400,
    7200,
    10800
  ],
  "icu_coach": false,
  "bio": "Cycling Coach\n\n<em><strong>BFT Burzoni VO2 Team Pink</strong></em>\n\n<em><strong>COMAL Trentino Cycling Academy</strong></em>\n\n",
  "website": "https://linktr.ee/bonvicin.coaching",
  "icu_date_of_birth": "1996-06-09",
  "icu_api_key": "6njh1i49l5hdcbj71d034nyjt",
  "icu_type_settings": [],
  "icu_form_as_percent": true,
  "icu_mmp_days": 90,
  "icu_wellness_prompt": false,
  "wellness_last_prompt_date": "2026-01-30",
  "icu_wellness_keys": [
    "weight",
    "restingHR",
    "hrv",
    "sleep",
    "sleepQuality",
    "soreness",
    "fatigue",
    "stress",
    "mood",
    "motivation",
    "injury",
    "comments",
    "respiration",
    "readiness",
    "bodyFat",
    "sleepScore",
    "Ciclo",
    "menstrualPhase",
    "spO2"
  ],
  "private_wellness_keys": [
    "menstrualPhase",
    "mood",
    "comments"
  ],
  "icu_track_menstrual_cycle": false,
  "icu_menstrual_cycle_perm": "WRITE",
  "activity_rpe_prompt": true,
  "coach_ticks": [],
  "icu_garmin_health": true,
  "icu_garmin_training": true,
  "icu_garmin_sync_activities": true,
  "garmin_sync_activity_types": null,
  "garmin_sync_after": null,
  "icu_garmin_download_wellness": false,
  "icu_garmin_upload_workouts": true,
  "icu_garmin_outdoor_power_range": 2.5,
  "icu_garmin_hr_range": 1.5,
  "garmin_pace_range": 2.5,
  "garmin_power_target": "POWER_LAP",
  "icu_garmin_last_upload": "2026-01-30T19:40:03.129+00:00",
  "icu_garmin_upload_filters": null,
  "icu_garmin_wellness_keys": [
    "weight",
    "restingHR",
    "kcalConsumed",
    "sleep",
    "sleepScore",
    "sleepQuality",
    "spO2",
    "hrv"
  ],
  "open_step_duration": 600,
  "polar_scope": "accesslink.read_all",
  "polar_sync_activities": true,
  "polar_sync_activity_types": null,
  "polar_download_wellness": false,
  "polar_wellness_keys": null,
  "suunto_scope": null,
  "suunto_user_id": null,
  "suunto_sync_activities": null,
  "suunto_sync_activity_types": null,
  "suunto_upload_workouts": null,
  "suunto_outdoor_power_range": 2.5,
  "suunto_hr_range": 1.5,
  "suunto_pace_range": 2.5,
  "suunto_last_upload": null,
  "suunto_upload_filters": null,
  "suunto_download_wellness": false,
  "coros_user_id": null,
  "coros_sync_activities": false,
  "coros_upload_workouts": false,
  "coros_download_wellness": false,
  "coros_last_upload": null,
  "concept2_user_id": null,
  "concept2_sync_activities": false,
  "zepp_user_id": null,
  "zepp_sync_activities": false,
  "zepp_upload_workouts": false,
  "zepp_download_wellness": false,
  "huawei_user_id": null,
  "huawei_sync_activities": false,
  "huawei_upload_workouts": false,
  "huawei_download_wellness": false,
  "wahoo_user_id": "1155999",
  "wahoo_sync_activities": true,
  "wahoo_upload_workouts": true,
  "zwift_user_id": "e78f838c-b75c-4891-9c76-eda7b3e72960",
  "zwift_sync_activities": true,
  "zwift_upload_workouts": true,
  "dropbox_scope": null,
  "oura_scope": null,
  "oura_wellness_keys": null,
  "whoop_scope": "offline read:recovery read:cycles read:sleep read:body_measurement read:workout",
  "whoop_wellness_keys": [
    "sleep",
    "restingHR",
    "hrv",
    "readiness",
    "respiration"
  ],
  "google_scope": null,
  "google_wellness_keys": null,
  "icu_email_verified": true,
  "icu_email_disabled": null,
  "icu_send_achievements": true,
  "icu_send_newsletter": true,
  "icu_send_private_chat": true,
  "icu_send_private_msg": true,
  "icu_send_follow_req": true,
  "icu_send_group_chat": true,
  "icu_send_group_msg": true,
  "icu_send_activity_chat": true,
  "icu_send_followed_activity_chat": false,
  "icu_send_coached_activity_chat": false,
  "icu_send_activity_msg": true,
  "icu_send_coach_me_req": true,
  "icu_send_gear_alerts": false,
  "icu_send_plan_for_week": false,
  "include_descr_in_plan_for_week": false,
  "icu_send_followed_new_activity": false,
  "icu_send_coached_new_activity": false,
  "icu_send_coach_tick": true,
  "strava_allowed": null,
  "strava_id": 33830131,
  "scope": "read,activity:write,activity:read,activity:read_all,profile:write,profile:read_all,read_all",
  "strava_sync_activities": true,
  "strava_sync_activity_types": null,
  "strava_sync_other_activities": true,
  "ignore_strava_gear": false,
  "update_strava_name": true,
  "add_weather_to_strava_descr": false,
  "height": 1.99,
  "height_units": "CM",
  "plan": "SUPPORTER",
  "plan_expires": null,
  "trial_end_date": null,
  "sponsored_by_chat_id": null,
  "has_password": true,
  "beta_user": true,
  "currency": "eur",
  "training_plan_id": null,
  "training_plan_start_date": null,
  "icu_tags": [],
  "icu_notes": "",
  "strava_authorized": true,
  "sportSettings": [
    {
      "id": 519318,
      "athlete_id": "i115436",
      "types": [
        "Ride",
        "VirtualRide",
        "MountainBikeRide",
        "GravelRide",
        "TrackRide"
      ],
      "warmup_time": 1200,
      "cooldown_time": 600,
      "ftp": 270,
      "indoor_ftp": 270,
      "w_prime": 30000,
      "p_max": 1500,
      "power_zones": [
        60,
        80,
        90,
        105,
        135,
        300,
        999
      ],
      "sweet_spot_min": 83,
      "sweet_spot_max": 95,
      "power_spike_threshold": 100,
      "power_zone_names": [
        "Active Recovery",
        "Endurance",
        "Tempo",
        "Threshold",
        "VO2Max",
        "Anaerobic",
        "MAX"
      ],
      "ftp_est_min_secs": 720,
      "use_laps_for_power_intervals": false,
      "keep_all_laps_for_power_intervals": true,
      "after_kj0": 2500,
      "after_kj1": null,
      "power_field": null,
      "lthr": 166,
      "max_hr": 183,
      "hr_zones": [
        120,
        142,
        153,
        166,
        176,
        183
      ],
      "hr_zone_names": [
        "Recovery",
        "Aerobic",
        "Tempo",
        "Threshold",
        "VO2max",
        "5+"
      ],
      "hr_load_type": "HRSS",
      "hrrc_min_percent": 100.0,
      "threshold_pace": null,
      "pace_units": null,
      "pace_zones": null,
      "pace_zone_names": null,
      "pace_load_type": null,
      "gap_model": "NONE",
      "elevation_correction": "NO",
      "use_gap_zone_times": false,
      "best_effort_distances": null,
      "pace_curve_start": 100.0,
      "load_order": "POWER_HR_PACE",
      "tiz_order": "POWER_HR_PACE",
      "workout_order": "POWER_HR_PACE",
      "interval_display": "POWER_HR_PACE",
      "default_gear_id": "b14930372",
      "default_indoor_gear_id": null,
      "extract_workouts": false,
      "show_pauses": 610,
      "ignore_velocity": false,
      "default_workout_time": null,
      "update_activity_name_from_workout": true,
      "created": "2023-03-15T11:54:05.231+00:00",
      "updated": "2026-01-09T20:54:53.645+00:00",
      "mmp_model": {
        "type": "FFT_CURVES",
        "criticalPower": 250,
        "wPrime": 21930,
        "pMax": 503,
        "inputPointIndexes": [
          96,
          101
        ],
        "ftp": 255
      },
      "display": {
        "colorScheme": "LOAD",
        "lowIntensity": 50,
        "highIntensity": 90,
        "lowLoad": 70,
        "highLoad": 350,
        "usePairedWorkoutColor": false,
        "ignoreWorkoutColors": false,
        "showAverageHR": true,
        "showNormalizedWatts": true,
        "showLoad": true,
        "showWork": true,
        "showWorkAboveFTP": true,
        "showWeightLifted": true,
        "showAveragePower": false,
        "showRPE": true,
        "showFeel": true,
        "showPace": true,
        "showGAP": false,
        "showIntensity": true,
        "showName": true,
        "showIntervals": false,
        "showSkylineChart": true,
        "showPairedWorkoutChart": false,
        "showDescription": false,
        "showStartTime": false,
        "preciseDistance": false,
        "shrinkWarmup": true,
        "shrinkCooldown": true,
        "shrinkCommute": true,
        "color": "#0863b2",
        "color2": "#0a76d5"
      },
      "activity_field_ids": [
        396106,
        396108,
        396109,
        396107,
        396057,
        396058,
        396059,
        396060,
        396061,
        396327,
        405268,
        707263,
        743949,
        743950,
        743951,
        743952,
        743953,
        743954,
        743955,
        761540
      ],
      "activity_charts": {
        "home": [
          {
            "id": "365386",
            "width": null,
            "height": null
          },
          {
            "id": "365399",
            "width": null,
            "height": null
          },
          {
            "id": "402902",
            "width": null,
            "height": null
          },
          {
            "id": "365430",
            "width": null,
            "height": null
          },
          {
            "id": "365432",
            "width": null,
            "height": null
          },
          {
            "id": "435213",
            "width": null,
            "height": null
          },
          {
            "id": "367557",
            "width": null,
            "height": null
          },
          {
            "id": "367559",
            "width": null,
            "height": null
          },
          {
            "id": "435220",
            "width": null,
            "height": null
          }
        ],
        "power": [
          {
            "id": "power-zones",
            "width": null,
            "height": null
          },
          {
            "id": "power-histogram",
            "width": null,
            "height": null
          },
          {
            "id": "power-curves",
            "width": null,
            "height": null
          },
          {
            "id": "power-hr-trace",
            "width": null,
            "height": null
          },
          {
            "id": "power-hr",
            "width": null,
            "height": null
          },
          {
            "id": "279119",
            "width": null,
            "height": null
          },
          {
            "id": "279116",
            "width": null,
            "height": null
          },
          {
            "id": "279120",
            "width": null,
            "height": null
          },
          {
            "id": "lr-balance",
            "width": null,
            "height": null
          },
          {
            "id": "659632",
            "width": null,
            "height": null
          }
        ],
        "hr": [
          {
            "id": "hr-zones",
            "width": null,
            "height": null
          },
          {
            "id": "cz-TimeatAltitude",
            "width": null,
            "height": null
          },
          {
            "id": "hr-histogram",
            "width": null,
            "height": null
          },
          {
            "id": "hr-curves",
            "width": null,
            "height": null
          },
          {
            "id": "hr-cumulative-time",
            "width": null,
            "height": null
          },
          {
            "id": "hr-load-model",
            "width": null,
            "height": null
          }
        ],
        "pace": [
          {
            "id": "pace-zones",
            "width": null,
            "height": null
          },
          {
            "id": "cz-TimeatAltitude",
            "width": null,
            "height": null
          },
          {
            "id": "cz-COREsHeatZones",
            "width": null,
            "height": null
          },
          {
            "id": "cz-Temperature",
            "width": null,
            "height": null
          },
          {
            "id": "cz-VentilatoryThresholds",
            "width": null,
            "height": null
          },
          {
            "id": "pace-histogram",
            "width": null,
            "height": null
          },
          {
            "id": "pace-curves",
            "width": null,
            "height": null
          }
        ],
        "data": [
          {
            "id": "interval-table",
            "width": null,
            "height": null
          }
        ],
        "tab1": [
          {
            "id": "timeline",
            "width": null,
            "height": null
          },
          {
            "id": "435213",
            "width": null,
            "height": null
          },
          {
            "id": "435202",
            "width": null,
            "height": null
          },
          {
            "id": "402895",
            "width": null,
            "height": null
          },
          {
            "id": "435212",
            "width": null,
            "height": null
          },
          {
            "id": "435200",
            "width": null,
            "height": null
          },
          {
            "id": "402935",
            "width": null,
            "height": null
          },
          {
            "id": "402927",
            "width": null,
            "height": null
          },
          {
            "id": "402924",
            "width": null,
            "height": null
          },
          {
            "id": "365446",
            "width": null,
            "height": null
          },
          {
            "id": "879857",
            "width": null,
            "height": null
          },
          {
            "id": "698414",
            "width": null,
            "height": null
          }
        ],
        "tab2": [
          {
            "id": "timeline",
            "width": null,
            "height": null
          },
          {
            "id": "701227",
            "width": null,
            "height": null
          },
          {
            "id": "786823",
            "width": null,
            "height": null
          }
        ],
        "tab3": [
          {
            "id": "timeline",
            "width": null,
            "height": null
          }
        ],
        "tab4": [
          {
            "id": "timeline",
            "width": null,
            "height": null
          },
          {
            "id": "726157",
            "width": null,
            "height": null
          },
          {
            "id": "730882",
            "width": null,
            "height": null
          },
          {
            "id": "721804",
            "width": null,
            "height": null
          },
          {
            "id": "719790",
            "width": null,
            "height": null
          },
          {
            "id": "721862",
            "width": null,
            "height": null
          },
          {
            "id": "726115",
            "width": null,
            "height": null
          },
          {
            "id": "726134",
            "width": null,
            "height": null
          },
          {
            "id": "726186",
            "width": null,
            "height": null
          },
          {
            "id": "726147",
            "width": null,
            "height": null
          },
          {
            "id": "726169",
            "width": null,
            "height": null
          }
        ],
        "tab5": [
          {
            "id": "timeline",
            "width": null,
            "height": null
          },
          {
            "id": "704583",
            "width": null,
            "height": null
          },
          {
            "id": "704586",
            "width": null,
            "height": null
          }
        ],
        "tab6": [
          {
            "id": "738097",
            "width": null,
            "height": null
          },
          {
            "id": "786823",
            "width": null,
            "height": null
          },
          {
            "id": "timeline",
            "width": null,
            "height": null
          },
          {
            "id": "692587",
            "width": null,
            "height": null
          },
          {
            "id": "694442",
            "width": null,
            "height": null
          }
        ],
        "tab7": [
          {
            "id": "682991",
            "width": null,
            "height": null
          },
          {
            "id": "700869",
            "width": null,
            "height": null
          },
          {
            "id": "timeline",
            "width": null,
            "height": null
          },
          {
            "id": "679342",
            "width": null,
            "height": null
          }
        ],
        "tab8": [
          {
            "id": "692565",
            "width": null,
            "height": null
          },
          {
            "id": "692573",
            "width": null,
            "height": null
          },
          {
            "id": "694414",
            "width": null,
            "height": null
          },
          {
            "id": "694421",
            "width": null,
            "height": null
          }
        ],
        "tab9": [
          {
            "id": "681239",
            "width": null,
            "height": null
          },
          {
            "id": "timeline",
            "width": null,
            "height": null
          },
          {
            "id": "679342",
            "width": null,
            "height": null
          },
          {
            "id": "688703",
            "width": null,
            "height": null
          },
          {
            "id": "700863",
            "width": null,
            "height": null
          }
        ],
        "route": [],
        "tab10": [
          {
            "id": "701227",
            "width": null,
            "height": null
          },
          {
            "id": "timeline",
            "width": null,
            "height": null
          },
          {
            "id": "709448",
            "width": null,
            "height": null
          },
          {
            "id": "692550",
            "width": null,
            "height": null
          },
          {
            "id": "692558",
            "width": null,
            "height": null
          },
          {
            "id": "692559",
            "width": null,
            "height": null
          },
          {
            "id": "692560",
            "width": null,
            "height": null
          }
        ],
        "tab11": [
          {
            "id": "timeline",
            "width": null,
            "height": null
          }
        ],
        "tab12": [
          {
            "id": "701595",
            "width": null,
            "height": null
          },
          {
            "id": "704641",
            "width": null,
            "height": null
          },
          {
            "id": "timeline",
            "width": null,
            "height": null
          },
          {
            "id": "879838",
            "width": null,
            "height": null
          }
        ],
        "tab13": [
          {
            "id": "793076",
            "width": null,
            "height": null
          }
        ]
      },
      "custom_field_ids": [
        757625
      ],
      "custom_field_values": {
        "VO2MAX": 61
      },
      "custom_zones_ids": [
        786926
      ],
      "other": false,
      "eFTPSupported": true,
      "use_distance_for_intervals": false
    },
    {
      "id": 519319,
      "athlete_id": "i115436",
      "types": [
        "Run",
        "VirtualRun",
        "TrailRun"
      ],
      "warmup_time": 300,
      "cooldown_time": 300,
      "ftp": null,
      "indoor_ftp": null,
      "w_prime": null,
      "p_max": null,
      "power_zones": null,
      "sweet_spot_min": null,
      "sweet_spot_max": null,
      "power_spike_threshold": 30,
      "power_zone_names": null,
      "ftp_est_min_secs": 300,
      "use_laps_for_power_intervals": false,
      "keep_all_laps_for_power_intervals": true,
      "after_kj0": null,
      "after_kj1": null,
      "power_field": null,
      "lthr": 168,
      "max_hr": 185,
      "hr_zones": [
        141,
        150,
        158,
        167,
        172,
        177,
        185
      ],
      "hr_zone_names": [
        "Recovery",
        "Aerobic",
        "Tempo",
        "SubThreshold",
        "SuperThreshold",
        "Aerobic Capacity",
        "Anaerobic"
      ],
      "hr_load_type": "HRSS",
      "hrrc_min_percent": 100.0,
      "threshold_pace": null,
      "pace_units": "MINS_KM",
      "pace_zones": null,
      "pace_zone_names": null,
      "pace_load_type": "RUN",
      "gap_model": "STRAVA_RUN",
      "elevation_correction": "AUTO",
      "use_gap_zone_times": true,
      "best_effort_distances": [
        400.0,
        800.0,
        1500.0,
        1609.34,
        3000.0,
        5000.0,
        10000.0,
        21097.5,
        42195.0
      ],
      "pace_curve_start": 1000.0,
      "load_order": "POWER_PACE_HR",
      "tiz_order": "POWER_HR_PACE",
      "workout_order": "POWER_HR_PACE",
      "interval_display": "POWER_HR_PACE",
      "default_gear_id": "g9320446",
      "default_indoor_gear_id": null,
      "extract_workouts": false,
      "show_pauses": 600,
      "ignore_velocity": false,
      "default_workout_time": null,
      "update_activity_name_from_workout": true,
      "created": "2023-03-15T11:54:05.231+00:00",
      "updated": "2025-10-10T18:05:01.453+00:00",
      "mmp_model": null,
      "display": {
        "colorScheme": "SOLID",
        "lowIntensity": 50,
        "highIntensity": 90,
        "lowLoad": 25,
        "highLoad": 250,
        "usePairedWorkoutColor": false,
        "ignoreWorkoutColors": false,
        "showAverageHR": true,
        "showNormalizedWatts": true,
        "showLoad": true,
        "showWork": false,
        "showWorkAboveFTP": false,
        "showWeightLifted": true,
        "showAveragePower": false,
        "showRPE": true,
        "showFeel": true,
        "showPace": true,
        "showGAP": true,
        "showIntensity": false,
        "showName": true,
        "showIntervals": false,
        "showSkylineChart": true,
        "showPairedWorkoutChart": false,
        "showDescription": false,
        "showStartTime": false,
        "preciseDistance": false,
        "shrinkWarmup": true,
        "shrinkCooldown": true,
        "shrinkCommute": true,
        "color": "#8C564B",
        "color2": "#a7675a"
      },
      "activity_field_ids": [],
      "activity_charts": {
        "home": null,
        "power": [
          {
            "id": "power-zones",
            "width": null,
            "height": null
          },
          {
            "id": "cz-TimeatAltitude",
            "width": null,
            "height": null
          },
          {
            "id": "power-histogram",
            "width": null,
            "height": null
          },
          {
            "id": "power-curves",
            "width": null,
            "height": null
          },
          {
            "id": "power-hr",
            "width": null,
            "height": null
          },
          {
            "id": "power-hr-trace",
            "width": null,
            "height": null
          },
          {
            "id": "lr-balance",
            "width": null,
            "height": null
          }
        ],
        "hr": [
          {
            "id": "hr-zones",
            "width": null,
            "height": null
          },
          {
            "id": "cz-TimeatAltitude",
            "width": null,
            "height": null
          },
          {
            "id": "hr-histogram",
            "width": null,
            "height": null
          },
          {
            "id": "hr-curves",
            "width": null,
            "height": null
          },
          {
            "id": "hr-cumulative-time",
            "width": null,
            "height": null
          },
          {
            "id": "hr-load-model",
            "width": null,
            "height": null
          }
        ],
        "pace": [
          {
            "id": "pace-zones",
            "width": null,
            "height": null
          },
          {
            "id": "cz-TimeatAltitude",
            "width": null,
            "height": null
          },
          {
            "id": "pace-histogram",
            "width": null,
            "height": null
          },
          {
            "id": "pace-curves",
            "width": null,
            "height": null
          }
        ],
        "data": null
      },
      "custom_field_ids": [],
      "custom_field_values": {},
      "custom_zones_ids": [
        786926
      ],
      "other": false,
      "eFTPSupported": false,
      "use_distance_for_intervals": false
    },
    {
      "id": 519320,
      "athlete_id": "i115436",
      "types": [
        "Swim",
        "OpenWaterSwim"
      ],
      "warmup_time": 300,
      "cooldown_time": 300,
      "ftp": null,
      "indoor_ftp": null,
      "w_prime": null,
      "p_max": null,
      "power_zones": null,
      "sweet_spot_min": null,
      "sweet_spot_max": null,
      "power_spike_threshold": 30,
      "power_zone_names": null,
      "ftp_est_min_secs": 300,
      "use_laps_for_power_intervals": false,
      "keep_all_laps_for_power_intervals": true,
      "after_kj0": null,
      "after_kj1": null,
      "power_field": null,
      "lthr": 168,
      "max_hr": 185,
      "hr_zones": [
        141,
        150,
        158,
        167,
        172,
        177,
        185
      ],
      "hr_zone_names": [
        "Recovery",
        "Aerobic",
        "Tempo",
        "SubThreshold",
        "SuperThreshold",
        "Aerobic Capacity",
        "Anaerobic"
      ],
      "hr_load_type": "HRSS",
      "hrrc_min_percent": 100.0,
      "threshold_pace": 0.8333333,
      "pace_units": "SECS_100M",
      "pace_zones": null,
      "pace_zone_names": null,
      "pace_load_type": "SWIM",
      "gap_model": "NONE",
      "elevation_correction": "NO",
      "use_gap_zone_times": false,
      "best_effort_distances": [
        45.719997,
        50.0,
        91.439995,
        100.0,
        200.0,
        400.0,
        800.0,
        1500.0,
        3800.0
      ],
      "pace_curve_start": 100.0,
      "load_order": "POWER_HR_PACE",
      "tiz_order": "POWER_HR_PACE",
      "workout_order": "POWER_HR_PACE",
      "interval_display": "POWER_PACE_HR",
      "default_gear_id": null,
      "default_indoor_gear_id": null,
      "extract_workouts": false,
      "show_pauses": 600,
      "ignore_velocity": false,
      "default_workout_time": null,
      "update_activity_name_from_workout": true,
      "created": "2023-03-15T11:54:05.231+00:00",
      "updated": "2025-08-01T14:05:31.351+00:00",
      "mmp_model": null,
      "display": {
        "colorScheme": "SOLID",
        "lowIntensity": 50,
        "highIntensity": 90,
        "lowLoad": 25,
        "highLoad": 250,
        "usePairedWorkoutColor": false,
        "ignoreWorkoutColors": false,
        "showAverageHR": true,
        "showNormalizedWatts": true,
        "showLoad": true,
        "showWork": false,
        "showWorkAboveFTP": false,
        "showWeightLifted": true,
        "showAveragePower": false,
        "showRPE": true,
        "showFeel": true,
        "showPace": true,
        "showGAP": false,
        "showIntensity": false,
        "showName": true,
        "showIntervals": false,
        "showSkylineChart": true,
        "showPairedWorkoutChart": false,
        "showDescription": false,
        "showStartTime": false,
        "preciseDistance": false,
        "shrinkWarmup": true,
        "shrinkCooldown": true,
        "shrinkCommute": true,
        "color": "#119EB1",
        "color2": "#14bdd4"
      },
      "activity_field_ids": [],
      "activity_charts": {
        "home": null,
        "power": null,
        "hr": null,
        "pace": null,
        "data": null
      },
      "custom_field_ids": [],
      "custom_field_values": {},
      "custom_zones_ids": [],
      "other": false,
      "eFTPSupported": false,
      "use_distance_for_intervals": true
    },
    {
      "id": 519321,
      "athlete_id": "i115436",
      "types": [
        "Other"
      ],
      "warmup_time": 1200,
      "cooldown_time": 600,
      "ftp": null,
      "indoor_ftp": null,
      "w_prime": null,
      "p_max": null,
      "power_zones": null,
      "sweet_spot_min": null,
      "sweet_spot_max": null,
      "power_spike_threshold": 30,
      "power_zone_names": null,
      "ftp_est_min_secs": 300,
      "use_laps_for_power_intervals": false,
      "keep_all_laps_for_power_intervals": true,
      "after_kj0": null,
      "after_kj1": null,
      "power_field": null,
      "lthr": 160,
      "max_hr": 185,
      "hr_zones": [
        134,
        142,
        150,
        159,
        163,
        168,
        185
      ],
      "hr_zone_names": [
        "Recovery",
        "Aerobic",
        "Tempo",
        "SubThreshold",
        "SuperThreshold",
        "Aerobic Capacity",
        "Anaerobic"
      ],
      "hr_load_type": "HRSS",
      "hrrc_min_percent": 100.0,
      "threshold_pace": null,
      "pace_units": null,
      "pace_zones": null,
      "pace_zone_names": null,
      "pace_load_type": "RUN",
      "gap_model": "NONE",
      "elevation_correction": "NO",
      "use_gap_zone_times": false,
      "best_effort_distances": [
        400.0,
        800.0,
        1500.0,
        1609.34,
        3000.0,
        5000.0,
        10000.0,
        21097.5,
        42195.0
      ],
      "pace_curve_start": 1000.0,
      "load_order": "POWER_HR_PACE",
      "tiz_order": "POWER_HR_PACE",
      "workout_order": "POWER_HR_PACE",
      "interval_display": "POWER_HR_PACE",
      "default_gear_id": null,
      "default_indoor_gear_id": null,
      "extract_workouts": false,
      "show_pauses": 600,
      "ignore_velocity": false,
      "default_workout_time": null,
      "update_activity_name_from_workout": true,
      "created": "2023-03-15T11:54:05.231+00:00",
      "updated": "2025-10-10T18:14:16.739+00:00",
      "mmp_model": null,
      "display": {
        "colorScheme": "SOLID",
        "lowIntensity": 50,
        "highIntensity": 90,
        "lowLoad": 25,
        "highLoad": 250,
        "usePairedWorkoutColor": false,
        "ignoreWorkoutColors": false,
        "showAverageHR": true,
        "showNormalizedWatts": true,
        "showLoad": true,
        "showWork": false,
        "showWorkAboveFTP": false,
        "showWeightLifted": true,
        "showAveragePower": false,
        "showRPE": true,
        "showFeel": true,
        "showPace": true,
        "showGAP": false,
        "showIntensity": false,
        "showName": true,
        "showIntervals": false,
        "showSkylineChart": true,
        "showPairedWorkoutChart": false,
        "showDescription": false,
        "showStartTime": false,
        "preciseDistance": false,
        "shrinkWarmup": true,
        "shrinkCooldown": true,
        "shrinkCommute": true,
        "color": "#7F7F7F",
        "color2": "#989898"
      },
      "activity_field_ids": [],
      "activity_charts": {
        "home": null,
        "power": [
          {
            "id": "power-zones",
            "width": null,
            "height": null
          },
          {
            "id": "cz-TimeatAltitude",
            "width": null,
            "height": null
          },
          {
            "id": "power-histogram",
            "width": null,
            "height": null
          },
          {
            "id": "power-curves",
            "width": null,
            "height": null
          },
          {
            "id": "power-hr",
            "width": null,
            "height": null
          },
          {
            "id": "power-hr-trace",
            "width": null,
            "height": null
          },
          {
            "id": "lr-balance",
            "width": null,
            "height": null
          }
        ],
        "hr": [
          {
            "id": "hr-zones",
            "width": null,
            "height": null
          },
          {
            "id": "cz-TimeatAltitude",
            "width": null,
            "height": null
          },
          {
            "id": "hr-histogram",
            "width": null,
            "height": null
          },
          {
            "id": "hr-curves",
            "width": null,
            "height": null
          },
          {
            "id": "hr-cumulative-time",
            "width": null,
            "height": null
          },
          {
            "id": "hr-load-model",
            "width": null,
            "height": null
          }
        ],
        "pace": [
          {
            "id": "pace-zones",
            "width": null,
            "height": null
          },
          {
            "id": "cz-TimeatAltitude",
            "width": null,
            "height": null
          },
          {
            "id": "pace-histogram",
            "width": null,
            "height": null
          },
          {
            "id": "pace-curves",
            "width": null,
            "height": null
          }
        ],
        "data": null
      },
      "custom_field_ids": [],
      "custom_field_values": {},
      "custom_zones_ids": [
        786926
      ],
      "other": true,
      "eFTPSupported": false,
      "use_distance_for_intervals": false
    }
  ],
  "custom_items": [
    {
      "id": 273887,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PUBLIC",
      "name": "Power enhanced",
      "description": "Power with W/Kg (custom stream needed), average and trends for work, zones (2-...-5) + HR10s",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/69dc929d-06e6-471d-9950-d81cdae19e5b",
      "content": {
        "id": null,
        "name": "Power enhanced",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "Power",
            "color": "#1F77B4FF",
            "extras": [
              {
                "id": 2,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.11
              },
              {
                "id": 3,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 3,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.12
              },
              {
                "id": 4,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 4,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.12
              },
              {
                "id": 5,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 5,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.11
              }
            ],
            "legend": false,
            "stream": "watts",
            "transform": "none",
            "areaOpacity": 0.15,
            "lineOpacity": 2,
            "strokeWidth": 1.01,
            "transformArgs": {
              "secs": 60
            }
          },
          {
            "id": 3,
            "axis": null,
            "text": "AVG",
            "color": "#FF00FFFF",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "work_interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "strokeWidth": 1.5,
            "transformArgs": null
          },
          {
            "id": 4,
            "axis": null,
            "text": "TREND",
            "color": "#3FF032FF",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "work_interval_linear_trend",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "strokeWidth": 1.75,
            "transformArgs": null
          },
          {
            "id": 9,
            "axis": null,
            "text": "HR10s",
            "color": "#dd0447",
            "extras": [],
            "legend": true,
            "stream": "raw_heartrate",
            "transform": "moving_avg",
            "areaOpacity": 0.02,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 10
            }
          },
          {
            "id": 10,
            "axis": null,
            "text": "W/Kg",
            "color": "#1F77B4",
            "extras": [],
            "legend": true,
            "stream": "WKg",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": null
          },
          {
            "id": 11,
            "axis": null,
            "text": "Temp",
            "color": "#c0b570",
            "extras": [],
            "legend": true,
            "stream": "temp",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 20
            }
          }
        ],
        "title": null,
        "height": 90,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "",
        "y2AxisLabel": null
      },
      "usage_count": 22,
      "index": 1,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-30T10:02:58.859+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 276696,
      "athlete_id": "i115436",
      "type": "ACTIVITY_STREAM",
      "visibility": "PRIVATE",
      "name": "Calculated power",
      "description": "Calculated power based on VAM and average gradient over 10s.",
      "image": null,
      "content": {
        "pos": true,
        "code": "Calculatedpower",
        "link": "https://en.wikipedia.org/wiki/VAM_(bicycling)",
        "name": "Calculated power",
        "type": "numeric",
        "color": "#0E7BF1",
        "units": "watts",
        "legend": "Est. power",
        "script": "{\nlet alt = icu.streams.fixed_altitude\nlet dist =  icu.streams.distance\nlet kg = activity.icu_weight\n\nfor (let i = 0; i < data.length; i++) data[i] = ((alt[i+10]-alt[i] )*360)/(((alt[i+10]-alt[i])/(dist[i+10]-dist[i]))*1000+200)*kg\n}",
        "convert": "",
        "no_nulls": false,
        "legend_pos": "topLeft",
        "domain_zero": true,
        "area_opacity": "0.05",
        "line_opacity": "0.7",
        "number_format": ".0f",
        "fit_record_field": null,
        "short_description": "Calculated power",
        "processes_fit_messages": false
      },
      "usage_count": 40,
      "index": 1,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-13T18:51:07.247+00:00",
      "from_athlete": {
        "id": "5916126",
        "name": "Kosio Varbenov",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/6e64b2bb-f5ec-41a5-a836-67cfedb0db4b",
        "city": "Graz",
        "state": "Steiermark",
        "country": "Austria",
        "timezone": "Europe/Vienna",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 182043
    },
    {
      "id": 276698,
      "athlete_id": "i115436",
      "type": "INTERVAL_FIELD",
      "visibility": "PRIVATE",
      "name": "Average Temp",
      "description": "Average ambient temperature",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "AverageTemp",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#FF7F0E",
        "gauge": true,
        "total": null,
        "units": "C",
        "prefix": null,
        "script": "{\nlet temp = streams.get(\"temp\").data\nlet tot = 0\nlet c = 0\nfor (let i = interval.start_index; i < interval.end_index; i++) {\n  let v = temp[i]\n  if (v) {\n    tot += v\n    ++c\n  }\n}\n\nc ? tot/c : null\n}",
        "suffix": "C",
        "average": null,
        "convert": "",
        "example": 22.5,
        "options": null,
        "pace_units": null,
        "number_format": ".1f",
        "processes_fit_messages": false,
        "name": "Average Temp"
      },
      "usage_count": 2,
      "index": 1,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-08-15T18:36:53.516+00:00",
      "from_athlete": {
        "id": "2049151",
        "name": "David (intervals.icu)",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/37e18c85-cac7-4c45-8dc8-2e716f4b66d2",
        "city": "Cape Town",
        "state": "Western Cape",
        "country": "South Africa",
        "timezone": "Africa/Johannesburg",
        "sex": "M",
        "bio": "Software Engineer and keen cyclist!",
        "website": "https://intervals.icu",
        "email": null
      },
      "from_id": 103398
    },
    {
      "id": 357169,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Cycling time in zones + 2weeks trend",
      "description": "Time in zones using 3 zone model + hours total and 14 days trend. ONLY CYCLING",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/bb3baa1c-e3d8-423b-9423-443cab24ec35",
      "content": {
        "id": "4we3cq17",
        "name": "Cycling time in zones + 2weeks trend",
        "plots": [
          {
            "id": "time_in_s3",
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(221,4,71,0.5)",
            "text": "Z5+",
            "type": "bars",
            "field": "time_in_s3",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z5, Z6 and Z7",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z5+",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z5, Z6 and Z7",
            "showOnCalendar": false,
            "calendarOptions": {
              "day1": true,
              "day2": true,
              "day3": true,
              "day4": true,
              "day5": true,
              "day6": true,
              "day7": true,
              "label": "Z5+ ",
              "units": " hours",
              "weekPopupDay": 7,
              "weekSummaryDay": 7
            },
            "invertSubWellness": false
          },
          {
            "id": "time_in_s2",
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(255,127,14, 0.5)",
            "text": "Z3+4",
            "type": "bars",
            "field": "time_in_s2",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z3 and Z4",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(255,127,14)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z3+4",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z3 and Z4",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": "time_in_s1",
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(0,158,0, 0.4)",
            "text": "Z1+2",
            "type": "bars",
            "field": "time_in_s1",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z1 and Z2",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(0,158,0)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z1+2",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z1 and Z2",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 1,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#00000045",
            "text": "Day",
            "type": "dot",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#00000029",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "top",
            "strokeWidth": 0.2,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#8d824700",
            "text": "Weekly",
            "type": "line",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#33333380",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": 0,
            "band": 0.1,
            "fill": "#FF00FF30",
            "text": "TND",
            "type": "line",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#DD04A7FF",
            "aggArgs": {
              "days": 14,
              "factor": 7
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 0.01,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "moving_avg",
            "min": 0,
            "band": 0.05,
            "fill": "rgba(102,51,204,0.3)",
            "text": "kJTND",
            "type": "line",
            "field": "work",
            "scale": "kJ",
            "stack": "",
            "title": "Total work",
            "extras": [],
            "filter": "round0",
            "radius": 3,
            "stroke": "rgb(102,51,204)",
            "aggArgs": {
              "days": 14,
              "factor": 7
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Work",
            "markerValue": "right",
            "strokeWidth": 0.01,
            "i18nTitleKey": "Total work",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Time in Zones & TND",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Power zones (h)",
        "y2AxisLabel": " ",
        "stackTo100Percent": false
      },
      "usage_count": 42,
      "index": 1,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-09-14T12:50:40.882+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 365386,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HISTOGRAM",
      "visibility": "FOLLOWERS",
      "name": "Power 2s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Power 2s",
        "plots": [
          {
            "id": 1,
            "text": "Power 2s",
            "type": "bars",
            "color": "#1F77B4FF",
            "legend": false,
            "stream": "raw_watts",
            "transform": "moving_avg",
            "bucketSize": 20,
            "areaOpacity": 0.75,
            "lineOpacity": 0.7,
            "trimPercent": 0.5,
            "transformArgs": {
              "secs": 2
            },
            "hideLastBucket": false,
            "hideFirstBucket": true
          }
        ],
        "width": 540,
        "height": 320
      },
      "usage_count": 1,
      "index": 1,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-08-21T14:49:54.865+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396057,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "AeT",
      "description": "Estimacin AeT by controlmetrics.es",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "AeT",
        "icon": "mdi-airplane",
        "link": null,
        "type": "numeric",
        "color": "#130AF9",
        "gauge": true,
        "total": null,
        "units": "w",
        "inline": false,
        "prefix": null,
        "script": "(secret sauce)",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "AeT"
      },
      "usage_count": 40,
      "index": 1,
      "hide_script": true,
      "hidden_by_id": "10385309",
      "updated": "2025-06-25T18:33:40.706+00:00",
      "from_athlete": {
        "id": "10385309",
        "name": "Luisma Gallego",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c7e97937-d358-425a-8acc-2c726c4b5cff",
        "city": "Cubelles",
        "state": "Barcelona",
        "country": "Spain",
        "timezone": "Europe/Madrid",
        "sex": "M",
        "bio": "Physiology Technician\n\nPersonal Trainer EREPS accreditation number 107429\n\nInstructor at Sportcoach.es\n\nPublications: https://dialnet.unirioja.es/servlet/articulo?codigo=8443236\n\nParticipant in several podcasts about training and cycling\n\nwww.controlmetrics.es\n",
        "website": "https://www.controlmetrics.es",
        "email": null
      },
      "from_id": 390234
    },
    {
      "id": 402895,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HEATMAP",
      "visibility": "FOLLOWERS",
      "name": "Power / Cadence 3s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Power / Cadence 3s",
        "plots": [
          {
            "id": "x",
            "max": null,
            "min": null,
            "text": "Power",
            "color": "#6633cc",
            "legend": false,
            "stream": "watts_3s",
            "transform": "none",
            "bucketSize": 5,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": null,
            "hideLastBucket": false,
            "hideFirstBucket": true
          },
          {
            "id": "y",
            "max": null,
            "min": null,
            "text": "Cadence",
            "color": "#ff00ff",
            "legend": false,
            "stream": "cadence",
            "transform": "moving_avg",
            "bucketSize": 1.5,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 3
            },
            "hideLastBucket": false,
            "hideFirstBucket": true
          }
        ],
        "steps": null,
        "width": 510,
        "height": 350,
        "opacity": null,
        "colorScale": "interpolateWarm",
        "contourPlot": false,
        "trimPercent": null
      },
      "usage_count": 1,
      "index": 1,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:17:15.957+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 616421,
      "athlete_id": "i115436",
      "type": "ACTIVITY_PANEL",
      "visibility": "PRIVATE",
      "name": "Interfaccia",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Interfaccia",
        "width": 330,
        "config": {
          "id": 1,
          "type": "tree",
          "items": [
            {
              "id": 2,
              "type": "tree",
              "items": [
                {
                  "id": 10,
                  "type": "tree",
                  "items": [
                    {
                      "id": 12,
                      "type": "tree",
                      "items": [
                        {
                          "id": 14,
                          "fieldId": "start_date_local",
                          "noLabel": true,
                          "dataAsLabel": true
                        },
                        {
                          "id": 15,
                          "fieldId": "distance",
                          "noLabel": true,
                          "showUnits": true
                        }
                      ]
                    },
                    {
                      "id": 13,
                      "type": "tree",
                      "items": [
                        {
                          "id": 16,
                          "fieldId": "start_time",
                          "noLabel": true,
                          "dataAsLabel": true
                        },
                        {
                          "id": 17,
                          "fieldId": "moving_time",
                          "noLabel": true
                        }
                      ]
                    }
                  ],
                  "layout": "row"
                },
                {
                  "id": 11,
                  "type": "tree",
                  "items": [
                    {
                      "id": 18,
                      "layout": "inline",
                      "fieldId": "coasting_time"
                    },
                    {
                      "id": 19,
                      "layout": "inline",
                      "fieldId": "average_speed"
                    },
                    {
                      "id": 20,
                      "layout": "inline",
                      "fieldId": "total_elevation_gain"
                    }
                  ],
                  "layout": "table",
                  "alignItems": "start",
                  "justifyContent": "space-around"
                },
                {
                  "id": 66,
                  "layout": "inline",
                  "fieldId": "trainer",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "column",
              "alignItems": "start",
              "justifyContent": "space-around"
            },
            {
              "id": 3,
              "type": "tree",
              "items": [
                {
                  "id": 21,
                  "layout": "inline",
                  "fieldId": "pace",
                  "showUnits": true
                },
                {
                  "id": 22,
                  "layout": "inline",
                  "fieldId": "gap",
                  "showUnits": true
                },
                {
                  "id": 23,
                  "layout": "inline",
                  "fieldId": "threshold_pace",
                  "showUnits": true
                }
              ],
              "layout": "table"
            },
            {
              "id": 4,
              "type": "tree",
              "items": [
                {
                  "id": 24,
                  "type": "tree",
                  "items": [
                    {
                      "id": 27,
                      "fieldId": "kg_lifted",
                      "showUnits": true
                    },
                    {
                      "id": 28,
                      "fieldId": "icu_intensity"
                    },
                    {
                      "id": 29,
                      "fieldId": "icu_training_load"
                    },
                    {
                      "id": 30,
                      "fieldId": "icu_rpe"
                    },
                    {
                      "id": 31,
                      "fieldId": "feel"
                    }
                  ],
                  "layout": "row"
                },
                {
                  "id": 25,
                  "layout": "inline",
                  "fieldId": "tiz_class"
                },
                {
                  "id": 26,
                  "type": "tree",
                  "items": [
                    {
                      "id": 32,
                      "fieldId": "compliance"
                    },
                    {
                      "id": 33,
                      "fieldId": "coach_tick"
                    },
                    {
                      "id": 34,
                      "fieldId": "wind_summary"
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center"
                }
              ],
              "layout": "column"
            },
            {
              "id": 5,
              "type": "tree",
              "items": [
                {
                  "id": 35,
                  "layout": "inline",
                  "fieldId": "average_heartrate"
                },
                {
                  "id": 36,
                  "layout": "inline",
                  "fieldId": "max_heartrate"
                },
                {
                  "id": 37,
                  "layout": "inline",
                  "fieldId": "hrrc"
                },
                {
                  "id": 38,
                  "layout": "inline",
                  "fieldId": "trimp"
                }
              ]
            },
            {
              "id": 6,
              "type": "tree",
              "items": [
                {
                  "id": 39,
                  "layout": "inline",
                  "fieldId": "icu_weighted_avg_watts",
                  "showUnits": true
                },
                {
                  "id": 40,
                  "layout": "inline",
                  "fieldId": "icu_average_watts",
                  "showUnits": true
                },
                {
                  "id": 41,
                  "layout": "inline",
                  "fieldId": "icu_variability_index"
                },
                {
                  "id": 42,
                  "layout": "inline",
                  "fieldId": "icu_power_hr"
                },
                {
                  "id": 43,
                  "layout": "inline",
                  "fieldId": "icu_efficiency_factor"
                },
                {
                  "id": 44,
                  "layout": "inline",
                  "fieldId": "avg_lr_balance"
                }
              ],
              "layout": "table",
              "alignItems": "start",
              "justifyContent": "space-around"
            },
            {
              "id": 7,
              "type": "tree",
              "items": [
                {
                  "id": 45,
                  "layout": "inline",
                  "fieldId": "icu_ctl"
                },
                {
                  "id": 46,
                  "layout": "inline",
                  "fieldId": "icu_atl"
                },
                {
                  "id": 47,
                  "layout": "inline",
                  "fieldId": "form"
                },
                {
                  "id": 48,
                  "layout": "inline",
                  "fieldId": "session_rpe"
                },
                {
                  "id": 49,
                  "layout": "inline",
                  "fieldId": "average_cadence"
                },
                {
                  "id": 50,
                  "layout": "inline",
                  "fieldId": "average_stride"
                }
              ]
            },
            {
              "id": 8,
              "type": "tree",
              "items": [
                {
                  "id": 65,
                  "layout": "inline",
                  "fieldId": "icu_weight",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 51,
                  "layout": "inline",
                  "fieldId": "icu_ftp",
                  "showUnits": true
                },
                {
                  "id": 52,
                  "layout": "inline",
                  "fieldId": "icu_rolling_ftp",
                  "showUnits": true
                },
                {
                  "id": 53,
                  "layout": "inline",
                  "fieldId": "icu_pm_ftp",
                  "showUnits": true
                },
                {
                  "id": 54,
                  "layout": "inline",
                  "fieldId": "icu_w_prime"
                },
                {
                  "id": 55,
                  "layout": "inline",
                  "fieldId": "icu_max_wbal_depletion",
                  "showUnits": true
                }
              ],
              "layout": "table",
              "alignItems": "start",
              "justifyContent": "space-around"
            },
            {
              "id": 9,
              "type": "tree",
              "items": [
                {
                  "id": 57,
                  "layout": "inline",
                  "fieldId": "icu_joules",
                  "showUnits": true
                },
                {
                  "id": 58,
                  "layout": "inline",
                  "fieldId": "icu_joules_above_ftp",
                  "showUnits": true
                },
                {
                  "id": 64,
                  "layout": "inline",
                  "fieldId": "AllWorkFTP",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 59,
                  "layout": "inline",
                  "fieldId": "calories"
                }
              ],
              "layout": "table",
              "alignItems": "start",
              "justifyContent": "space-around"
            }
          ],
          "layout": "row",
          "alignItems": "start",
          "spaceAfter": false,
          "justifyContent": "space-around"
        },
        "height": 200,
        "width_full": true,
        "height_auto": true
      },
      "usage_count": 0,
      "index": 1,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-08T18:56:41.483+00:00",
      "from_athlete": {
        "id": "2049151",
        "name": "David (intervals.icu)",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/37e18c85-cac7-4c45-8dc8-2e716f4b66d2",
        "city": "Cape Town",
        "state": "Western Cape",
        "country": "South Africa",
        "timezone": "Africa/Johannesburg",
        "sex": "M",
        "bio": "Software Engineer and keen cyclist!",
        "website": "https://intervals.icu",
        "email": null
      },
      "from_id": 612004
    },
    {
      "id": 786926,
      "athlete_id": "i115436",
      "type": "ZONES",
      "visibility": "PRIVATE",
      "name": "Time at Altitude",
      "description": "",
      "image": null,
      "content": {
        "code": "TimeatAltitude",
        "icon": "",
        "link": "",
        "color": "#333333",
        "zones": [
          {
            "id": "1",
            "end": 1000.0,
            "name": "bassa quota",
            "color": null,
            "start": null,
            "end_anchor": "",
            "start_anchor": ""
          },
          {
            "id": "2",
            "end": 1300.0,
            "name": "medio - bassa",
            "color": "#17becf",
            "start": 1000.0,
            "end_anchor": "",
            "start_anchor": ""
          },
          {
            "id": "3",
            "end": 1600.0,
            "name": "media",
            "color": "#0e7bf1",
            "start": 1300.0,
            "end_anchor": "",
            "start_anchor": ""
          },
          {
            "id": "4",
            "end": 1900.0,
            "name": "alta quota bassa",
            "color": "#2ca02c",
            "start": 1600.0,
            "end_anchor": "",
            "start_anchor": ""
          },
          {
            "id": "5",
            "end": 2200.0,
            "name": "alta quota",
            "color": "#ffcb0e",
            "start": 1900.0,
            "end_anchor": "",
            "start_anchor": ""
          },
          {
            "id": "6",
            "end": 2500.0,
            "name": "alta quota alta",
            "color": "#ff7f0e",
            "start": 2200.0,
            "end_anchor": "",
            "start_anchor": ""
          },
          {
            "id": "7",
            "end": 2800.0,
            "name": "quota molto alta",
            "color": "#dd0447",
            "start": 2500.0,
            "end_anchor": "",
            "start_anchor": ""
          },
          {
            "id": "8",
            "end": 3100.0,
            "name": "quota estrema",
            "color": "#dd04a7",
            "start": 2800.0,
            "end_anchor": "",
            "start_anchor": ""
          },
          {
            "id": "9",
            "end": null,
            "name": "stratosfera",
            "color": "#333333",
            "start": 3100.0,
            "end_anchor": "",
            "start_anchor": ""
          }
        ],
        "anchor": "none",
        "stream_type": "altitude",
        "name": "Time at Altitude"
      },
      "usage_count": 0,
      "index": 1,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-10-10T18:13:28.428+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 273044,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Load/RPE",
      "description": null,
      "image": null,
      "content": {
        "id": "pjzbpg3g",
        "name": "Load/RPE",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "rgba(255,82,14, 0.4)",
            "text": "Norm Watts",
            "type": "dot",
            "field": "np",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Normalized watts",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(255,82,14)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "Run",
                  "TrailRun",
                  "Swim",
                  "VirtualRide",
                  "VirtualRun"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Norm Watts",
            "markerValue": "top",
            "strokeWidth": 1,
            "i18nTitleKey": "Normalized watts",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "rgba(44,160,44, 0.4)",
            "text": "Moving",
            "type": "dot",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(44,160,44)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "Run",
                  "VirtualRide",
                  "VirtualRun",
                  "TrailRun",
                  "Swim"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "top",
            "strokeWidth": 1,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "rgba(102,51,204,0.3)",
            "text": "Load",
            "type": "bars",
            "field": "fitness_load",
            "scale": "load",
            "stack": "load",
            "title": "Training load",
            "extras": [],
            "filter": "round0",
            "future": true,
            "radius": 3,
            "stroke": "rgb(102,51,204)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "VirtualRun",
                  "Run",
                  "TrailRun",
                  "Swim"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Load",
            "markerValue": "top",
            "strokeWidth": 1,
            "i18nTitleKey": "Training load",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "rgba(102,51,204,0.3)",
            "text": "RPE",
            "type": "line",
            "field": "rpe",
            "gauge": true,
            "scale": "rpe",
            "stack": "",
            "title": "Rate of Perceived Exertion",
            "extras": [],
            "radius": 3,
            "stroke": "#DD04A7FF",
            "filters": [],
            "i18nKey": "RPE",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Rate of Perceived Exertion",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 220,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 2,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-09T09:20:55.661+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 273913,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PUBLIC",
      "name": "HR Enhanced",
      "description": "HR with average and trends for work + PWR10s with W/Kg (custom stream needed)",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/240861e2-a048-4747-b1f6-f43d270afc25",
      "content": {
        "id": null,
        "name": "HR Enhanced",
        "plots": [
          {
            "id": 5,
            "axis": null,
            "text": "HR",
            "color": "#dd0447",
            "extras": [],
            "legend": false,
            "stream": "heartrate",
            "transform": "none",
            "areaOpacity": 0.1,
            "lineOpacity": 1,
            "transformArgs": null
          },
          {
            "id": 7,
            "axis": null,
            "text": "AVG",
            "color": "#FF00FFFF",
            "extras": [],
            "legend": true,
            "stream": "heartrate",
            "transform": "work_interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "strokeWidth": 1.5,
            "transformArgs": null
          },
          {
            "id": 8,
            "axis": null,
            "text": "TREND",
            "color": "#3FF032FF",
            "extras": [],
            "legend": true,
            "stream": "heartrate",
            "transform": "work_interval_linear_trend",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "strokeWidth": 1.75,
            "transformArgs": null
          },
          {
            "id": 9,
            "axis": null,
            "text": "10s Power",
            "color": "#34ACE4FF",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 0.02,
            "lineOpacity": 0.75,
            "transformArgs": {
              "secs": 10
            }
          },
          {
            "id": 11,
            "axis": null,
            "text": "10s W/Kg",
            "color": "#1F77B4",
            "extras": [],
            "legend": true,
            "stream": "WKg",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": {
              "secs": 10
            }
          },
          {
            "id": 12,
            "axis": null,
            "text": "Temp",
            "color": "#c0b570",
            "extras": [],
            "legend": true,
            "stream": "temp",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 20
            }
          },
          {
            "id": 13,
            "axis": null,
            "text": "F Temp",
            "color": "#505050FF",
            "extras": [],
            "legend": true,
            "stream": "weather_temp",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 0.7,
            "transformArgs": null
          },
          {
            "id": 14,
            "axis": null,
            "text": "Feels like",
            "color": "#1F77B4DB",
            "extras": [],
            "legend": true,
            "stream": "feels_like",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 0.7,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 90,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 16,
      "index": 2,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-03T10:49:57.067+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 279116,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "TimeOverUnderPower",
      "description": "This chart presents the total time that you ride under/above a specific power.",
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "400px",
        "script": "{\n    function pad(str, size, car) {\n        while (str.length < size) str = car + str;\n        return str;\n    }\n    \n    function duration_mm_ss(time) {\n        let time_m = Math.floor(time / 60);\n        let time_s = time - time_m * 60;\n        return pad(pad(time_m.toString(), 2, '0'), 3, ' ') + \":\" + pad(time_s.toString(), 2, '0')\n    }\n    \n    function get_pwrZones(power, zones) {\n        for (let i = 0; i < zones.length; i++) {\n            if (power <= zones[i]) return i+1;\n        }\n        return -1;\n    }\n    \n    let activity = icu.activity;    \n    let streams = icu.streams;\n    let pwr = streams.get(\"fixed_watts\").data;\n    let d = streams.get(\"time\").data;\n\n    let pwrMin = 0;\n    let pwrMax = 0;\n    for (let i = 0; i < pwr.length; i++) {\n        if (pwrMax < pwr[i]) {\n            pwrMax = pwr[i];\n        }\n    }\n\n    //  Athlete power zones\n    // export const ZoneColours = [\"#009e80\", \"#009e00\", \"#ffcb0e\", \"#ff7f0e\", \"#dd0447\", \"#6633cc\", \"#504861\" ]\n    // export const ZoneColours4 = [\"#009e00\", \"#ffcb0e\", \"#ff7f0e\", \"#dd0447\" ]\n    // export const ZoneColours3 = [\"#009e00\", \"#ffcb0e\", \"#dd0447\" ]\n\n    // export function toZoneColours(zc) {\n    //    if (zc >= 5) return ZoneColours\n    //    if (zc >= 4) return ZoneColours4\n    //    return ZoneColours3\n    // }\n\n    colors = [\"#009e80\", \"#009e00\", \"#ffcb0e\", \"#ff7f0e\", \"#dd0447\", \"#6633cc\", \"#504861\"]\n    zonesP = []\n    for (let i=0; i < activity.icu_power_zones.length; i++) {\n        zonesP.push(Math.min(pwrMax, Math.floor(activity.icu_ftp * activity.icu_power_zones[i] / 100)));\n    }\n    \n    //  Histogram\n    let totalTime = 0;\n    let watts_histo = [];   \n    for (let i = 0; i <= pwrMax; i++) watts_histo.push(0);\n    for (let i = 0; i < pwr.length; i++) {\n        if (pwr[i] > pwrMin) {\n            watts_histo[pwr[i]] += 1;\n            totalTime += 1;\n        }\n    }\n    \n    //  Accumulation\n    let cumTime = 0;\n    let data_Pwr = [];\n    let data_Time = [];\n    let data_TimeStr = [];\n    let data_Text = [];\n\n    for (let i = pwrMin; i < watts_histo.length; i++) {\n        cumTime += watts_histo[i];\n\n        data_Pwr.push(i);\n        data_Time.push(cumTime);\n        data_TimeStr.push(duration_mm_ss(cumTime));\n        \n        let percentUnder = cumTime / totalTime * 100;      \n        let percentOver = 100 - cumTime / totalTime * 100;\n        \n        let str =   \"<b>(Z\" + get_pwrZones(i, zonesP) + \") \" + i + \" watts</b>\"\n                +   \"<br>\" + duration_mm_ss(cumTime)             + \" Under (\" + percentUnder.toFixed(1) + \" %)\"\n                +   \"<br>\" + duration_mm_ss(totalTime - cumTime) + \" Over  (\" + percentOver.toFixed(1) + \" %)\"\n        ;\n        \n        data_Text.push(str);\n    }\n\n    //  Shapes for power zones\n    shapesP = [{\n        type: 'rect',\n        xref: 'x',\n        yref: 'y',\n        x0: 0,\n        y0: 0,\n        x1: totalTime,\n        y1: zonesP[0],\n        layer: 'below',\n        opacity: 0.2,\n        fillcolor: colors[0],\n        line: {\n            color: 'black',\n            width: 0,\n        dash: 'dot'\n        }\n    }];\n\n    for (let i=0; i < activity.icu_power_zones.length-1; i++) {\n        temp_shape = {\n            type: 'rect',\n            xref: 'x',\n            yref: 'y',\n            x0: 0,\n            y0: zonesP[i]+1,\n            x1: totalTime,\n            y1: zonesP[i+1],\n            layer: 'below',\n            opacity: 0.2,\n            fillcolor: colors[i+1],\n            line: { width: 0 }\n        }\n        shapesP.push(temp_shape)\n    }\n\n    //  Trace\n    trace1 = {\n        x: data_Time,\n        y: data_Pwr,\n        text: data_Text,\n        type: 'scatter',\n        yaxis: 'y',\n        xaxis: 'x',\n        name: 'Time under/over power',\n        mode: 'lines',\n        hoverinfo: 'text',\n        line: { color: 'black' }\n    };\n\n    var data = [trace1];\n\n    //  Layout    \n    layout = {\n        title: {\n            text: \"Time under/over power\",\n            font: { color: '#999999' },\n        },\n        xaxis: {\n            side: 'bottom',\n            range: [0, cumTime],\n            showline: true, zeroline: true,\n            autotick: false, tick0: 0, dtick: cumTime/10,\n            showspikes: true, spikemode: 'across', spikesnap: \"cursor+data\", spikedash: 'solid', spikethickness: 1, spikecolor:  '#999999',\n            color: '#999999',\n        },\n        yaxis: {\n            side: 'left',            \n            range: [pwrMin, pwrMax+1],\n            showline: true, zeroline: true,\n            autotick: false, tick0: 0, dtick: 50,\n            showspikes: true, spikemode: 'across', spikesnap: \"cursor+data\", spikedash: 'solid', spikethickness: 1, spikecolor:  '#999999',\n            title: { text: 'Power', },\n            color: '#999999',\n        },\n        margin: { l: 45, r: 20, t: 30, b: 20 },\n        hovermode: 'x unified',\n        spikedistance: -1,\n        shapes: shapesP,\n        showlegend: false,\n        legend: {\"orientation\": \"h\"}\n    }\n\n    chart = { data, layout };\n}",
        "name": "TimeOverUnderPower"
      },
      "usage_count": 0,
      "index": 2,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-17T16:12:56.791+00:00",
      "from_athlete": {
        "id": "5776122",
        "name": "Hugo Joudrier",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/30aa47a5-889c-4c6e-8e71-a3054aa6dd74",
        "city": "Chambry",
        "state": "Rhne-Alpes",
        "country": "France",
        "timezone": "Europe/Paris",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 136893
    },
    {
      "id": 365399,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HISTOGRAM",
      "visibility": "FOLLOWERS",
      "name": "Heartrate 2s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Heartrate 2s",
        "plots": [
          {
            "id": 1,
            "max": null,
            "min": null,
            "text": "HR 2s",
            "type": "bars",
            "color": "#DD0447FF",
            "scale": "watts",
            "extras": [],
            "legend": false,
            "stream": "raw_heartrate",
            "transform": "moving_avg",
            "bucketSize": 5,
            "areaOpacity": 0.7,
            "lineOpacity": 0.7,
            "trimPercent": 1,
            "transformArgs": {
              "secs": 2
            },
            "hideLastBucket": false,
            "hideFirstBucket": false
          }
        ],
        "width": 540,
        "height": 320
      },
      "usage_count": 1,
      "index": 2,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:15:13.281+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396058,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "AeT HR",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "AeTHR",
        "icon": "mdi-heart",
        "link": null,
        "type": "numeric",
        "color": "#FF0101",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "(secret sauce)",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "pace_units": null,
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "AeT HR"
      },
      "usage_count": 40,
      "index": 2,
      "hide_script": true,
      "hidden_by_id": "10385309",
      "updated": "2024-08-11T10:26:43.927+00:00",
      "from_athlete": {
        "id": "10385309",
        "name": "Luisma Gallego",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c7e97937-d358-425a-8acc-2c726c4b5cff",
        "city": "Cubelles",
        "state": "Barcelona",
        "country": "Spain",
        "timezone": "Europe/Madrid",
        "sex": "M",
        "bio": "Physiology Technician\n\nPersonal Trainer EREPS accreditation number 107429\n\nInstructor at Sportcoach.es\n\nPublications: https://dialnet.unirioja.es/servlet/articulo?codigo=8443236\n\nParticipant in several podcasts about training and cycling\n\nwww.controlmetrics.es\n",
        "website": "https://www.controlmetrics.es",
        "email": null
      },
      "from_id": 390992
    },
    {
      "id": 402902,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HEATMAP",
      "visibility": "FOLLOWERS",
      "name": "Power / HR 3s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Power / HR 3s",
        "plots": [
          {
            "id": "x",
            "max": null,
            "min": null,
            "axis": null,
            "text": "Power",
            "color": "#6633cc",
            "legend": false,
            "stream": "watts",
            "transform": "moving_avg",
            "bucketSize": 5,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 3
            },
            "hideLastBucket": false,
            "hideFirstBucket": true
          },
          {
            "id": "y",
            "max": null,
            "min": null,
            "text": "HR",
            "color": "#dd0447",
            "legend": false,
            "stream": "raw_heartrate",
            "transform": "moving_avg",
            "bucketSize": 2,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 3
            },
            "hideLastBucket": false,
            "hideFirstBucket": true
          }
        ],
        "steps": null,
        "width": 510,
        "height": 320,
        "opacity": null,
        "colorScale": "interpolateWarm",
        "contourPlot": false,
        "trimPercent": null
      },
      "usage_count": 1,
      "index": 2,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:15:08.587+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 429596,
      "athlete_id": "i115436",
      "type": "ACTIVITY_STREAM",
      "visibility": "PUBLIC",
      "name": "W/Kg",
      "description": "thanks pepe for the script",
      "image": null,
      "content": {
        "pos": true,
        "code": "WKg",
        "link": null,
        "name": "W/Kg",
        "type": "numeric",
        "color": "#1F77B4",
        "units": "W/Kg",
        "legend": "W/Kg",
        "script": "{let weight = activity.icu_weight\nlet watts = icu.streams.fixed_watts\nfor (let i = 0; i < data.length; i++) data[i] = watts[i] / weight}",
        "convert": "",
        "no_nulls": false,
        "legend_pos": "topLeft",
        "domain_zero": true,
        "area_opacity": "0.15",
        "line_opacity": "1",
        "number_format": ".1f",
        "fit_record_field": null,
        "short_description": "W/Kg",
        "processes_fit_messages": false
      },
      "usage_count": 75,
      "index": 2,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-17T15:17:50.834+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 616901,
      "athlete_id": "i115436",
      "type": "ACTIVITY_PANEL",
      "visibility": "FOLLOWERS",
      "name": "Bfactor 0.8",
      "description": "my panel with my customs",
      "image": null,
      "content": {
        "id": null,
        "name": "Bfactor 0.8",
        "width": 330,
        "config": {
          "id": 1,
          "type": "tree",
          "items": [
            {
              "id": 62,
              "type": "tree",
              "items": [
                {
                  "id": 63,
                  "layout": "normal",
                  "fieldId": "start_date_local",
                  "noLabel": true,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 65,
                  "layout": "normal",
                  "fieldId": "start_time",
                  "noLabel": true,
                  "showUnits": false,
                  "dataAsLabel": true,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 125,
                  "type": "tree",
                  "items": [
                    {
                      "id": 126,
                      "type": "tree",
                      "items": [
                        {
                          "id": 127,
                          "layout": "normal",
                          "fieldId": "distance",
                          "noLabel": true,
                          "showUnits": false,
                          "dataAsLabel": false,
                          "spaceBefore": false,
                          "hideRelatedField": false
                        },
                        {
                          "id": 128,
                          "layout": "normal",
                          "fieldId": "moving_time",
                          "noLabel": true,
                          "showUnits": false,
                          "dataAsLabel": false,
                          "spaceBefore": false,
                          "hideRelatedField": false
                        }
                      ],
                      "layout": "row",
                      "alignItems": "center",
                      "spaceAfter": false,
                      "justifyContent": "space-around"
                    }
                  ],
                  "layout": "row",
                  "alignItems": "start",
                  "spaceAfter": false,
                  "justifyContent": "space-around"
                },
                {
                  "id": 117,
                  "layout": "inline",
                  "fieldId": "elapsed_time",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 118,
                  "layout": "inline",
                  "fieldId": "coasting_time",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 189,
                  "type": "tree",
                  "items": [
                    {
                      "id": 190,
                      "layout": "inline",
                      "fieldId": "CoastDIFF",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 191,
                      "layout": "inline",
                      "fieldId": "DIFFCOAST",
                      "noLabel": true,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": false,
                  "justifyContent": "space-around"
                },
                {
                  "id": 192,
                  "type": "tree",
                  "items": [
                    {
                      "id": 193,
                      "layout": "inline",
                      "fieldId": "TOverCOAST",
                      "noLabel": true,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 194,
                      "layout": "inline",
                      "fieldId": "OverCOAST",
                      "noLabel": true,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": false,
                  "justifyContent": "space-around"
                },
                {
                  "id": 67,
                  "layout": "inline",
                  "fieldId": "total_elevation_gain",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 150,
                  "layout": "inline",
                  "fieldId": "gear_name",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 148,
                  "layout": "normal",
                  "fieldId": "trainer",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": true,
                  "hideRelatedField": false
                }
              ],
              "layout": "column",
              "alignItems": "end",
              "spaceAfter": true,
              "justifyContent": "end"
            },
            {
              "id": 4,
              "type": "tree",
              "items": [
                {
                  "id": 75,
                  "type": "tree",
                  "items": [
                    {
                      "id": 76,
                      "layout": "normal",
                      "fieldId": "icu_rpe",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 77,
                      "layout": "normal",
                      "fieldId": "feel",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 129,
                      "layout": "normal",
                      "fieldId": "coach_tick",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": true,
                  "justifyContent": "space-around"
                },
                {
                  "id": 130,
                  "type": "tree",
                  "items": [
                    {
                      "id": 131,
                      "layout": "normal",
                      "fieldId": "icu_training_load",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 132,
                      "layout": "normal",
                      "fieldId": "hr_load",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "start",
                  "spaceAfter": false,
                  "justifyContent": "space-around"
                },
                {
                  "id": 133,
                  "layout": "inline",
                  "fieldId": "hr_load_error",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 120,
                  "layout": "inline",
                  "fieldId": "decoupling",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 151,
                  "layout": "inline",
                  "fieldId": "tiz_class",
                  "noLabel": true,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "column",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "center"
            },
            {
              "id": 79,
              "type": "tree",
              "items": [
                {
                  "id": 187,
                  "layout": "inline",
                  "fieldId": "average_speed",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 188,
                  "layout": "inline",
                  "fieldId": "max_speed",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 82,
                  "layout": "inline",
                  "fieldId": "average_cadence",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 86,
                  "layout": "inline",
                  "fieldId": "average_heartrate",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": false,
                  "dataAsLabel": false,
                  "spaceBefore": true,
                  "hideRelatedField": false
                },
                {
                  "id": 87,
                  "layout": "inline",
                  "fieldId": "max_heartrate",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 149,
                  "layout": "inline",
                  "fieldId": "hrrc",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 119,
                  "layout": "inline",
                  "fieldId": "trimp",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "column",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "space-around"
            },
            {
              "id": 6,
              "type": "tree",
              "items": [
                {
                  "id": 145,
                  "type": "tree",
                  "items": [
                    {
                      "id": 146,
                      "layout": "normal",
                      "fieldId": "icu_weighted_avg_watts",
                      "showUnits": true,
                      "useColors": false
                    },
                    {
                      "id": 147,
                      "layout": "normal",
                      "fieldId": "icu_average_watts",
                      "showUnits": true,
                      "useColors": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": false,
                  "justifyContent": "space-around"
                },
                {
                  "id": 153,
                  "layout": "inline",
                  "fieldId": "Avgnocoasting",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 123,
                  "layout": "inline",
                  "fieldId": "icu_intensity",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 41,
                  "layout": "inline",
                  "fieldId": "icu_variability_index",
                  "spaceBefore": false
                },
                {
                  "id": 90,
                  "layout": "inline",
                  "fieldId": "icu_pm_p_max",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 43,
                  "layout": "inline",
                  "fieldId": "icu_efficiency_factor"
                },
                {
                  "id": 44,
                  "layout": "inline",
                  "fieldId": "avg_lr_balance"
                }
              ],
              "layout": "column",
              "alignItems": "center",
              "justifyContent": "space-around"
            },
            {
              "id": 8,
              "type": "tree",
              "items": [
                {
                  "id": 142,
                  "type": "tree",
                  "items": [
                    {
                      "id": 144,
                      "layout": "normal",
                      "fieldId": "icu_weight",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 143,
                      "layout": "normal",
                      "fieldId": "icu_ftp",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": false,
                  "justifyContent": "space-around"
                },
                {
                  "id": 52,
                  "layout": "inline",
                  "fieldId": "icu_rolling_ftp",
                  "showUnits": true,
                  "spaceBefore": true
                },
                {
                  "id": 53,
                  "layout": "inline",
                  "fieldId": "icu_pm_ftp",
                  "showUnits": true,
                  "spaceBefore": false
                },
                {
                  "id": 54,
                  "layout": "inline",
                  "fieldId": "icu_w_prime",
                  "spaceBefore": true
                },
                {
                  "id": 55,
                  "layout": "inline",
                  "fieldId": "icu_max_wbal_depletion",
                  "showUnits": true
                },
                {
                  "id": 154,
                  "layout": "inline",
                  "fieldId": "p_max",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 99,
                  "layout": "inline",
                  "fieldId": "pace",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 100,
                  "layout": "inline",
                  "fieldId": "pace_load",
                  "noLabel": false,
                  "showUnits": false,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "column",
              "alignItems": "end",
              "spaceAfter": false,
              "justifyContent": "space-around"
            },
            {
              "id": 9,
              "type": "tree",
              "items": [
                {
                  "id": 176,
                  "type": "tree",
                  "items": [
                    {
                      "id": 177,
                      "layout": "inline",
                      "fieldId": "calories",
                      "noLabel": false,
                      "showUnits": true,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 178,
                      "layout": "inline",
                      "fieldId": "icu_joules",
                      "noLabel": false,
                      "showUnits": true,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": false,
                  "justifyContent": "space-around"
                },
                {
                  "id": 166,
                  "type": "tree",
                  "items": [
                    {
                      "id": 175,
                      "layout": "normal",
                      "fieldId": "icu_joules_above_ftp",
                      "noLabel": false,
                      "showUnits": true,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 167,
                      "layout": "normal",
                      "fieldId": "AllWorkFTP",
                      "noLabel": false,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 168,
                      "layout": "normal",
                      "fieldId": "AllworkCPPercentage",
                      "noLabel": false,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": false,
                  "justifyContent": "center"
                },
                {
                  "id": 169,
                  "type": "tree",
                  "items": [
                    {
                      "id": 170,
                      "layout": "normal",
                      "fieldId": "WorkHour",
                      "noLabel": true,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 171,
                      "layout": "normal",
                      "fieldId": "WorkHourOverCP",
                      "noLabel": true,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": false,
                  "justifyContent": "center"
                },
                {
                  "id": 172,
                  "type": "tree",
                  "items": [
                    {
                      "id": 173,
                      "layout": "normal",
                      "fieldId": "WorkHourKg",
                      "noLabel": true,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 174,
                      "layout": "normal",
                      "fieldId": "WorkHourKgoverCP",
                      "noLabel": true,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": false,
                  "justifyContent": "center"
                },
                {
                  "id": 195,
                  "type": "tree",
                  "items": [
                    {
                      "id": 196,
                      "layout": "normal",
                      "fieldId": "KJkg",
                      "noLabel": true,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 197,
                      "layout": "normal",
                      "fieldId": "KJkgCP",
                      "noLabel": true,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": true,
                  "justifyContent": "space-around"
                },
                {
                  "id": 199,
                  "type": "tree",
                  "items": [
                    {
                      "id": 201,
                      "layout": "inline",
                      "fieldId": "carbs_used",
                      "noLabel": false,
                      "showUnits": true,
                      "useColors": false,
                      "dataAsLabel": true,
                      "hideRelatedField": true
                    },
                    {
                      "id": 200,
                      "layout": "inline",
                      "fieldId": "carbs_ingested",
                      "noLabel": false,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": true,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 202,
                      "layout": "inline",
                      "fieldId": "CHOh",
                      "noLabel": false,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": true,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "row",
                  "alignItems": "center",
                  "spaceAfter": false,
                  "justifyContent": "space-around"
                }
              ],
              "layout": "column",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "space-between"
            },
            {
              "id": 91,
              "type": "tree",
              "items": [
                {
                  "id": 182,
                  "type": "tree",
                  "items": [
                    {
                      "id": 183,
                      "layout": "normal",
                      "fieldId": "strain_score_parts",
                      "noLabel": true,
                      "showUnits": false,
                      "useColors": true,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "table",
                  "alignItems": "center",
                  "spaceAfter": true,
                  "justifyContent": "space-around"
                },
                {
                  "id": 93,
                  "type": "tree",
                  "items": [
                    {
                      "id": 138,
                      "type": "tree",
                      "items": [
                        {
                          "id": 139,
                          "layout": "normal",
                          "fieldId": "average_temp",
                          "noLabel": false,
                          "showUnits": false,
                          "dataAsLabel": false,
                          "spaceBefore": false,
                          "hideRelatedField": false
                        },
                        {
                          "id": 140,
                          "layout": "normal",
                          "fieldId": "max_temp",
                          "noLabel": false,
                          "showUnits": false,
                          "dataAsLabel": false,
                          "spaceBefore": false,
                          "hideRelatedField": false
                        },
                        {
                          "id": 141,
                          "layout": "normal",
                          "fieldId": "min_temp",
                          "noLabel": false,
                          "showUnits": false,
                          "dataAsLabel": false,
                          "spaceBefore": false,
                          "hideRelatedField": false
                        }
                      ],
                      "layout": "row",
                      "alignItems": "end",
                      "spaceAfter": false,
                      "justifyContent": "end"
                    },
                    {
                      "id": 136,
                      "layout": "inline",
                      "fieldId": "average_weather_temp",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 137,
                      "layout": "inline",
                      "fieldId": "average_feels_like",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    },
                    {
                      "id": 98,
                      "layout": "normal",
                      "fieldId": "wind_summary",
                      "noLabel": false,
                      "showUnits": false,
                      "dataAsLabel": false,
                      "spaceBefore": false,
                      "hideRelatedField": false
                    }
                  ],
                  "layout": "column",
                  "alignItems": "center",
                  "spaceAfter": true,
                  "justifyContent": "space-around"
                }
              ],
              "layout": "column",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "center"
            }
          ],
          "layout": "row",
          "alignItems": "end",
          "spaceAfter": false,
          "justifyContent": "space-around"
        },
        "height": 200,
        "width_full": true,
        "height_auto": true
      },
      "usage_count": 14,
      "index": 2,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-26T23:42:57.188+00:00",
      "from_athlete": {
        "id": "i27197",
        "name": "Gabriel Vargas",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/2a88c66d-02ad-4877-989c-10f461e3e5a6",
        "city": "Campinas",
        "state": "SP",
        "country": "Brazil",
        "timezone": "America/Sao_Paulo",
        "sex": "M",
        "bio": null,
        "website": "https://www.gabrielvargas.com.br/",
        "email": null
      },
      "from_id": 615116
    },
    {
      "id": 273999,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PUBLIC",
      "name": "VAM - Gradient",
      "description": "VAM (visualized only positive) + Gradient + W/Kg (5s and interval avg, w/kg custom stream script needed for this)",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/bfc0260b-84fb-4006-baab-777226e83169",
      "content": {
        "id": null,
        "name": "VAM - Gradient",
        "plots": [
          {
            "id": 6,
            "axis": null,
            "text": "VAM",
            "color": "#1F77B4",
            "extras": [],
            "legend": true,
            "stream": "vam",
            "transform": "none",
            "areaOpacity": 1,
            "lineOpacity": 1,
            "strokeWidth": 1.5,
            "transformArgs": null
          },
          {
            "id": 7,
            "axis": null,
            "text": "Gradient",
            "color": "#DD0447FF",
            "extras": [],
            "legend": true,
            "stream": "grade_smooth",
            "transform": "none",
            "areaOpacity": 1,
            "lineOpacity": 1,
            "transformArgs": null
          },
          {
            "id": 11,
            "axis": null,
            "text": "W/Kg",
            "color": "#FF7F0EFF",
            "extras": [],
            "legend": true,
            "stream": "WKg",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 0.5,
            "transformArgs": {
              "secs": 5
            }
          },
          {
            "id": 12,
            "axis": null,
            "text": "AVG VAM",
            "color": "#1F77B4",
            "extras": [],
            "legend": true,
            "stream": "vam",
            "transform": "interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": null
          },
          {
            "id": 13,
            "axis": null,
            "text": "AVG Gradient",
            "color": "#DD0447FF",
            "extras": [],
            "legend": true,
            "stream": "grade_smooth",
            "transform": "interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": null
          },
          {
            "id": 14,
            "axis": null,
            "text": "AVG W/Kg",
            "color": "#FF7F0EFF",
            "extras": [],
            "legend": true,
            "stream": "WKg",
            "transform": "interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 90,
        "yAxisMax": null,
        "yAxisMin": 0.0,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 102,
      "index": 3,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-09-24T09:08:45.694+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396059,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "AeT w/kg",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "AeTwkg",
        "icon": "balance",
        "link": null,
        "type": "numeric",
        "color": "#0013FF",
        "gauge": true,
        "total": null,
        "units": " w/kg",
        "inline": false,
        "prefix": null,
        "script": "(secret sauce)",
        "suffix": " w/kg",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "pace_units": null,
        "number_format": ".2f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "AeT w/kg"
      },
      "usage_count": 40,
      "index": 3,
      "hide_script": true,
      "hidden_by_id": "10385309",
      "updated": "2024-08-11T10:26:47.537+00:00",
      "from_athlete": {
        "id": "10385309",
        "name": "Luisma Gallego",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c7e97937-d358-425a-8acc-2c726c4b5cff",
        "city": "Cubelles",
        "state": "Barcelona",
        "country": "Spain",
        "timezone": "Europe/Madrid",
        "sex": "M",
        "bio": "Physiology Technician\n\nPersonal Trainer EREPS accreditation number 107429\n\nInstructor at Sportcoach.es\n\nPublications: https://dialnet.unirioja.es/servlet/articulo?codigo=8443236\n\nParticipant in several podcasts about training and cycling\n\nwww.controlmetrics.es\n",
        "website": "https://www.controlmetrics.es",
        "email": null
      },
      "from_id": 390283
    },
    {
      "id": 735041,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "HRV",
      "description": "Heart rate variability with trend",
      "image": null,
      "content": {
        "id": "ld4tq5vx",
        "name": "HRV",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "band": 0.75,
            "fill": "#2CA02C66",
            "text": "HRV",
            "type": "bars",
            "field": "hrv",
            "gauge": true,
            "scale": "ms",
            "stack": "",
            "title": "Heartrate variability",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009E00FF",
            "filters": [],
            "i18nKey": "HRV rMSSD",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Heartrate variability",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": null,
            "band": 0,
            "fill": "#1F77B44D",
            "text": "Base",
            "type": "line",
            "field": "hrv",
            "gauge": true,
            "scale": "ms",
            "stack": "",
            "title": "Heartrate variability",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#1F77B4FF",
            "aggArgs": {
              "days": 7
            },
            "filters": [],
            "i18nKey": "HRV rMSSD",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Heartrate variability",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": null,
            "band": 0.75,
            "fill": "#1F77B429",
            "text": "Norm",
            "type": "line",
            "field": "hrv",
            "gauge": true,
            "scale": "ms",
            "stack": "",
            "title": "Heartrate variability",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#1F77B43B",
            "aggArgs": {
              "days": 60
            },
            "filters": [],
            "i18nKey": "HRV rMSSD",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Heartrate variability",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "cv",
            "min": null,
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "CV%",
            "type": "line",
            "field": "hrv",
            "gauge": true,
            "scale": "ms",
            "stack": "",
            "title": "Heartrate variability",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(214,39,40)",
            "aggArgs": {
              "days": 7
            },
            "filters": [],
            "i18nKey": "HRV rMSSD",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Heartrate variability",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "month_avg",
            "min": null,
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "Monthly",
            "type": "line",
            "field": "hrv",
            "gauge": true,
            "scale": "ms",
            "stack": "",
            "title": "Heartrate variability",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000AD",
            "filters": [],
            "i18nKey": "HRV rMSSD",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Heartrate variability",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#000000ff",
            "text": "Fasi ciclo",
            "type": "dot",
            "field": "Ciclo",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "Ciclo",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [],
            "tickFormat": "customInput",
            "customInput": {
              "id": 660148,
              "name": "Fasi ciclo",
              "type": "INPUT_FIELD",
              "image": null,
              "index": 1,
              "content": {
                "max": null,
                "min": null,
                "code": "Ciclo",
                "icon": "",
                "link": null,
                "name": "Fasi ciclo",
                "type": "select",
                "color": "#009E00",
                "gauge": true,
                "total": null,
                "units": null,
                "prefix": null,
                "script": null,
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 3,
                "options": [
                  {
                    "icon": null,
                    "text": " Mestruale",
                    "color": "#D62728",
                    "value": 1
                  },
                  {
                    "icon": null,
                    "text": "Follicolare",
                    "color": "#334CCC",
                    "value": 2
                  },
                  {
                    "icon": null,
                    "text": "Luteale",
                    "color": "#FFCB0E",
                    "value": 3
                  },
                  {
                    "icon": null,
                    "text": "Ovulatorio",
                    "color": "#009E00",
                    "value": 4
                  }
                ],
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-05-23T16:39:47.636+00:00",
              "athlete_id": "i180702",
              "visibility": "PUBLIC",
              "description": "fase mestruale",
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 7,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "rgba(221,4,71,0.5)",
            "text": "Period",
            "type": "dot",
            "field": "period",
            "scale": "period",
            "stack": "",
            "title": "Period days",
            "extras": [],
            "filter": "period",
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "filters": [],
            "i18nKey": "Period",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Period days",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "HRV",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": 0.0,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "ms",
        "y2AxisLabel": " ",
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 3,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-20T09:35:56.388+00:00",
      "from_athlete": {
        "id": "i180702",
        "name": "campanella",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/f458629b-7f60-4554-bf9f-c5e5b88bc1a3",
        "city": "Trento",
        "state": "Trentino",
        "country": "Italy",
        "timezone": "Europe/Rome",
        "sex": "F",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 400900
    },
    {
      "id": 738097,
      "athlete_id": "i115436",
      "type": "ACTIVITY_PANEL",
      "visibility": "PRIVATE",
      "name": "Panel 61",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Panel 61",
        "width": 1590,
        "config": {
          "id": 1,
          "type": "tree",
          "items": [
            {
              "id": 23,
              "type": "tree",
              "items": [
                {
                  "id": 28,
                  "layout": "normal",
                  "fieldId": "Sover600",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 29,
                  "layout": "normal",
                  "fieldId": "S5over600",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "table",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "space-around"
            },
            {
              "id": 24,
              "type": "tree",
              "items": [
                {
                  "id": 32,
                  "layout": "normal",
                  "fieldId": "Sover650",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 33,
                  "layout": "normal",
                  "fieldId": "S5over650",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "table",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "space-around"
            },
            {
              "id": 25,
              "type": "tree",
              "items": [
                {
                  "id": 34,
                  "layout": "normal",
                  "fieldId": "Sover700",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 35,
                  "layout": "normal",
                  "fieldId": "S5over700",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "table",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "space-around"
            },
            {
              "id": 26,
              "type": "tree",
              "items": [
                {
                  "id": 36,
                  "layout": "normal",
                  "fieldId": "Sover750",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 37,
                  "layout": "normal",
                  "fieldId": "S5over750",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "table",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "space-around"
            },
            {
              "id": 27,
              "type": "tree",
              "items": [
                {
                  "id": 38,
                  "layout": "normal",
                  "fieldId": "Sover800",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 39,
                  "layout": "normal",
                  "fieldId": "S5over800",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "table",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "space-around"
            },
            {
              "id": 13,
              "type": "tree",
              "items": [
                {
                  "id": 14,
                  "layout": "normal",
                  "fieldId": "Wkg5",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 15,
                  "layout": "normal",
                  "fieldId": "Wkg",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 16,
                  "layout": "normal",
                  "fieldId": "Wkg7",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 17,
                  "layout": "normal",
                  "fieldId": "Wkg8",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "table",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "space-around"
            },
            {
              "id": 18,
              "type": "tree",
              "items": [
                {
                  "id": 19,
                  "layout": "normal",
                  "fieldId": "Sover5Wkg",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 20,
                  "layout": "normal",
                  "fieldId": "Sover6Wkg",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 21,
                  "layout": "normal",
                  "fieldId": "Sover7Wkg",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                },
                {
                  "id": 22,
                  "layout": "normal",
                  "fieldId": "Sover8Wkg",
                  "noLabel": false,
                  "showUnits": false,
                  "useColors": true,
                  "dataAsLabel": false,
                  "spaceBefore": false,
                  "hideRelatedField": false
                }
              ],
              "layout": "table",
              "alignItems": "center",
              "spaceAfter": false,
              "justifyContent": "end"
            }
          ],
          "layout": "row",
          "spaceAfter": false
        },
        "height": 200,
        "width_full": true,
        "height_auto": true
      },
      "usage_count": 0,
      "index": 3,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-23T11:56:35.430+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 274069,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PUBLIC",
      "name": "Cadence + Torque",
      "description": "Cadence with work trend + Torque",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/a3923b02-a520-4b0e-a881-25777e05828e",
      "content": {
        "id": null,
        "name": "Cadence + Torque",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "Cadence",
            "color": "#1B00FFFF",
            "extras": [],
            "legend": true,
            "stream": "cadence",
            "transform": "moving_avg",
            "areaOpacity": 0.75,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 5
            }
          },
          {
            "id": 2,
            "axis": null,
            "text": "Torque",
            "color": "#62E62DFF",
            "extras": [],
            "legend": true,
            "stream": "torque",
            "transform": "moving_avg",
            "areaOpacity": 0.8,
            "lineOpacity": 5,
            "transformArgs": {
              "secs": 5
            }
          },
          {
            "id": 3,
            "axis": null,
            "text": "TrendRPM",
            "color": "#ff00ff",
            "extras": [],
            "legend": true,
            "stream": "cadence",
            "transform": "work_interval_linear_trend",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "strokeWidth": 2,
            "transformArgs": null
          },
          {
            "id": 5,
            "axis": null,
            "text": "AVG RPM",
            "color": "#000000FF",
            "extras": [],
            "legend": true,
            "stream": "cadence",
            "transform": "interval_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "strokeWidth": 1.5,
            "transformArgs": null
          },
          {
            "id": 6,
            "axis": null,
            "text": "AVG Torque",
            "color": "#000000FF",
            "extras": [],
            "legend": true,
            "stream": "torque",
            "transform": "interval_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "strokeWidth": 1.5,
            "transformArgs": null
          },
          {
            "id": 8,
            "axis": null,
            "text": "TrendRPMZOOM",
            "color": "#DD0447FF",
            "extras": [],
            "legend": true,
            "stream": "cadence",
            "transform": "zoom_trend",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 90,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 126,
      "index": 4,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-14T10:15:13.087+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 276705,
      "athlete_id": "i115436",
      "type": "INTERVAL_FIELD",
      "visibility": "PRIVATE",
      "name": "RPE",
      "description": "Intensity/difficulty rating out of 10.",
      "image": null,
      "content": {
        "max": 10.0,
        "min": 1.0,
        "code": "RPE",
        "icon": null,
        "link": "https://www.mountainpeakfitness.com/blog/power-heart-rate-zones-for-the-endurance-athlete",
        "type": "numeric",
        "color": "#333333",
        "gauge": null,
        "total": null,
        "units": null,
        "prefix": "RPE",
        "script": null,
        "suffix": null,
        "average": null,
        "convert": null,
        "example": 1.3,
        "options": null,
        "pace_units": null,
        "number_format": ".0f",
        "processes_fit_messages": false,
        "name": "RPE"
      },
      "usage_count": 5,
      "index": 4,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-13T19:00:40.911+00:00",
      "from_athlete": {
        "id": "i77672",
        "name": "Daniel Harris",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c19033cb-1529-423c-8649-f008310bf7aa",
        "city": "Criftins",
        "state": "England",
        "country": "United Kingdom",
        "timezone": "Europe/London",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 93913
    },
    {
      "id": 279119,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "W' Plot (Veloclinic Plot)",
      "description": "The W' plot from Veloclinic shows the maximal amount of work that can be done for any given power minus the work done by CP.",
      "image": null,
      "content": {
        "link": "http://veloclinic.com/veloclinic-plot-w-cp-subtraction-plot/",
        "width": "100%",
        "height": "400px",
        "script": "{  \n    function duration_mm_ss(time) {\n        let time_m = Math.floor(time / 60);\n        let time_s = time - time_m * 60;\n        if (time_m > 0) {\n            if (time_s > 0) return time_m.toString() + \"m\" + time_s.toFixed(0).toString() + \"s\";\n            return time_m.toString() + \"m\";\n        }\n        if (time_s > 0) return time_s.toFixed(0).toString() + \"s\"\n        return \"null time\"\n    }\n\n    let activity = icu.activity; \n    let ftp = activity.icu_ftp;\n    let hie = activity.icu_w_prime;\n    let hie_max = hie, pwr_max = 0;\n\n    let textO_HIE = \"<b>W\\': \" + hie + \" Joules</b>\"\n    let textO_FTP = \"<b>FTP: \" + ftp + \" Watts</b>\"\n   \n    let pcActivity = icu.powerCurve, w_primeActivity = [], pwrActivity = [], Activity_text = [];\n    for (t = 0; t < pcActivity.secs.length; t++) {\n        if (pcActivity.watts[t] > ftp) {\n            pwrActivity.push(pcActivity.watts[t]);\n            w_primeActivity.push((pcActivity.watts[t] - ftp) * pcActivity.secs[t]);\n            \n            let str =   \"<b>\" + duration_mm_ss(pcActivity.secs[t]) + \" @\" + pcActivity.watts[t] + \"watts</b> (FTP+\" + (pcActivity.watts[t] - ftp) + \"w)\"  \n                    +   \"<br>\" + w_primeActivity[w_primeActivity.length-1] + \" Joules (\" + (w_primeActivity[w_primeActivity.length-1]/hie*100).toFixed(2) + \"%)\"\n            ;\n            Activity_text.push(str);\n        }\n    };\n\n    let HIE_w_prime = [] ,HIE_text = [];\n    let pcPeriod = icu.bestPower['84d'], w_primePeriod = [], pwrPeriod = [], textPeriod = [];\n    for (t = 0; t < pcPeriod.secs.length; t++) {\n        if (pcPeriod.watts[t] > ftp) {\n            pwrPeriod.push(pcPeriod.watts[t]);\n            w_primePeriod.push((pcPeriod.watts[t] - ftp) * pcPeriod.secs[t]);\n\n            let str =   \"<b>\" + duration_mm_ss(pcPeriod.secs[t]) + \" @\" + pcPeriod.watts[t] + \"watts</b> (FTP+\" + (pcPeriod.watts[t] - ftp) + \"w)\"  \n                    +   \"<br>\" + w_primePeriod[w_primePeriod.length-1] + \" Joules (\" + (w_primePeriod[w_primePeriod.length-1]/hie*100).toFixed(2) + \"%)\"\n            ;\n            textPeriod.push(str);\n            \n            HIE_w_prime.push(hie);\n            HIE_text.push(\n                    \"<b>TTE@\" + pcPeriod.watts[t] + \"watts=\" + duration_mm_ss(hie/(pcPeriod.watts[t] - ftp))\n            );\n        }\n        if (hie_max < w_primePeriod[w_primePeriod.length-1]) hie_max = w_primePeriod[w_primePeriod.length-1];\n        if (pwr_max < pcPeriod.watts[t]) pwr_max = pcPeriod.watts[t];\n    };\n    pwrPeriod.push(ftp);\n    w_primePeriod.push(0);\n    HIE_w_prime.push(hie);\n    HIE_text.push(textO_HIE);\n      \n    traceFTP = {\n        x: [ftp , ftp],\n        y: [0    , hie_max],\n        text: [\"\", textO_FTP],\n        type: 'scatter',\n        mode: 'lines',\n        line: { width: 3, color: 'green' },\n        hoverinfo: 'text',\n        xaxis: 'x',\n        yaxis: 'y',\n    };\n      \n    traceHIE = {\n        x: [0 , pwr_max],\n        y: [hie , hie],\n        text: [textO_HIE, \"\"],\n        type: 'scatter',\n        mode: 'lines',\n        line: { width: 3, dash: 'dash', color: 'red' },\n        hoverinfo: 'text',\n        xaxis: 'x',\n        yaxis: 'y',\n    };\n    \n    traceHIELabel = {\n        x: pwrPeriod,\n        y: HIE_w_prime,\n        text: HIE_text,\n        type: 'scatter',\n        mode: 'lines',\n        line: { width: 0, dash: 'dash', color: 'red' },\n        hoverinfo: 'text',\n        xaxis: 'x',\n        yaxis: 'y',\n    };\n\n    let traceActivity = {\n        x: pwrActivity,\n        y: w_primeActivity,\n        text: Activity_text,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: 'black' },\n        hoverinfo: 'text',\n        xaxis: 'x',\n        yaxis: 'y',\n    };\n\n    let tracePeriod = {\n        name: 'W_prime period 84d',\n        x: pwrPeriod,\n        y: w_primePeriod,\n        text: textPeriod,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: 'blue' },\n        hoverinfo: 'text',\n        xaxis: 'x',\n        yaxis: 'y',\n    };\n\n    let data = [tracePeriod, traceActivity, traceHIE, traceHIELabel, traceFTP]\n\n    let layout = {\n        title: {\n            text: \"Critical Power Subtraction plot\"\n        },\n        xaxis: {\n            side: 'bottom',\n            range: [0, pwr_max],\n            title: { text: 'Power (W)' },\n        },\n        yaxis: {\n            side: 'left',            \n            range: [0, hie_max],\n            title: { text: 'Energy (J)', },\n        },\n        margin: { l: 45, r: 20, t: 30, b: 35 },\n        showlegend: false,\n    };\n\n    chart = {data, layout}\n}",
        "name": "W' Plot (Veloclinic Plot)"
      },
      "usage_count": 0,
      "index": 4,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-17T16:17:23.311+00:00",
      "from_athlete": {
        "id": "5776122",
        "name": "Hugo Joudrier",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/30aa47a5-889c-4c6e-8e71-a3054aa6dd74",
        "city": "Chambry",
        "state": "Rhne-Alpes",
        "country": "France",
        "timezone": "Europe/Paris",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 157269
    },
    {
      "id": 396060,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "MSS",
      "description": "MSS - Estado Estable (no es FTP) by controlmetrics.es",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "MSS",
        "icon": "closed_caption",
        "link": "www.controlmetrics.es",
        "type": "numeric",
        "color": "#CF6530",
        "gauge": true,
        "total": null,
        "units": " w",
        "inline": false,
        "prefix": null,
        "script": "(secret sauce)",
        "suffix": " w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "pace_units": null,
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "MSS"
      },
      "usage_count": 40,
      "index": 4,
      "hide_script": true,
      "hidden_by_id": "10385309",
      "updated": "2024-08-11T10:26:51.348+00:00",
      "from_athlete": {
        "id": "10385309",
        "name": "Luisma Gallego",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c7e97937-d358-425a-8acc-2c726c4b5cff",
        "city": "Cubelles",
        "state": "Barcelona",
        "country": "Spain",
        "timezone": "Europe/Madrid",
        "sex": "M",
        "bio": "Physiology Technician\n\nPersonal Trainer EREPS accreditation number 107429\n\nInstructor at Sportcoach.es\n\nPublications: https://dialnet.unirioja.es/servlet/articulo?codigo=8443236\n\nParticipant in several podcasts about training and cycling\n\nwww.controlmetrics.es\n",
        "website": "https://www.controlmetrics.es",
        "email": null
      },
      "from_id": 390433
    },
    {
      "id": 402924,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HEATMAP",
      "visibility": "PRIVATE",
      "name": "Power / Torque 3s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Power / Torque 3s",
        "plots": [
          {
            "id": "x",
            "max": null,
            "min": null,
            "text": "3s Power",
            "color": "#6633cc",
            "legend": false,
            "stream": "watts_3s",
            "transform": "none",
            "bucketSize": 5,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": null,
            "hideLastBucket": false,
            "hideFirstBucket": true
          },
          {
            "id": "y",
            "max": null,
            "min": null,
            "text": "Torque",
            "color": "#ff00ff",
            "legend": false,
            "stream": "torque",
            "transform": "moving_avg",
            "bucketSize": 1.5,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 3
            },
            "hideLastBucket": false,
            "hideFirstBucket": true
          }
        ],
        "steps": 10,
        "width": 510,
        "height": 350,
        "opacity": null,
        "colorScale": "interpolateWarm",
        "contourPlot": false,
        "trimPercent": null
      },
      "usage_count": 0,
      "index": 4,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:17:25.215+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 429606,
      "athlete_id": "i115436",
      "type": "ACTIVITY_STREAM",
      "visibility": "PRIVATE",
      "name": "Rear Gear",
      "description": "This chart shows the selected rear gear. Only works if the FIT file is available. The number of teeth must typically be configured on the head unit.\n\nTested with data from Wahoo+Di2.",
      "image": null,
      "content": {
        "pos": false,
        "code": "RearGear",
        "link": null,
        "name": "Rear Gear",
        "type": "numeric",
        "color": "#0E7BF1",
        "units": "teeth",
        "legend": null,
        "script": "{\n  let rear_gear, rear_gear_num, front_gear, front_gear_num\n\n  function fixValue(value) {\n    // I am not sure why, but sometimes the value is an array with the same value twice?\n    value = Array.isArray(value) ? value[0] : value\n    return value === 0 ? null : value\n  }\n\n  for (let m of icu.fit) {\n    switch (m.event?.valueName) {\n      case \"REAR_GEAR_CHANGE\":\n      case \"FRONT_GEAR_CHANGE\":\n        rear_gear      = fixValue(m.rear_gear?.value)\n        rear_gear_num  = fixValue(m.rear_gear_num?.value)\n        front_gear     = fixValue(m.front_gear?.value)\n        front_gear_num = fixValue(m.front_gear_num?.value)\n    }\n    let ts = m.timestamp\n    if (ts) data.setAt(ts.value, rear_gear)\n  }\n}",
        "convert": "",
        "no_nulls": true,
        "legend_pos": "topLeft",
        "domain_zero": false,
        "area_opacity": "0.05",
        "line_opacity": "0.7",
        "number_format": ".0f",
        "fit_record_field": null,
        "short_description": "Rear Gear (Di2/eTap/EPS)",
        "processes_fit_messages": true
      },
      "usage_count": 38,
      "index": 4,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-09-22T14:01:22.151+00:00",
      "from_athlete": {
        "id": "5022580",
        "name": "Jonas H",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/7acd5baf-12c2-48df-9eab-cbf0e62a797c",
        "city": "n/a",
        "state": "Central Denmark Region",
        "country": "Denmark",
        "timezone": "Europe/Copenhagen",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 186537
    },
    {
      "id": 612935,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "HRRc",
      "description": null,
      "image": null,
      "content": {
        "id": "jt8mgtj9",
        "name": "HRRc",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#000000FF",
            "text": "Day HRRc",
            "type": "dot",
            "field": "hrrc",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Heartrate recovery",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#D62728FF",
            "filters": [],
            "i18nKey": "HRRc",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Heartrate recovery",
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_max",
            "min": null,
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "Week HRRc",
            "type": "line",
            "field": "hrrc",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Heartrate recovery",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(214,39,40)",
            "filters": [],
            "i18nKey": "HRRc",
            "markerValue": "right",
            "strokeWidth": 1.5,
            "i18nTitleKey": "Heartrate recovery",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": null,
            "band": 0.7,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "Trend 42 HRRc",
            "type": "line",
            "field": "hrrc",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Heartrate recovery",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#D62829FF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "HRRc",
            "markerValue": "right",
            "strokeWidth": 0.2,
            "i18nTitleKey": "Heartrate recovery",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 220,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "HRRc",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 4,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-04T16:00:55.779+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 273770,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Threshold Power",
      "description": "Best ride power (max weekly) for 2m,5m,10m,15m,20m",
      "image": null,
      "content": {
        "id": "ptceadzu",
        "name": "Threshold Power",
        "plots": [
          {
            "id": 1,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 120
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "Power 2m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#D62728FF",
            "aggArgs": {
              "days": 90
            },
            "filters": [
              {
                "id": 1,
                "value": [],
                "field_id": "type"
              }
            ],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 300
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "Power 5m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009E00FF",
            "aggArgs": {
              "days": 90
            },
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 600
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "Power 10m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#1F77B4FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 900
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "Power 15m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#FF7F0EFF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 1200
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "Power 20m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#FFCB0EFF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 120
            },
            "band": 0,
            "fill": "#D62728FF",
            "text": "2m",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#D62728FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": 250.0,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "yAxisLabel": "Power",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 5,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-09T10:13:02.218+00:00",
      "from_athlete": {
        "id": "i62859",
        "name": "OSCAR MARTINEZ",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c295a232-660c-4a1c-abdb-a7ff5be4aaac",
        "city": "Paterna",
        "state": "Valencia",
        "country": "Spain",
        "timezone": "Europe/Madrid",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 55572
    },
    {
      "id": 274070,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PUBLIC",
      "name": "W'bal + Trend",
      "description": "W' balance with work trend",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/69607156-003f-43ee-ba1c-6e423e1dd38a",
      "content": {
        "id": null,
        "name": "W'bal + Trend",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "W'bal",
            "color": "#36DD2EFF",
            "extras": [],
            "legend": false,
            "stream": "w_bal",
            "transform": "none",
            "areaOpacity": 0.1,
            "lineOpacity": 2,
            "transformArgs": null
          },
          {
            "id": 2,
            "axis": null,
            "text": "W'bal",
            "color": "#FF00FFFF",
            "extras": [],
            "legend": false,
            "stream": "w_bal",
            "transform": "work_interval_linear_trend",
            "areaOpacity": 0.14,
            "lineOpacity": 0,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 60,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 43,
      "index": 5,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-09-24T09:02:49.506+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 279120,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "Heartrate vs AVGPower",
      "description": "This graph displays the average power at each harterate value during yours trainings",
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "300px",
        "script": "{\n// Ottenere i dati di potenza e cadenza\nlet power = icu.streams.get(\"watts\").data || [];\nlet heart= icu.streams.get(\"heartrate\").data || [];\n\n// Creare un oggetto per memorizzare la potenza media per ogni valore di cadenza\nlet averagePowerByHeart = {};\n\n// Calcolare la potenza media per ogni valore di cadenza\nfor (let i = 0; i < heart.length; i++) {\n    let currentHeart = heart[i];\n\n    if (!averagePowerByHeart[currentHeart]) {\n        averagePowerByHeart[currentHeart] = [];\n    }\n\n    averagePowerByHeart[currentHeart].push(power[i]);\n}\n\n// Creare array di dati per il grafico\npowerdata=[];\nheartdata=[];\ndata = [];\n\n// Calcolare la media per ciascun valore di cadenza e aggiungere i dati all'array\nfor (let heartValue in averagePowerByHeart) {\n    let powerValues = averagePowerByHeart[heartValue];\n    let averagePower = powerValues.reduce((acc, val) => acc + val, 0) / powerValues.length;\n     \n    // Aggiungere un oggetto al array di dati\n    powerdata.push(parseInt(averagePower));\n    heartdata.push(parseInt(heartValue));\n    //console.log(heartdata);\n}\n\ndata.push({\n        x: heartdata,\n        y: powerdata,\n        type: 'scatter',\n        mode: 'lines',\n        line: {\n             color: 'green', // Imposta il colore della linea su rosso\n             width: 2 // Imposta la larghezza della linea (puoi regolare questo valore)\n    }\n});\n\n    console.log(JSON.stringify(data, null, 2));\n\n// Definire il layout del grafico\nlet layout = {\n    title: {\n        text: \"Power vs Heartrate\"\n    },\n    xaxis: {\n        title: \"Heartrate\",\n        tickmode: 'linear',\n        dtick: 5\n    },\n    yaxis: {\n        title: \"Average Power\",\n        tickmode: 'linear',\n        dtick: 50\n    },\n    margin: {\n        l: 50,\n        r: 50,\n        t: 50,\n        b: 50\n    }\n};\n\n// Creare l'oggetto del grafico\nchart = {data,layout}\n\n}",
        "name": "Heartrate vs AVGPower"
      },
      "usage_count": 0,
      "index": 5,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-17T16:18:20.995+00:00",
      "from_athlete": {
        "id": "575919",
        "name": "Manuel Oberti ",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/92747c37-f199-4b45-9c5a-d92788fe9f58",
        "city": "Bonate Sopra",
        "state": "Lombardia",
        "country": "Italia",
        "timezone": "Europe/Rome",
        "sex": "M",
        "bio": null,
        "website": "https://www.strava.com/athletes/575919",
        "email": null
      },
      "from_id": 239547
    },
    {
      "id": 396061,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "P6",
      "description": "",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Pvo2max",
        "icon": "mdi-flash",
        "link": "",
        "type": "numeric",
        "color": "#DD04A7",
        "gauge": true,
        "total": null,
        "units": " w",
        "inline": false,
        "prefix": "",
        "script": "(secret sauce)",
        "suffix": " w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": [],
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": "",
        "processes_fit_messages": false,
        "name": "P6"
      },
      "usage_count": 40,
      "index": 5,
      "hide_script": true,
      "hidden_by_id": "10385309",
      "updated": "2025-11-21T19:32:58.683+00:00",
      "from_athlete": {
        "id": "10385309",
        "name": "Luisma Gallego",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c7e97937-d358-425a-8acc-2c726c4b5cff",
        "city": "Cubelles",
        "state": "Barcelona",
        "country": "Spain",
        "timezone": "Europe/Madrid",
        "sex": "M",
        "bio": "Physiology Technician\n\nPersonal Trainer EREPS accreditation number 107429\n\nInstructor at Sportcoach.es\n\nPublications: https://dialnet.unirioja.es/servlet/articulo?codigo=8443236\n\nParticipant in several podcasts about training and cycling\n\nwww.controlmetrics.es\n",
        "website": "https://www.controlmetrics.es",
        "email": null
      },
      "from_id": 392332
    },
    {
      "id": 402927,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HEATMAP",
      "visibility": "PRIVATE",
      "name": "Cadence / Torque 3s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Cadence / Torque 3s",
        "plots": [
          {
            "id": "x",
            "max": null,
            "min": null,
            "text": "Cadence",
            "color": "#ff00ff",
            "legend": false,
            "stream": "cadence",
            "transform": "moving_avg",
            "bucketSize": 1,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 3
            },
            "hideLastBucket": false,
            "hideFirstBucket": true
          },
          {
            "id": "y",
            "max": null,
            "min": null,
            "text": "Torque",
            "color": "#ff00ff",
            "legend": false,
            "stream": "torque",
            "transform": "moving_avg",
            "bucketSize": 1.5,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 3
            },
            "hideLastBucket": false,
            "hideFirstBucket": true
          }
        ],
        "steps": null,
        "width": 510,
        "height": 350,
        "opacity": null,
        "colorScale": "interpolateWarm",
        "contourPlot": false,
        "trimPercent": null
      },
      "usage_count": 0,
      "index": 5,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:17:27.008+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 429607,
      "athlete_id": "i115436",
      "type": "ACTIVITY_STREAM",
      "visibility": "PRIVATE",
      "name": "Front Gear",
      "description": "This chart shows the selected front gear. Only works if the FIT file is available. The number of teeth must typically be configured on the head unit.\n\nTested with data from Wahoo+Di2.",
      "image": null,
      "content": {
        "pos": false,
        "code": "FrontGear",
        "link": null,
        "name": "Front Gear",
        "type": "numeric",
        "color": "#0E7BF1",
        "units": "teeth",
        "legend": null,
        "script": "{\n  let rear_gear, rear_gear_num, front_gear, front_gear_num\n\n  function fixValue(value) {\n    // I am not sure why, but sometimes the value is an array with the same value twice?\n    value = Array.isArray(value) ? value[0] : value\n    return value === 0 ? null : value\n  }\n\n  for (let m of icu.fit) {\n    switch (m.event?.valueName) {\n      case \"REAR_GEAR_CHANGE\":\n      case \"FRONT_GEAR_CHANGE\":\n        rear_gear      = fixValue(m.rear_gear?.value)\n        rear_gear_num  = fixValue(m.rear_gear_num?.value)\n        front_gear     = fixValue(m.front_gear?.value)\n        front_gear_num = fixValue(m.front_gear_num?.value)\n    }\n    let ts = m.timestamp\n    if (ts) data.setAt(ts.value, front_gear)\n  }\n}",
        "convert": "",
        "no_nulls": true,
        "legend_pos": "topLeft",
        "domain_zero": false,
        "area_opacity": "0.05",
        "line_opacity": "0.7",
        "number_format": ".0f",
        "fit_record_field": null,
        "short_description": "Front Gear (Di2/eTap/EPS)",
        "processes_fit_messages": true
      },
      "usage_count": 38,
      "index": 5,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-09-22T14:01:25.654+00:00",
      "from_athlete": {
        "id": "5022580",
        "name": "Jonas H",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/7acd5baf-12c2-48df-9eab-cbf0e62a797c",
        "city": "n/a",
        "state": "Central Denmark Region",
        "country": "Denmark",
        "timezone": "Europe/Copenhagen",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 186540
    },
    {
      "id": 683183,
      "athlete_id": "i115436",
      "type": "INTERVAL_FIELD",
      "visibility": "PRIVATE",
      "name": "Estimated cdA",
      "description": "This script calculates the drag coefficient times the frontal area (cdA) for a cyclist, an important factor in determining aerodynamic drag. It uses input data such as average weather temperature, altitude, rider weight, road gradient, speed, power output, and wind speed. The script calculates the effective wind speed by considering the percentages of headwind and tailwind. It then computes the air density based on altitude and temperature, and determines the rolling resistance considering the road gradient and total mass. Finally, it calculates the cdA value based on the power output, speed, rolling resistance, and air density. The resulting cdA value is crucial for aerodynamic evaluation and performance analysis of the cyclist.",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "EstimatedcdA",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#FFB000",
        "gauge": true,
        "total": false,
        "units": "m",
        "prefix": null,
        "script": "{\n    // Variables\n    const c_r = 0.00330;    // Rolling resistance coefficient \n    const m_Bike = 9;       // Mass of bike + clothes + bottles (kg)\n\n    // Constants\n    const rho_0 = 1.293;  // Density of air at sea level (kg/m^3)\n    const g = 9.81;       // Acceleration due to gravity (m/s^2)\n    const P_0 = 101325;   // Standard atmospheric pressure (Pa)\n    const c_M = 0.99;     // Mechanical efficiency \n\n    const T = interval.average_weather_temp + 273.15; // Temperature (K)\n    const H_nn = (interval.max_altitude + interval.min_altitude) / 2;  // Altitude (m)\n    const m_Rider = wellness.weight;  // Mass of rider (kg)\n    const grade = interval.average_gradient * 100;  // Road grade (%)\n    const v = interval.average_speed;  // Speed (m/s)\n    const P = interval.average_watts;  // Power output (W)\n    \n    // Wind\n    const w_speed = interval.average_wind_speed;  // Wind speed (m/s)\n\n    // Calculate effective wind speed\n    const w = w_speed * interval.headwind_percent / 100 - w_speed * interval.tailwind_percent / 100;\n\n    // Calculate air density\n    const rho = rho_0 * 373 / T * Math.exp(-rho_0 * g * H_nn / P_0);\n\n    // Calculate rolling resistance\n    const beta = Math.atan(grade / 100);\n    const F_rg = g * (m_Bike + m_Rider) * (c_r * Math.cos(beta) + Math.sin(beta));\n\n    // Calculate cdA\n    const c_rVn = 0.1 * Math.cos(beta);\n    const cdA = (P / (c_M * v) - F_rg - v * c_rVn) / (rho / 2 * Math.pow(v + w, 2));\n\n    cdA;\n}",
        "suffix": "m",
        "average": true,
        "convert": "",
        "example": 42,
        "options": null,
        "text_wrap": null,
        "pace_units": null,
        "text_align": null,
        "number_format": ".2f",
        "processes_fit_messages": false,
        "name": "Estimated cdA"
      },
      "usage_count": 0,
      "index": 5,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-06-19T13:50:27.504+00:00",
      "from_athlete": {
        "id": "i85346",
        "name": "R2Tom",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/9effd3aa-d71f-4dc5-a60b-bd8a7af746e5",
        "city": "Altdorf",
        "state": "Bavaria",
        "country": "Germany",
        "timezone": "Europe/Berlin",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 548711
    },
    {
      "id": 735042,
      "athlete_id": "i115436",
      "type": "INPUT_FIELD",
      "visibility": "PRIVATE",
      "name": "Fasi ciclo",
      "description": "fase mestruale",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Ciclo",
        "icon": "",
        "link": null,
        "type": "select",
        "color": "#009E00",
        "gauge": false,
        "total": null,
        "units": null,
        "prefix": null,
        "script": null,
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 3,
        "options": [
          {
            "icon": null,
            "text": " Mestruale",
            "color": "#D62728",
            "value": 1.0
          },
          {
            "icon": null,
            "text": "Follicolare",
            "color": "#334CCC",
            "value": 2.0
          },
          {
            "icon": null,
            "text": "Ovulatorio",
            "color": "#2CA02C",
            "value": 3.0
          },
          {
            "icon": null,
            "text": "Luteale",
            "color": "#ff00ff",
            "value": 4.0
          }
        ],
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "processes_fit_messages": false,
        "name": "Fasi ciclo"
      },
      "usage_count": 32,
      "index": 5,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-20T09:35:04.626+00:00",
      "from_athlete": {
        "id": "i180702",
        "name": "campanella",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/f458629b-7f60-4554-bf9f-c5e5b88bc1a3",
        "city": "Trento",
        "state": "Trentino",
        "country": "Italy",
        "timezone": "Europe/Rome",
        "sex": "F",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 660148
    },
    {
      "id": 275624,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "Power Mobile",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "Power Mobile",
        "plots": [
          {
            "id": 1,
            "text": "Power",
            "color": "#1F77B4FF",
            "extras": [],
            "legend": false,
            "stream": "watts",
            "transform": "none",
            "areaOpacity": 0.1,
            "lineOpacity": 1,
            "transformArgs": null
          },
          {
            "id": 2,
            "text": "Power",
            "color": "#FF00FFFF",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "work_interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "strokeWidth": 1.5,
            "transformArgs": null
          },
          {
            "id": 3,
            "text": "Power",
            "color": "#3FF032FF",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "work_interval_linear_trend",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "strokeWidth": 1.75,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 120,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 6,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-12T08:27:46.295+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 365430,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HISTOGRAM",
      "visibility": "FOLLOWERS",
      "name": "Power 20s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Power 20s",
        "plots": [
          {
            "id": 1,
            "text": "Power 20s",
            "type": "bars",
            "color": "#1F77B4FF",
            "legend": false,
            "stream": "raw_watts",
            "transform": "moving_avg",
            "bucketSize": 20,
            "areaOpacity": 0.75,
            "lineOpacity": 0.7,
            "trimPercent": 0.1,
            "transformArgs": {
              "secs": 20
            },
            "hideLastBucket": false,
            "hideFirstBucket": true
          }
        ],
        "width": 540,
        "height": 320
      },
      "usage_count": 1,
      "index": 6,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-08-21T14:50:55.527+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396105,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "All Work>CP",
      "description": "The built in Work>FTP metric only counts the part of the work that is over FTP i.e. the area of the power curve above the FTP line. This measure includes the below the line portion when operating at or above FTP.",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "AllWorkFTP",
        "icon": "battery_alert",
        "link": null,
        "type": "numeric",
        "color": "#EE2C6D",
        "gauge": true,
        "total": null,
        "units": "kJ",
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntime =  streams.get(\"time\").data\nftp = activity.icu_ftp\njoules = 0\nfor (let i = 0; i < watts.length; i++) {\n  let w = watts[i]\n  if (w >= ftp) { \n    let secs = time[i] - (i > 0 ? time[i - 1] : 0)\n    if (secs < 30) joules += w * secs\n  }\n}\njoules/1000",
        "suffix": " kJ",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "All Work>CP"
      },
      "usage_count": 41,
      "index": 6,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T09:55:30.970+00:00",
      "from_athlete": {
        "id": "2049151",
        "name": "David (intervals.icu)",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/37e18c85-cac7-4c45-8dc8-2e716f4b66d2",
        "city": "Cape Town",
        "state": "Western Cape",
        "country": "South Africa",
        "timezone": "Africa/Johannesburg",
        "sex": "M",
        "bio": "Software Engineer and keen cyclist!",
        "website": "https://intervals.icu",
        "email": null
      },
      "from_id": 83222
    },
    {
      "id": 435202,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HEATMAP",
      "visibility": "PRIVATE",
      "name": "Cadence - Gradient",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Cadence - Gradient",
        "plots": [
          {
            "id": "x",
            "max": null,
            "min": null,
            "axis": null,
            "text": "Cadence",
            "color": "#ff00ff",
            "legend": false,
            "stream": "cadence",
            "transform": "none",
            "bucketSize": 1,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": null,
            "hideLastBucket": false,
            "hideFirstBucket": true
          },
          {
            "id": "y",
            "max": null,
            "min": null,
            "axis": null,
            "text": "Gradient",
            "color": "#34ace4",
            "legend": false,
            "stream": "grade_smooth",
            "transform": "none",
            "bucketSize": 1,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": null,
            "hideLastBucket": false,
            "hideFirstBucket": true
          }
        ],
        "steps": null,
        "width": 510,
        "height": 350,
        "opacity": null,
        "colorScale": "icuZoneColours",
        "contourPlot": true,
        "trimPercent": 0.1
      },
      "usage_count": 0,
      "index": 6,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:17:13.645+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 453397,
      "athlete_id": "i115436",
      "type": "ACTIVITY_STREAM",
      "visibility": "FOLLOWERS",
      "name": "AEROPOINT beta",
      "description": "",
      "image": null,
      "content": {
        "pos": false,
        "code": "AEROPOINT",
        "link": null,
        "name": "AEROPOINT beta",
        "type": "numeric",
        "color": "#334CCC",
        "units": "smoothness",
        "legend": null,
        "script": "{\nlet watts = icu.streams.fixed_watts\nlet speed = icu.streams.velocity_smooth\nfor (let i = 0; i < data.length; i++) data[i] = (speed[i] + 100000/ (watts[i] + 100000) * 20)\n}",
        "convert": "",
        "no_nulls": true,
        "legend_pos": "topLeft",
        "domain_zero": false,
        "area_opacity": "0.05",
        "line_opacity": "1",
        "number_format": ".1f",
        "fit_record_field": "",
        "short_description": null,
        "processes_fit_messages": false
      },
      "usage_count": 1,
      "index": 6,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-30T12:08:25.758+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659632,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "Cumulative Time at Power",
      "description": "A power version of the \"Cumulative Time\" HR plot, displays the total time you spent at or above power values.",
      "image": null,
      "content": {
        "link": null,
        "width": "50%",
        "height": "300px",
        "script": "{\n\n    /**\n     * Formats the given number of seconds into a string representation of hours, minutes, and seconds.\n     * @param seconds - The number of seconds to format.\n     * @returns The formatted string representation of the time in the format \"hh:mm:ss\".\n     */\n    function formatHMS(seconds) {\n        let h = Math.floor(seconds / 3600);\n        let m = Math.floor((seconds % 3600) / 60);\n        let s = seconds % 60;\n        if (h > 0) {\n            return h + \"h\" + m + \"m\";\n        } else {\n            return m + \"m\" + s + \"s\";\n        }\n    }\n\n    /*\n    Process data\n    */\n    let activity = icu.activity;    \n    let streams = icu.streams;\n    let pwr = streams.get(\"fixed_watts\").data;\n\n    let pwrMax = Math.max(...pwr);\n    let pwrMin = 0;\n\n    // Build histogram of time at each power level\n    // Initialize histogram from 0 to pwrMax with zeros\n    let pwrHistogram = new Array(pwrMax+1).fill(0);\n    // For every entry in the power timeseries, increment the corresponding histogram bin\n    for (let i = 0; i < pwr.length; i++) {\n        if (pwr[i] > pwrMin) pwrHistogram[pwr[i]]++;\n    }\n\n    // Accumulate data from max power down\n    let ftp = activity.icu_ftp;\n    let data_Pwr = [];\n    let data_Time = [];\n    let data_Text = [];\n    let cumulativeTime = 0;\n    for (let pow = pwrMax; pow >= pwrMin; pow--) {\n        // power\n        data_Pwr.push(pow);\n        // cumulative time at or above this power value\n        cumulativeTime += pwrHistogram[pow];\n        data_Time.push(cumulativeTime);\n        // text for hover\n        let percent_ftp = (pow / ftp * 100).toFixed(1);\n        let str = pow + \" W<br>\" + percent_ftp + \"%<br>\" + formatHMS(cumulativeTime) ;\n        data_Text.push(str);\n    }\n\n    /*\n    Draw power zone boundaries\n    */\n    let zonePercents = activity.icu_power_zones;\n    // Transform zonePercents into watts\n    let zoneWatts = zonePercents.map(z => Math.min(pwrMax, Math.floor(ftp * z / 100)));\n    // Build a complete list of boundaries including pwrMax (left end) and pwrMin (right end)\n    // Omit pwrMax, this already ends up as the top of Z7 due to Math.min expression in zoneWatts def above, since intervals.icu includes final power zone boundary of 999\n    let boundaries = [pwrMin, ...zoneWatts];\n\n    // We'll draw vertical lines at each zone boundary except the far left (pwrMax) and far right (pwrMin)\n    // and place annotations for each zone label in the center of each zone\n    let shapes = [];\n    let annotations = [];\n    let numZones = boundaries.length - 1; // if we have n boundaries, we have n zones\n    // For every interior boundary, draw a vertical line\n    for (let i = 1; i < boundaries.length - 1; i++) {\n        shapes.push({\n            type: 'line',\n            xref: 'x',\n            yref: 'paper',\n            x0: boundaries[i],\n            x1: boundaries[i],\n            y0: 0,\n            y1: 1,\n            line: { color: '#DDDDDD', width: 1 },\n            layer: 'below' \n        });\n    }\n\n    // For every zone, place a label in the center\n    for (let i = 0; i < numZones; i++) {\n        let left = boundaries[i];\n        let right = boundaries[i+1];\n        let mid = (left + right) / 2;\n        let zoneLabel = \"Z\" + (i + 1);\n        annotations.push({\n            x: mid,\n            xref: 'x',\n            yref: 'paper',\n            y: 0.01,  // small offset above x-axis\n            text: zoneLabel,\n            showarrow: false,\n            xanchor: 'center',\n            yanchor: 'bottom',\n            font: { color: '#999999', size:10 }\n        });\n    }\n\n    /*\n    Graph Layout\n    */\n\n    // Define y-axis ticks for log scale\n    // After computing data_Time and determining the max cumulative time:\n    let maxTime = Math.max(...data_Time);\n    // Compute upper range for plotting later\n    let upperLog = Math.log10(maxTime) + 0.1; // add a small buffer so the top data point isn't right on the edge\n\n\n    // Base ticks (up to 1h)\n    let baseTicks = [1,5,10,30,60,120,300,600,1200,3600];\n    let baseLabels = [\"1s\",\"5s\",\"10s\",\"30s\",\"1m\",\"2m\",\"5m\",\"10m\",\"20m\",\"1h\"];\n\n    let tickvals = [];\n    let ticktext = [];\n\n    // Add all base ticks up to 1h or up to maxTime, whichever is smaller\n    for (let i = 0; i < baseTicks.length; i++) {\n        if (baseTicks[i] <= maxTime) {\n            tickvals.push(baseTicks[i]);\n            ticktext.push(baseLabels[i]);\n        }\n    }\n\n    // If maxTime goes beyond 1h, generate hourly ticks up to maxTime\n    if (maxTime > 3600) {\n        // Start from 2h and go upwards\n        let hour = 2;\n        while (hour * 3600 <= maxTime) {\n            tickvals.push(hour * 3600);\n            ticktext.push(hour + \"h\");\n            hour++;\n        }\n    }\n\n    // Create the plot data\n    let trace = {\n        x: data_Pwr,\n        y: data_Time,\n        text: data_Text,\n        type: 'scatter',\n        mode: 'lines',\n        hoverinfo: 'text',\n        line: { color: '#cc0000' }\n    };\n    let data = [trace];\n\n    // Plot layout\n    let layout = {\n        title: {\n            text: \"Cumulative Time At or Above Power\",\n            font: { color: '#999999' }\n        },\n        spikedistance: -1,\n        hoverlabel: {\n            bgcolor: '#ffffff',\n            font: {\n                color: '#333333'\n            }\n        },\n        xaxis: {\n            title: \"Power (W)\",\n            range: [pwrMax, pwrMin], // inverted axis\n            showline: true,\n            zeroline: false,\n            showgrid: false, // no vertical grid lines, just ticks\n            color: '#999999',\n            tickmode: 'auto',\n            // Hover hairline setup\n            showspikes: true,\n            spikemode: 'across',\n            spikesnap: 'cursor',\n            spikecolor: '#999999',\n            spikedash: 'solid',\n            spikethickness: 1,\n        },\n        yaxis: {\n            title: \"Cumulative Time\",\n            type: 'log',\n            tickvals: tickvals,\n            ticktext: ticktext,\n            showline: true,\n            zeroline: false,\n            showgrid: true, // horizontal lines are okay\n            color: '#999999',\n            // no horizontal spike line\n            showspikes: false,\n            range: [0, upperLog]\n        },\n        margin: { l: 50, r: 20, t: 30, b: 40 },\n        hovermode: 'x', // vertical line only\n        shapes: shapes,\n        annotations: annotations,\n        showlegend: false\n    };\n\n    chart = { data, layout };\n}",
        "name": "Cumulative Time at Power"
      },
      "usage_count": 0,
      "index": 6,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T16:53:22.048+00:00",
      "from_athlete": {
        "id": "i29030",
        "name": "Greg Marcil",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/67667eca-0106-48f1-a1be-485fcbfdc351",
        "city": null,
        "state": null,
        "country": null,
        "timezone": "America/Los_Angeles",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 508090
    },
    {
      "id": 748437,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "max HR",
      "description": null,
      "image": null,
      "content": {
        "id": "zaxwduyy",
        "name": "max HR",
        "plots": [
          {
            "id": 1,
            "agg": "max_days",
            "min": null,
            "band": 0,
            "fill": "rgba(255,82,14, 0.4)",
            "text": "Max 30W",
            "type": "line",
            "field": "max_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Max heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#d62728ff",
            "aggArgs": {
              "days": 210
            },
            "filters": [],
            "i18nKey": "Max HR",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Max heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "max_days",
            "min": null,
            "band": 0,
            "fill": "rgba(255,82,14, 0.4)",
            "text": "Max 42d",
            "type": "line",
            "field": "max_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Max heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(255,82,14)",
            "aggArgs": {
              "days": 42
            },
            "filters": [],
            "i18nKey": "Max HR",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Max heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#009e0000",
            "text": "Max activity",
            "type": "dot",
            "field": "max_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Max heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [],
            "i18nKey": "Max HR",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Max heartrate",
            "invertSubWellness": false
          }
        ],
        "title": "HRMAX",
        "height": 330,
        "yAxisMax": 210.0,
        "yAxisMin": 150.0,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 6,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-09-02T12:23:57.929+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 273804,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "CP Power",
      "description": null,
      "image": null,
      "content": {
        "id": "38u9bx5q",
        "name": "CP Power",
        "plots": [
          {
            "id": 1,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 300
            },
            "band": 0,
            "fill": "#FFCB0EBF",
            "text": "5m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#FFCB0EBF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 360
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "6m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#FF520EFF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 480
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "8m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009E00FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 720
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "12m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#DD04A7FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 1200
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "20m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#DD044747",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 1500
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "25m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#00C9FFFF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 7,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 300
            },
            "band": 0,
            "fill": "#FFCB0EBF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 8,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 360
            },
            "band": 0,
            "fill": "#FF520EFF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 9,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 480
            },
            "band": 0,
            "fill": "#009E00FF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 10,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 720
            },
            "band": 0,
            "fill": "#DD04A7FF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 11,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 1200
            },
            "band": 0,
            "fill": "#DD044747",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 12,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 1500
            },
            "band": 0,
            "fill": "#00C9FFFF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 330,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "POWER",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 7,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-23T18:22:26.471+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 275628,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "HR Mobile",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "HR Mobile",
        "plots": [
          {
            "id": 1,
            "text": "HR TREND",
            "color": "#3FF032FF",
            "extras": [],
            "legend": true,
            "stream": "heartrate",
            "transform": "work_interval_linear_trend",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "transformArgs": null
          },
          {
            "id": 2,
            "text": "PWR",
            "color": "#FF00FFFF",
            "extras": [],
            "legend": true,
            "stream": "heartrate",
            "transform": "work_interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "transformArgs": null
          },
          {
            "id": 3,
            "text": "HR",
            "color": "#dd0447",
            "extras": [],
            "legend": false,
            "stream": "heartrate",
            "transform": "none",
            "areaOpacity": 0.1,
            "lineOpacity": 1,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 60,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 7,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-12T08:16:53.635+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 365432,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HISTOGRAM",
      "visibility": "FOLLOWERS",
      "name": "HR 20s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "HR 20s",
        "plots": [
          {
            "id": 1,
            "text": "HR 20s",
            "type": "bars",
            "color": "#dd0447",
            "legend": false,
            "stream": "raw_heartrate",
            "transform": "moving_avg",
            "bucketSize": 5,
            "areaOpacity": 0.7,
            "lineOpacity": 0.7,
            "trimPercent": 0.5,
            "transformArgs": {
              "secs": 20
            },
            "hideFirstBucket": false
          }
        ],
        "width": 540,
        "height": 320
      },
      "usage_count": 1,
      "index": 7,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-08-21T14:51:04.117+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396106,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "Time Above CP",
      "description": "This field calculates the total time above FTP",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "TimeAboveFTP",
        "icon": "timer",
        "link": null,
        "type": "numeric",
        "color": "#6633CC",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": null,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\nftp = activity.icu_ftp\nconsole.log(\"ftp\", ftp)\ntime_above = 0\nfor (let i = 0; i < watts.length; i++) {\n   w = watts[i]\n  if (w >= ftp) time_above += 1\n}\n\ntime_above",
        "suffix": "",
        "average": null,
        "convert": "duration",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Time Above CP"
      },
      "usage_count": 40,
      "index": 7,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T09:25:30.488+00:00",
      "from_athlete": {
        "id": "169405",
        "name": "Benjamin Hendler",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/21d0156e-c630-4dec-8427-a2cc37af7bff",
        "city": "Stockholm",
        "state": "",
        "country": "Sverige",
        "timezone": "Europe/Stockholm",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 84442
    },
    {
      "id": 464660,
      "athlete_id": "i115436",
      "type": "ACTIVITY_STREAM",
      "visibility": "PRIVATE",
      "name": "Aeropoint2.0",
      "description": null,
      "image": null,
      "content": {
        "pos": false,
        "code": "Aeropoint20",
        "link": null,
        "name": "Aeropoint2.0",
        "type": "numeric",
        "color": "#0E7BF1",
        "units": "W/Kg",
        "legend": null,
        "script": "for (let i = 0; i < icu.streams.fixed_watts.length; i++) {\n    if (icu.streams.fixed_watts[i] > 0) {\n        let watts = icu.streams.fixed_watts[i];\n        let velocity = icu.streams.velocity_smooth[i];\n        let logVelocity = Math.log(velocity + 1);\n        data[i] = (logVelocity + (1 / (watts + 1))) * 10 + 10;\n    } else {\n        data[i] = 0;\n    }\n}",
        "convert": "",
        "no_nulls": false,
        "legend_pos": "topLeft",
        "domain_zero": false,
        "area_opacity": "0.05",
        "line_opacity": "0.7",
        "number_format": ".1f",
        "fit_record_field": null,
        "short_description": null,
        "processes_fit_messages": false
      },
      "usage_count": 10,
      "index": 7,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-30T12:50:35.496+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 679342,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "Smart Climb Segments",
      "description": "This code is partly based on the script Climb Details. It identifies and analyzes climbs within a cycling activity based on specific criteria such as minimum grade and distance. The identification was improved to better recognise longer climbs, and less smaller hills. Additionally it corrects the calculation of distance and elevation and therefor gradient for summarised climbs. \n\nIt calculates various metrics for each climb, including average grade, average power, heart rate, vertical ascent speed, and difficulty coefficient. The results are visualized on a plot with annotated data for each climb and a gradient-colored profile based on the difficulty level. ",
      "image": null,
      "content": {
        "link": "https://forum.intervals.icu/t/compare-segments/96258/27?u=r2tom",
        "width": "100%",
        "height": "400px",
        "script": "function getBestAverageOverNSeconds(data, n, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let bestAvg = 0;\n    for (let i = 0; i <= data.length - windowSize; i++) {\n        const window = data.slice(i, i + windowSize);\n        const avg = window.reduce((a, b) => a + b, 0) / window.length;\n        if (avg > bestAvg) bestAvg = avg;\n    }\n    return bestAvg;\n}\n\n{\n   // Variabili di configurazione\n    const SECTION_LENGTH = 50; \n    const MIN_SEGMENTS = 7; \n    const MIN_GRADE = 2; \n    const MAX_GRADE_END = 1; \n    const MAX_GAP_SEGMENTS = 5; \n    const MIN_DIFFICULTY = 25;\n\n\n    // Funzione per recuperare i dati dei flussi\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n    \n    // Recupero dei flussi dati\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\"); // Flusso distanza in metri\n    const distanceKm = distance.map(d => d / 1000); // Conversione distanza in chilometri\n    const power = getStreamData(\"fixed_watts\"); // Flusso potenza in watt\n    const heartrate = getStreamData(\"fixed_heartrate\"); // Flusso frequenza cardiaca in bpm\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\"); // Flusso tempo (in secondi)\n    \n    // Correggi i valori iniziali del profilo altimetrico\n    const firstNonZeroAltitude = altitude.find(value => value !== 0);\n    if (firstNonZeroAltitude !== undefined) {\n        for (let i = 0; i < altitude.length; i++) {\n            if (altitude[i] === 0) {\n                altitude[i] = firstNonZeroAltitude;\n            } else {\n                break;\n            }\n        }\n    }\n    \n     \n    let sections = [];\n    let currentStartIndex = 0;\n    \n    // Suddivisione in sezioni\n    for (let i = 1; i < distance.length; i++) {\n        const distDiff = distance[i] - distance[currentStartIndex];\n        if (distDiff >= SECTION_LENGTH || i === distance.length - 1) {\n            const altDiff = altitude[i] - altitude[currentStartIndex];\n            const sectionGrade = (altDiff / distDiff) * 100;\n    \n            sections.push({\n                   sectionIndex: sections.length,\n                startIndex: currentStartIndex,\n                endIndex: i,\n                distance: distDiff,\n                elevation: altDiff,\n                grade: sectionGrade\n            });\n    \n            currentStartIndex = i;\n        }\n    }\n    \n    // Identificazione delle salite in base ai criteri\n    let climbs = [];\n    let currentClimb = { startSegment: null, endSegment: null };\n    \n    sections.forEach((section, index) => {\n        if (currentClimb.startSegment === null && section.grade >= MIN_GRADE) {\n            // Inizio di una nuova salita\n            currentClimb.startSegment = section.sectionIndex;\n        } else if (currentClimb.startSegment !== null && (section.grade < MAX_GRADE_END || index === sections.length - 1)) {\n            // Fine della salita\n            currentClimb.endSegment = section.sectionIndex-1;\n    \n            // Verifica dei criteri\n            if (currentClimb.endSegment-currentClimb.startSegment >= MIN_SEGMENTS) {\n                  console.log(`${currentClimb.startSegment} ${currentClimb.endSegment}`);\n                climbs.push({ ...currentClimb });\n            }\n    \n            // Reset della salita\n            currentClimb = { startSegment: null, endSegment: null };\n        }\n    });\n      \n    // Unisci salite e gap come parte della salita\n    for (let i = 1; i < climbs.length; i++) {\n        const prevClimb = climbs[i - 1];\n        const currentClimb = climbs[i];\n        const gapSegments = currentClimb.startSegment - prevClimb.endSegment;\n    \n        if (gapSegments <= MAX_GAP_SEGMENTS) {\n            // Unisci gap e salite\n            prevClimb.endSegment = currentClimb.endSegment;\n            climbs.splice(i, 1);\n            i--; // Aggiorna l'indice perch una salita  stata rimossa\n        }\n    }\n    \n    // Visualizzazione delle salite identificate\n    let annotations = [];\n    let traces = [];\n    let climbNo = 0;\n    //climbs.forEach((climb, climbNo) => {\n    climbs.forEach(climb => {\n        const startIndex = sections[climb.startSegment].startIndex;\n        const endIndex = sections[climb.endSegment].endIndex;\n    const climbSections = sections.slice(climb.startSegment, climb.endSegment);\n    // Calcolo dati salita: distanza e dislivello come differenza tra quota finale e iniziale\n    const dist = distance[endIndex] - distance[startIndex];\n    const elevationGain = altitude[endIndex] - altitude[startIndex];\n    const avgGrade = elevationGain / dist * 100;\n        const difficultyCoefficient = Math.pow(avgGrade, 2) * (dist / 1000);\n\n        // Filtra le salite con difficolt inferiore a 5\n        if (difficultyCoefficient < MIN_DIFFICULTY) {\n            return; // Ignora questa salita\n        }\n\n        climbNo++; \n    const climbPowers = power.slice(startIndex, endIndex);\n    // Calcolo potenza media prima e seconda met salita e rapporto\n    const half = Math.floor(climbPowers.length / 2);\n    const rat_1 = half > 0 ? climbPowers.slice(0, half).reduce((a, b) => a + b, 0) / half : 0;\n    const rat_2 = (climbPowers.length - half) > 0 ? climbPowers.slice(half).reduce((a, b) => a + b, 0) / (climbPowers.length - half) : 0;\n    const ratio = rat_1 > 0 ? rat_2 / rat_1 : 0;\n\n    // climbPowers gi dichiarato sopra\n    const climbHRs = heartrate.slice(startIndex, endIndex);\n    const hasHR = climbHRs.some(hr => hr > 0);\n    const climbCadence = getStreamData(\"cadence\").slice(startIndex, endIndex);\n    const avgPower = climbPowers.reduce((a, b) => a + b, 0) / climbPowers.length;\n    const best5sWatts = getBestAverageOverNSeconds(climbPowers, 5);\n    const avgHR = hasHR ? climbHRs.reduce((a, b) => a + b, 0) / climbHRs.length : null;\n    const maxHR = hasHR ? Math.max(...climbHRs) : null;\n    const avgCadence = climbCadence.length ? climbCadence.reduce((a, b) => a + b, 0) / climbCadence.length : 0;\n        const climbTimeInSeconds = time[endIndex] - time[startIndex];\n        function formatSecondsToHHMMSS(seconds) {\n            const sec = Math.floor(seconds % 60);\n            const min = Math.floor((seconds / 60) % 60);\n            const hr = Math.floor(seconds / 3600);\n            return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n        }\n        const formattedTime = `${Math.floor(climbTimeInSeconds / 60)}m${climbTimeInSeconds % 60}s`;\n        const formattedTimeHHMMSS = formatSecondsToHHMMSS(climbTimeInSeconds);\n        const ascentSpeed = elevationGain / (climbTimeInSeconds / 3600);\n        const avgHorizontalSpeed = (dist / 1000) / (climbTimeInSeconds / 3600);\n        const maxGrade = Math.max(...grade.slice(startIndex, endIndex));\n        const weight = icu.activity.icu_weight;\n        const avgPowerPerKg = weight ? avgPower / weight : 0;\n        const best5sPerKg = weight ? best5sWatts / weight : 0;\n        const gradientFactor = (2 + avgGrade / 10) * 100;\n        const TEORICWKG = ascentSpeed / gradientFactor;\n        const TEORICVAM = avgPowerPerKg * gradientFactor;\n        const vamDiff = ascentSpeed - TEORICVAM;\n        let vamArrow = '';\n        if (vamDiff > 10) {\n            vamArrow = ` +${vamDiff.toFixed(0)} m/h`;\n        } else if (vamDiff < -10) {\n            vamArrow = ` ${vamDiff.toFixed(0)} m/h`;\n        } else {\n            vamArrow = `  ${vamDiff.toFixed(0)} m/h`;\n        }\n\n        // Calcolo percentuale differenza tra TEORICWKG e avgPowerPerKg\n        let teoricWkgDiffPerc = '';\n        if (TEORICWKG && avgPowerPerKg) {\n            teoricWkgDiffPerc = ((avgPowerPerKg - TEORICWKG) / avgPowerPerKg * 100).toFixed(1) + '%';\n        }\n        // Calcolo kJ accumulati fino all'inizio della salita\n        let kJ_accum = 0, kJ_accum_overCP = 0;\n        const FTP = icu.activity.icu_ftp;\n        for (let i = 1; i < startIndex; i++) {\n            const dt = time[i] - time[i - 1];\n            kJ_accum += power[i] * dt / 1000;\n            if (power[i] >= FTP) kJ_accum_overCP += power[i] * dt / 1000;\n        }\n        const hours = time[startIndex] / 3600;\n        const kJ_per_h_kg = (weight && hours > 0) ? kJ_accum / hours / weight : 0;\n        const kJ_overCP_per_h_kg = (weight && hours > 0) ? kJ_accum_overCP / hours / weight : 0;\n        \n        // Determina il colore secondo la scala\n        let bgColor = \"grey\";\n        if (difficultyCoefficient >= 25 && difficultyCoefficient < 75) bgColor = \"yellowgreen\";\n        else if (difficultyCoefficient >= 75 && difficultyCoefficient < 150) bgColor = \"orange\";\n        else if (difficultyCoefficient >= 150 && difficultyCoefficient < 300) bgColor = \"darkorange\";\n        else if (difficultyCoefficient >= 300 && difficultyCoefficient < 600) bgColor = \"orangered\";\n        else if (difficultyCoefficient >= 600 && difficultyCoefficient < 900) bgColor = \"firebrick\";\n        else if (difficultyCoefficient >= 900 && difficultyCoefficient < 1200) bgColor = \"maroon\";\n        else if(difficultyCoefficient >= 1200) bgColor = \"black\";\n        \n        traces.push({\n            x: distanceKm.slice(startIndex, endIndex),\n            y: altitude.slice(startIndex, endIndex),\n            type: 'scatter',\n            mode: 'lines',\n            line: { color: bgColor, width: 2 },\n            name: `Anstieg ${climbNo}`,\n            hoverinfo: 'text',\n            text: `Climb ${climbNo}<br>\n ${(dist / 1000).toFixed(2)} km (${elevationGain.toFixed(0)} hm)<br>\n  ${avgGrade.toFixed(1)}% | max. ${maxGrade.toFixed(1)}%<br>\n ${avgPower.toFixed(0)} W | 5${best5sWatts.toFixed(0)}W   ${avgCadence.toFixed(0)} rpm<br>\n ${avgPowerPerKg.toFixed(2)} W/kg | 5 ${best5sPerKg.toFixed(2)} W/kg<br>\n ${rat_1.toFixed(0)} W | ${rat_2.toFixed(0)} W | ${ratio.toFixed(2)}<br>\n${hasHR ? `  ${avgHR.toFixed(0)} bpm | max. ${maxHR} bpm<br>` : ''}\n ${formattedTimeHHMMSS} |  ${avgHorizontalSpeed.toFixed(1)} km/h<br>\n ${ascentSpeed.toFixed(0)} m/h${vamArrow} | ${(avgPowerPerKg - TEORICWKG).toFixed(2)} W/kg<br>\n ${TEORICWKG.toFixed(2)} W/kg | ${TEORICVAM.toFixed(0)} VAM | ${teoricWkgDiffPerc}<br>\n ${formatSecondsToHHMMSS(time[startIndex])}<br>\n ${Math.round(kJ_accum)} kJ | ${Math.round(kJ_accum_overCP)} kJ > CP<br>\n ${kJ_per_h_kg.toFixed(1)} kJ/h/kg | ${kJ_overCP_per_h_kg.toFixed(1)} kJ/h/kg > CP`\n        });\n\n        // Annotazione permanente: coefficiente di difficolt (scala colori)\n        annotations.push({\n            x: (distanceKm[startIndex] + distanceKm[endIndex]) / 2,\n            y: Math.max(...altitude) + 130,\ntext: `QDH ${difficultyCoefficient.toFixed(0)}<br> ${avgPower.toFixed(0)} <br>${hasHR ? ` ${avgHR.toFixed(0)}` : ''} <br> ${Math.floor(climbTimeInSeconds / 60)}m${climbTimeInSeconds % 60}s`,\n            showarrow: false,\n            font: {\n                family: 'Arial',\n                size: 12,\n                color: 'white'\n            },\n            align: 'center',\n            bgcolor: bgColor,\n            bordercolor: difficultyCoefficient > 900 ? 'red' : null,\n            borderwidth: difficultyCoefficient > 900 ? 2 : 0,\n            opacity: 0.9\n        });\n    });\n    \n    // Aggiungi il profilo altimetrico di sfondo\n    traces.unshift({\n        x: distanceKm,\n        y: altitude,\n        text: altitude.map(alt => `${alt.toFixed(1)} m`),\n        hoverinfo: 'text',\n        fill: 'tozeroy',\n        type: 'scatter',\n        fillcolor: 'whitesmoke',\n        mode: 'none',\n        name: 'Hhe'\n    });\n    \n    // Crea il layout Plotly\n    const layout = {\n        title: 'Elevation profile',\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: false,\n        margin: {\n            t: 100,\n            l: 50,\n            r: 50,\n            b: 50\n        }\n    };\n    \n    // Crea il grafico\n    const chart = { data: traces, layout };\n    chart;\n    \n}",
        "name": "Smart Climb Segments"
      },
      "usage_count": 0,
      "index": 7,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-09T12:22:23.207+00:00",
      "from_athlete": {
        "id": "i85346",
        "name": "R2Tom",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/9effd3aa-d71f-4dc5-a60b-bd8a7af746e5",
        "city": "Altdorf",
        "state": "Bavaria",
        "country": "Germany",
        "timezone": "Europe/Berlin",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 610030
    },
    {
      "id": 273774,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "RHR + 7 day avg + 0.5 sigma band 42 day avg",
      "description": "This plot shows daily resting heart rate (bars) together with 7 day moving average (line). A band shows 0.5 sigma interval around the 42 day moving average.\n\nMotivation: recovery and (mis)adaptation can be tracked in long term resting heart rate (and HRV) trends. Day-to-day values are noisy, but a deviation of the 7 day average from the 42 day  0.5 standard deviation can be is a good indicator of something going on. \n\nE.g., if the 7 day line goes above the 42 day band, this might be a sign that someone needs to dial down the training a bit.",
      "image": null,
      "content": {
        "id": "0ll2n2fe",
        "name": "RHR + 7 day avg + 0.5 sigma band 42 day avg",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "RHR",
            "type": "bars",
            "field": "resting_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "resting_hr",
            "title": "Resting heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(214,39,40)",
            "filters": [],
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "RHR7",
            "type": "line",
            "field": "resting_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "resting_hr",
            "title": "Resting heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(214,39,40)",
            "aggArgs": {
              "days": 7
            },
            "filters": [],
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": null,
            "band": 0.5,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "RHR42",
            "type": "dot",
            "field": "resting_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Resting heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#D6272800",
            "aggArgs": {
              "days": 42
            },
            "filters": [],
            "i18nKey": "Resting HR",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Resting heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "month_avg",
            "min": null,
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "Monthly",
            "type": "line",
            "field": "resting_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Resting heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#00000070",
            "filters": [],
            "i18nKey": "Resting HR",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Resting heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "rgba(221,4,71,0.5)",
            "text": "Period",
            "type": "dot",
            "field": "period",
            "scale": "period",
            "stack": "",
            "title": "Period days",
            "extras": [],
            "filter": "period",
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "filters": [],
            "i18nKey": "Period",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Period days",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#000000FF",
            "text": "Fase",
            "type": "dot",
            "field": "Ciclo",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "Ciclo",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "tickFormat": "customInput",
            "customInput": {
              "id": 660383,
              "name": "Fasi ciclo",
              "type": "INPUT_FIELD",
              "image": null,
              "index": 5,
              "content": {
                "max": null,
                "min": null,
                "code": "Ciclo",
                "icon": "",
                "link": null,
                "name": "Fasi ciclo",
                "type": "select",
                "color": "#009E00",
                "gauge": true,
                "total": null,
                "units": null,
                "prefix": null,
                "script": null,
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 3,
                "options": [
                  {
                    "icon": null,
                    "text": " Mestruale",
                    "color": "#D62728",
                    "value": 1
                  },
                  {
                    "icon": null,
                    "text": "Follicolare",
                    "color": "#334CCC",
                    "value": 2
                  },
                  {
                    "icon": null,
                    "text": "Luteale",
                    "color": "#FFCB0E",
                    "value": 3
                  },
                  {
                    "icon": null,
                    "text": "Ovulatorio",
                    "color": "#009E00",
                    "value": 4
                  }
                ],
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "processes_fit_messages": false
              },
              "from_id": 660148,
              "updated": "2025-05-23T16:40:07.482+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": "fase mestruale",
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": "i180702",
                "bio": null,
                "sex": "F",
                "city": null,
                "name": "campanella",
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": "Europe/Rome",
                "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/f458629b-7f60-4554-bf9f-c5e5b88bc1a3"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Resting Hearth Rate",
        "height": 330,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "BPM",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 1,
      "index": 8,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-23T18:33:27.684+00:00",
      "from_athlete": {
        "id": "22604145",
        "name": "Andrii Magalich",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/53a37b82-437e-405d-8dcf-bee3e86b9cf9",
        "city": "",
        "state": "",
        "country": "",
        "timezone": "Europe/Amsterdam",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 29754
    },
    {
      "id": 276697,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "Calculated vs Actual power",
      "description": "Compare calculated power from VAM to your actual power, especially on climbing intervals.",
      "image": null,
      "content": {
        "id": null,
        "name": "Calculated vs Actual power",
        "plots": [
          {
            "id": 1,
            "text": "Calculated power",
            "color": "#0E7BF1",
            "extras": [],
            "legend": true,
            "stream": "Calculatedpower",
            "transform": "moving_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 30
            }
          },
          {
            "id": 2,
            "text": "Calculated power",
            "color": "#0E7BF1",
            "extras": [],
            "legend": false,
            "stream": "Calculatedpower",
            "transform": "work_interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "strokeWidth": 2,
            "transformArgs": null
          },
          {
            "id": 3,
            "text": "Power",
            "color": "#FF7F0EFF",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 30
            }
          },
          {
            "id": 4,
            "text": "Power",
            "color": "#FF7F0EFF",
            "extras": [],
            "legend": false,
            "stream": "watts",
            "transform": "work_interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "strokeWidth": 2,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 60,
        "yAxisMax": 500.0,
        "yAxisMin": 0.0,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 8,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-13T18:56:15.078+00:00",
      "from_athlete": {
        "id": "5916126",
        "name": "Kosio Varbenov",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/6e64b2bb-f5ec-41a5-a836-67cfedb0db4b",
        "city": "Graz",
        "state": "Steiermark",
        "country": "Austria",
        "timezone": "Europe/Vienna",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 182073
    },
    {
      "id": 365446,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HISTOGRAM",
      "visibility": "PRIVATE",
      "name": "Torque 5s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Torque 5s",
        "plots": [
          {
            "id": 1,
            "text": "Torque 5s",
            "type": "bars",
            "color": "#62E62DFF",
            "legend": false,
            "stream": "torque",
            "transform": "moving_avg",
            "bucketSize": 10,
            "areaOpacity": 0.75,
            "lineOpacity": 0.7,
            "trimPercent": 0.01,
            "transformArgs": {
              "secs": 5
            },
            "hideLastBucket": false,
            "hideFirstBucket": false
          }
        ],
        "width": 510,
        "height": 350
      },
      "usage_count": 0,
      "index": 8,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:16:07.667+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396107,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "%W' min",
      "description": "The lowest point in W' depletion in a % of the max.",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "PercentWmin",
        "icon": "arrow_downward",
        "link": null,
        "type": "numeric",
        "color": "#2CA02C",
        "gauge": true,
        "total": null,
        "units": "%",
        "inline": false,
        "prefix": null,
        "script": "(1-activity.icu_max_wbal_depletion/activity.icu_w_prime)",
        "suffix": "",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "AVERAGE",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".1%",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "%W' min"
      },
      "usage_count": 40,
      "index": 8,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T09:27:18.863+00:00",
      "from_athlete": {
        "id": "i65977",
        "name": "Jordi Sadurn",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/f14ebbba-f2f5-443a-b7a8-f053f5d0b171",
        "city": "Barcelona",
        "state": "Catalonia",
        "country": "Spain",
        "timezone": "Europe/Madrid",
        "sex": "M",
        "bio": "Soy Jordi, entrenador especializado en ciclismo. Convert mi pasin por la bici y la ciencia en mi trabajo: ayudar a ciclistas a rendir ms y disfrutar del proceso. Adems de entrenar, he competido en carretera, XCO, XCM y BMX, y tambin he participado en triatlones y carreras de trail, lo que me permite entender desde dentro las exigencias fsicas y mentales de los deportes de resistencia.\n\n\nEstudi Ciencias del Deporte en la Universidad de Barcelona y realic un Mster en Alto Rendimiento en Deportes Cclicos. Llevo ms de 5 aos entrenando ciclistas de todos los niveles, desde recreativos hasta lite, y mis deportistas han conseguido resultados destacados: podios en campeonatos nacionales cadete y junior, victorias internacionales en pruebas UCI C1 y C2 de XCO, y un triunfo absoluto en la Titan Desert categora M50.\n\n\nMi enfoque es riguroso, individualizado y basado en datos, pero siempre con un trato cercano y humano.",
        "website": "https://www.jscyclingtraining.com",
        "email": null
      },
      "from_id": 101648
    },
    {
      "id": 435213,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HEATMAP",
      "visibility": "PRIVATE",
      "name": "Balance / Power",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Balance / Power",
        "plots": [
          {
            "id": "x",
            "max": 60,
            "min": 40,
            "axis": null,
            "text": "Balance",
            "color": "#6633cc",
            "legend": false,
            "stream": "left_right_balance",
            "transform": "none",
            "bucketSize": 1,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": null,
            "hideLastBucket": false,
            "hideFirstBucket": false
          },
          {
            "id": "y",
            "max": null,
            "min": null,
            "axis": null,
            "text": "Power",
            "color": "#6633cc",
            "legend": false,
            "stream": "watts",
            "transform": "none",
            "bucketSize": 5,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": null,
            "hideLastBucket": false,
            "hideFirstBucket": true
          }
        ],
        "steps": null,
        "width": 510,
        "height": 350,
        "opacity": null,
        "colorScale": null,
        "contourPlot": true,
        "trimPercent": 0.05
      },
      "usage_count": 0,
      "index": 8,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:16:51.003+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 572796,
      "athlete_id": "i115436",
      "type": "ACTIVITY_STREAM",
      "visibility": "PRIVATE",
      "name": "Rear Gear 1-11",
      "description": null,
      "image": null,
      "content": {
        "pos": false,
        "code": "RearGear111",
        "link": null,
        "name": "Rear Gear 1-11",
        "type": "numeric",
        "color": "#0E7BF1",
        "units": "stride",
        "legend": null,
        "script": "{\n  let rear_gear, rear_gear_num, front_gear, front_gear_num;\n\n  function fixValue(value) {\n    value = Array.isArray(value) ? value[0] : value;\n    return value === 0 ? null : value;\n  }\n\n  const gearMap = {\n    11: 11, 12: 10, 13: 9, 14: 8, 16: 7, \n    18: 6, 20: 5, 22: 4, 25: 3, 28: 2, 32: 1\n  };\n\n  for (let m of icu.fit) {\n    switch (m.event?.valueName) {\n      case \"REAR_GEAR_CHANGE\":\n      case \"FRONT_GEAR_CHANGE\":\n        rear_gear      = fixValue(m.rear_gear?.value);\n        rear_gear_num  = fixValue(m.rear_gear_num?.value);\n        front_gear     = fixValue(m.front_gear?.value);\n        front_gear_num = fixValue(m.front_gear_num?.value);\n    }\n    let ts = m.timestamp;\n    if (ts) {\n      let pignoneIndex = rear_gear ? gearMap[rear_gear] ?? null : null;\n      data.setAt(ts.value, pignoneIndex);\n    }\n  }\n}",
        "convert": "",
        "no_nulls": true,
        "legend_pos": "topLeft",
        "domain_zero": false,
        "area_opacity": "0.05",
        "line_opacity": "0.7",
        "number_format": ".1f",
        "fit_record_field": null,
        "short_description": null,
        "processes_fit_messages": true
      },
      "usage_count": 34,
      "index": 8,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-02-24T15:19:19.136+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 679346,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "Climb Details",
      "description": "All credits to SergeNico. I only translated the French text to English! (And added a difficulty level on the lower side).\n\nThis code identifies and analyzes climbs within a cycling activity based on specific criteria such as minimum grade and distance. It calculates various metrics for each climb, including average grade, average power, heart rate, vertical ascent speed, and difficulty coefficient. The results are visualized on a plot with annotated data for each climb and a gradient-colored profile based on the difficulty level. The visualization helps assess performance across multiple climbs within the activity.\n\n\n\n",
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "600px",
        "script": "// Fonction pour scuriser les flux de donnes\nfunction getStreamData(streamName) {\n    const stream = icu.streams.get(streamName);\n    return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\n\n// Rcuprer les flux de donnes\nconst altitude = getStreamData(\"fixed_altitude\");\nconst distance = getStreamData(\"distance\"); // Flux distance en mtres\nconst grade = getStreamData(\"grade_smooth\");\nconst power = getStreamData(\"fixed_watts\"); // Flux puissance en watts\nconst heartrate = getStreamData(\"fixed_heartrate\"); // Flux frquence cardiaque en bpm\nconst time = getStreamData(\"time\"); // Flux de temps (en secondes)\n\nconst distanceKm = distance.map(d => d / 1000); // Conversion de la distance en kilomtres\n\n// Paramtres de la monte\nconst MIN_DISTANCE = 250; // Distance minimale en mtres\nconst MIN_GRADE = 2.9; // Pourcentage minimal de pente\nconst GAP_TIME_THRESHOLD = 30; // Seuil de 30 secondes pour fusionner les montes\nconst MIN_ELEVATION_GAIN = 10; // D+ minimal en mtres\n\n// Variables pour le graphique\nlet annotations = [];\nlet traces = [];\n\n// Identifier les montes\nlet climbs = [];\nlet currentClimb = { startIndex: null, endIndex: null, distance: 0, elevation: 0, startTime: null, endTime: null };\nfor (let i = 1; i < altitude.length; i++) {\n    const distDiff = distance[i] - distance[i - 1];\n    const altDiff = altitude[i] - altitude[i - 1];\n    const gradeValue = grade[i];\n\n    if (gradeValue >= MIN_GRADE) {\n        if (currentClimb.startIndex === null) {\n            currentClimb.startIndex = i - 1;\n            currentClimb.startTime = time[i - 1]; // Temps de dpart\n        }\n        currentClimb.endIndex = i;\n        currentClimb.distance += distDiff;\n        currentClimb.elevation += altDiff;\n        currentClimb.endTime = time[i]; // Temps de fin\n    } else if (currentClimb.startIndex !== null) {\n        climbs.push({ ...currentClimb });\n        currentClimb = { startIndex: null, endIndex: null, distance: 0, elevation: 0, startTime: null, endTime: null };\n    }\n}\n\n// Fusionner les montes proches\nfor (let i = 1; i < climbs.length; i++) {\n    if (climbs[i].startTime - climbs[i - 1].endTime <= GAP_TIME_THRESHOLD) {\n        climbs[i - 1].endIndex = climbs[i].endIndex;\n        climbs[i - 1].distance += climbs[i].distance;\n        climbs[i - 1].elevation += climbs[i].elevation;\n        climbs[i - 1].endTime = climbs[i].endTime;\n        climbs.splice(i, 1);\n        i--;\n    }\n}\n\n// Filtrer les montes qui respectent les critres aprs fusion\nclimbs = climbs.filter(climb => climb.distance >= MIN_DISTANCE && climb.elevation >= MIN_ELEVATION_GAIN);\n\n// Traiter les montes dtectes\nclimbs.forEach(climb => {\n    const climbGrades = grade.slice(climb.startIndex, climb.endIndex + 1);\n    const climbPowers = power.slice(climb.startIndex, climb.endIndex + 1);\n    const climbHRs = heartrate.slice(climb.startIndex, climb.endIndex + 1);\n\n    const avgGrade = climbGrades.reduce((a, b) => a + b, 0) / climbGrades.length;\n    const avgPower = climbPowers.reduce((a, b) => a + b, 0) / climbPowers.length;\n    const avgHR = climbHRs.reduce((a, b) => a + b, 0) / climbHRs.length;\n    const maxHR = Math.max(...climbHRs);\n    const maxgrade = Math.max(...climbGrades);\n\n    const climbTimeInSeconds = climb.endTime - climb.startTime;\n    const formattedTime = `${Math.floor(climbTimeInSeconds / 60)}min${climbTimeInSeconds % 60}s`;\n\n    const ascentSpeed = climb.elevation / (climbTimeInSeconds / 3600);\n    const avgHorizontalSpeed = (climb.distance / 1000) / (climbTimeInSeconds / 3600);\n\n    const difficultyCoefficient = Math.pow(avgGrade, 2) * (climb.distance / 1000);\n\n    if (difficultyCoefficient < 5) {\n        return;\n    }\n\n    let bgColor = \"silver\";\n    if (difficultyCoefficient > 9.6 && difficultyCoefficient < 25) bgColor = \"green\";\n    else if (difficultyCoefficient >= 25 && difficultyCoefficient < 75) bgColor = \"yellowgreen\";\n    else if (difficultyCoefficient >= 75 && difficultyCoefficient < 150) bgColor = \"orange\";\n    else if (difficultyCoefficient >= 150 && difficultyCoefficient < 300) bgColor = \"orangered\";\n    else if (difficultyCoefficient >= 300 && difficultyCoefficient < 600) bgColor = \"firebrick\";\n    else if (difficultyCoefficient >= 600 && difficultyCoefficient < 900) bgColor = \"indigo\";\n    else if (difficultyCoefficient >= 900) bgColor = \"black\";\n\n    traces.push({\n        x: distanceKm.slice(climb.startIndex, climb.endIndex + 1),\n        y: altitude.slice(climb.startIndex, climb.endIndex + 1),\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `Monte`,\n        hoverinfo: 'text',\n        text: climbGrades.map((_, i) =>\n            `D+: ${climb.elevation.toFixed(1)} m<br>\n            Length: ${(climb.distance / 1000).toFixed(1)} km<br>\n            % Avg: ${avgGrade.toFixed(1)}%<br>\n            % Max: ${maxgrade.toFixed(1)}%<br>\n            Vertical Speed: ${ascentSpeed.toFixed(1)} m/h<br>\n            Avg Speed: ${avgHorizontalSpeed.toFixed(1)} km/h<br>\n            Avg Power: ${avgPower.toFixed(0)} W<br>\n            Avg HR: ${avgHR.toFixed(0)} bpm<br>\n            Max HR: ${maxHR} bpm<br>\n            Climb time: ${formattedTime}`\n        )\n    });\n\n    annotations.push({\n        x: (distanceKm[climb.startIndex] + distanceKm[climb.endIndex]) / 2,\n        y: Math.max(...altitude) + 50,\n        text: `${Math.round(difficultyCoefficient)}`,\n        showarrow: false,\n        font: { family: 'Arial', size: 16, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        bordercolor: difficultyCoefficient > 900 ? 'red' : null,\n        borderwidth: difficultyCoefficient > 900 ? 2 : 0,\n        opacity: 0.9\n    });\n});\n\ntraces.unshift({ x: distanceKm, y: altitude, fill: 'tozeroy', type: 'scatter', fillcolor: 'whitesmoke', mode: 'none', name: 'Altitude' });\nlayout = { title: 'Climb details', xaxis: { title: 'Distance (km)' }, yaxis: { title: 'Altitude (m)' }, annotations: annotations, hovermode: 'x unified', showlegend: false };\nchart = { data: traces, layout };\nchart;",
        "name": "Climb Details"
      },
      "usage_count": 0,
      "index": 8,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-06-15T11:30:28.932+00:00",
      "from_athlete": {
        "id": "i10887",
        "name": "MedTechCD",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/de4ab215-e6ee-4e4a-a8b5-2fd03b3ef166",
        "city": "Mazenzele",
        "state": null,
        "country": "Belgium",
        "timezone": "Europe/Brussels",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 600918
    },
    {
      "id": 273776,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Sleep daily + 7 day avg",
      "description": null,
      "image": null,
      "content": {
        "id": "y3blc2xn",
        "name": "Sleep daily + 7 day avg",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#0E7BF180",
            "text": "Sleep",
            "type": "bars",
            "field": "sleep",
            "scale": "hours",
            "stack": "sleep",
            "title": "Sleep time",
            "extras": [],
            "filter": "hours",
            "radius": 3,
            "stroke": "#504861",
            "filters": [],
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": 0,
            "band": 0,
            "fill": "#00C9FFFF",
            "text": "Sleep7",
            "type": "line",
            "field": "sleep",
            "scale": "hours",
            "stack": "sleep",
            "title": "Sleep time",
            "extras": [],
            "filter": "hours",
            "radius": 3,
            "stroke": "#0E7BF1FF",
            "aggArgs": {
              "days": 7
            },
            "filters": [],
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": 0,
            "band": 1,
            "fill": "#0E7BF157",
            "text": "Sleep42",
            "type": "dot",
            "field": "sleep",
            "gauge": true,
            "scale": "hours",
            "stack": "",
            "title": "Sleep time",
            "extras": [],
            "filter": "hours",
            "radius": 3,
            "stroke": "#0E7BF100",
            "aggArgs": {
              "days": 42
            },
            "filters": [],
            "i18nKey": "Sleep",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Sleep time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "month_avg",
            "min": 0,
            "band": 0,
            "fill": "#50486180",
            "text": "Monthly",
            "type": "line",
            "field": "sleep",
            "gauge": true,
            "scale": "hours",
            "stack": "",
            "title": "Sleep time",
            "extras": [],
            "filter": "hours",
            "radius": 3,
            "stroke": "#00000070",
            "filters": [],
            "i18nKey": "Sleep",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Sleep time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "rgba(221,4,71,0.5)",
            "text": "Period",
            "type": "dot",
            "field": "period",
            "scale": "period",
            "stack": "",
            "title": "Period days",
            "extras": [],
            "filter": "period",
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "filters": [],
            "i18nKey": "Period",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Period days",
            "invertSubWellness": false
          }
        ],
        "title": "Sleep",
        "height": 330,
        "yAxisMax": null,
        "yAxisMin": 4.0,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Hours",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 1,
      "index": 9,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-09-02T18:19:44.659+00:00",
      "from_athlete": {
        "id": "22604145",
        "name": "Andrii Magalich",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/53a37b82-437e-405d-8dcf-bee3e86b9cf9",
        "city": "",
        "state": "",
        "country": "",
        "timezone": "Europe/Amsterdam",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 29752
    },
    {
      "id": 276725,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PUBLIC",
      "name": "30s PWR thicc",
      "description": "THICC 30 seconds power, with W/Kg (custom stream needed)",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/8d7bc0a6-41f6-4e1f-b1ab-2281c8b23aa9",
      "content": {
        "id": null,
        "name": "30s PWR thicc",
        "plots": [
          {
            "id": 5,
            "axis": null,
            "text": "30s Power",
            "color": "#6633cc",
            "extras": [],
            "legend": true,
            "stream": "watts_30s",
            "transform": "none",
            "areaOpacity": 1,
            "lineOpacity": 0.7,
            "strokeWidth": 1,
            "transformArgs": {
              "secs": 1
            }
          },
          {
            "id": 6,
            "axis": null,
            "text": "30s W/Kg",
            "color": "#1F77B4",
            "extras": [],
            "legend": true,
            "stream": "WKg",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": {
              "secs": 30
            }
          }
        ],
        "title": null,
        "height": 60,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 8,
      "index": 9,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-02-28T08:08:51.924+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 367557,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HISTOGRAM",
      "visibility": "FOLLOWERS",
      "name": "Power 5s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Power 5s",
        "plots": [
          {
            "id": 1,
            "text": "Power 5s",
            "type": "bars",
            "color": "#1F77B4FF",
            "legend": false,
            "stream": "raw_watts",
            "transform": "moving_avg",
            "bucketSize": 8,
            "areaOpacity": 0.75,
            "lineOpacity": 0.7,
            "trimPercent": 0.2,
            "transformArgs": {
              "secs": 5
            },
            "hideFirstBucket": true
          }
        ],
        "width": 540,
        "height": 350
      },
      "usage_count": 1,
      "index": 9,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-08-21T14:52:12.964+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396108,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "% Above CP",
      "description": "This field calculates the time above FTP as a percentage",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "AboveFTP",
        "icon": "arrow_upward",
        "link": null,
        "type": "numeric",
        "color": "#6633CC",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": null,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\nftp = activity.icu_ftp\nconsole.log(\"ftp\", ftp)\ntime_below = 0\ntotal_time = watts.length\nfor (let i = 0; i < watts.length; i++) {\n   w = watts[i]\n  if (w >= ftp) time_below += 1\n}\n\ntime_below/total_time",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 0.3,
        "options": null,
        "aggregate": "AVERAGE",
        "pace_units": null,
        "number_format": ".1%",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "% Above CP"
      },
      "usage_count": 40,
      "index": 9,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-08-11T11:26:51.460+00:00",
      "from_athlete": {
        "id": "169405",
        "name": "Benjamin Hendler",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/21d0156e-c630-4dec-8427-a2cc37af7bff",
        "city": "Stockholm",
        "state": "",
        "country": "Sverige",
        "timezone": "Europe/Stockholm",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 84476
    },
    {
      "id": 435220,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HEATMAP",
      "visibility": "PRIVATE",
      "name": "Power / HR  3/40s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Power / HR  3/40s",
        "plots": [
          {
            "id": "y",
            "max": null,
            "min": null,
            "axis": null,
            "text": "HR",
            "color": "#dd0447",
            "legend": false,
            "stream": "raw_heartrate",
            "transform": "moving_avg",
            "bucketSize": 1,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 3
            },
            "hideLastBucket": false,
            "hideFirstBucket": true
          },
          {
            "id": "x",
            "max": null,
            "min": null,
            "axis": null,
            "text": "Power",
            "color": "#6633cc",
            "legend": false,
            "stream": "watts",
            "transform": "moving_avg",
            "bucketSize": 3,
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 40
            },
            "hideLastBucket": false,
            "hideFirstBucket": true
          }
        ],
        "steps": null,
        "width": 510,
        "height": 350,
        "opacity": null,
        "colorScale": null,
        "contourPlot": true,
        "trimPercent": 0.45
      },
      "usage_count": 0,
      "index": 9,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:15:19.829+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 291017,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PUBLIC",
      "name": "30s HR Zones",
      "description": null,
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/17b5818c-e7dd-4cd6-bf56-63b474cae9bb",
      "content": {
        "id": null,
        "name": "30s HR Zones",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "30s HR",
            "color": "#dd0447ff",
            "extras": [
              {
                "id": 1,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "Label",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.3
              }
            ],
            "legend": false,
            "stream": "heartrate_exp",
            "transform": "moving_avg",
            "areaOpacity": 1,
            "lineOpacity": 0.7,
            "strokeWidth": 1,
            "transformArgs": {
              "secs": 30
            }
          },
          {
            "id": 2,
            "axis": null,
            "text": "Core Temp",
            "color": "#666666ff",
            "extras": [],
            "legend": false,
            "stream": "core_temperature",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "strokeWidth": 1.5,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 60,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 58,
      "index": 10,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-11-06T19:52:45.325+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 347489,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Respiration + 7 day avg",
      "description": null,
      "image": null,
      "content": {
        "id": "mxokla4w",
        "name": "Respiration + 7 day avg",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#009E0066",
            "text": "FR",
            "type": "bars",
            "field": "respiration",
            "gauge": true,
            "scale": "/min",
            "stack": "",
            "title": "Respiration",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(214,39,40)",
            "filters": [],
            "i18nKey": "Respiration",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Respiration",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": null,
            "band": 0,
            "fill": "#009E0066",
            "text": "FR7",
            "type": "line",
            "field": "respiration",
            "gauge": true,
            "scale": "/min",
            "stack": "",
            "title": "Respiration",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#009E00FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Respiration",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Respiration",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": null,
            "band": 1,
            "fill": "#2CA02C66",
            "text": "FR42",
            "type": "dot",
            "field": "respiration",
            "gauge": true,
            "scale": "/min",
            "stack": "",
            "title": "Respiration",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#009E0000",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Respiration",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Respiration",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "month_avg",
            "min": null,
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "Monthly",
            "type": "line",
            "field": "respiration",
            "gauge": true,
            "scale": "/min",
            "stack": "",
            "title": "Respiration",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#00000070",
            "filters": [],
            "i18nKey": "Respiration",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Respiration",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Respiratory Rate",
        "height": 330,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "BPM",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 1,
      "index": 10,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T10:11:11.497+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 367559,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HISTOGRAM",
      "visibility": "FOLLOWERS",
      "name": "HR 5s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "HR 5s",
        "plots": [
          {
            "id": 1,
            "text": "HR 5s",
            "type": "bars",
            "color": "#dd0447",
            "legend": false,
            "stream": "raw_heartrate",
            "transform": "moving_avg",
            "bucketSize": 2,
            "areaOpacity": 0.7,
            "lineOpacity": 0.7,
            "trimPercent": 1,
            "transformArgs": {
              "secs": 5
            },
            "hideFirstBucket": false
          }
        ],
        "width": 540,
        "height": 350
      },
      "usage_count": 1,
      "index": 10,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-08-21T14:52:23.016+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396109,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "Avg Above CP",
      "description": "This field calculates the average power above FTP. This metric is very good to understand the requirement of a unstructured workout (or race) as it shows the work that is needed during hard efforts.",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "AveragePowerAboveFTP",
        "icon": "arrow_forward",
        "link": null,
        "type": "numeric",
        "color": "#6633CC",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": null,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\nftp = activity.icu_ftp\nconsole.log(\"ftp\", ftp)\npower = 0\ncount = 0\nfor (let i = 0; i < watts.length; i++) {\n  w = watts[i]\n  if (w >= ftp) power += w\n  if (w >= ftp) count += 1\n}\n\npower/count",
        "suffix": " w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "AVERAGE",
        "pace_units": null,
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Avg Above CP"
      },
      "usage_count": 40,
      "index": 10,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-08-11T11:26:41.390+00:00",
      "from_athlete": {
        "id": "169405",
        "name": "Benjamin Hendler",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/21d0156e-c630-4dec-8427-a2cc37af7bff",
        "city": "Stockholm",
        "state": "",
        "country": "Sverige",
        "timezone": "Europe/Stockholm",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 84451
    },
    {
      "id": 273042,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "HRV + RPE",
      "description": null,
      "image": null,
      "content": {
        "id": "new2rowi",
        "name": "HRV + RPE",
        "plots": [
          {
            "id": 2,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "Resting HR",
            "type": "line",
            "field": "resting_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Resting heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(214,39,40)",
            "filters": [],
            "i18nKey": "Resting HR",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Resting heartrate",
            "showOnCalendar": false,
            "calendarOptions": {
              "day1": true,
              "day2": true,
              "day3": true,
              "day4": true,
              "day5": true,
              "day6": true,
              "day7": true,
              "label": "Resting HR ",
              "units": " bpm",
              "weekPopupDay": 7,
              "weekSummaryDay": 7
            },
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "HRV rMSSD",
            "type": "line",
            "field": "hrv",
            "gauge": true,
            "scale": "ms",
            "stack": "",
            "title": "Heartrate variability",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009E00FF",
            "filters": [],
            "i18nKey": "HRV rMSSD",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Heartrate variability",
            "showOnCalendar": false,
            "calendarOptions": {
              "day1": true,
              "day2": true,
              "day3": true,
              "day4": true,
              "day5": true,
              "day6": true,
              "day7": true,
              "label": "Readiness ",
              "units": " readiness",
              "weekPopupDay": 7,
              "weekSummaryDay": 7
            },
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "rgba(102,51,204,0.3)",
            "text": "RPE",
            "type": "dot",
            "field": "rpe",
            "gauge": true,
            "scale": "rpe",
            "stack": "",
            "title": "Rate of Perceived Exertion",
            "extras": [],
            "radius": 3,
            "stroke": "#DD04A7FF",
            "filters": [],
            "i18nKey": "RPE",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Rate of Perceived Exertion",
            "showOnCalendar": false,
            "calendarOptions": {
              "day1": true,
              "day2": true,
              "day3": true,
              "day4": true,
              "day5": true,
              "day6": true,
              "day7": true,
              "label": "RPE ",
              "units": " rpe",
              "weekPopupDay": 7,
              "weekSummaryDay": 7
            },
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 220,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 11,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-02-21T15:19:33.645+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 376945,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PUBLIC",
      "name": "Speed details",
      "description": "Instant + 30s average speed chart with avg for activity, work interval and zoom selection. Script with gears",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/2d81b91b-1bac-4f7c-b1d0-cf1302f0bb9c",
      "content": {
        "id": null,
        "name": "Speed details",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "Speed",
            "color": "#4BCCFFFF",
            "extras": [],
            "legend": true,
            "stream": "velocity_smooth",
            "transform": "none",
            "areaOpacity": 0.9,
            "lineOpacity": 0.5,
            "transformArgs": {
              "secs": 60
            }
          },
          {
            "id": 2,
            "axis": null,
            "text": "30s",
            "color": "#000000FF",
            "extras": [],
            "legend": true,
            "stream": "velocity_smooth",
            "transform": "moving_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 1,
            "strokeWidth": 1.5,
            "transformArgs": {
              "secs": 30
            }
          },
          {
            "id": 3,
            "axis": null,
            "text": "Avg",
            "color": "#53FF64FF",
            "extras": [],
            "legend": true,
            "stream": "velocity_smooth",
            "transform": "activity_avg",
            "areaOpacity": 0,
            "lineOpacity": 5,
            "strokeWidth": 1.2,
            "transformArgs": null
          },
          {
            "id": 4,
            "axis": null,
            "text": "Avg WRK",
            "color": "#FF00FFFF",
            "extras": [],
            "legend": true,
            "stream": "velocity_smooth",
            "transform": "work_interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 5,
            "strokeWidth": 1.2,
            "transformArgs": null
          },
          {
            "id": 5,
            "axis": null,
            "text": "Avg ZOOM",
            "color": "#9500FFFF",
            "extras": [],
            "legend": true,
            "stream": "velocity_smooth",
            "transform": "zoom_avg",
            "areaOpacity": 0,
            "lineOpacity": 5,
            "strokeWidth": 1.15,
            "transformArgs": null
          },
          {
            "id": 7,
            "axis": null,
            "text": "Front Gear",
            "color": "#666666FF",
            "extras": [],
            "legend": true,
            "stream": "FrontGear",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 0.8,
            "transformArgs": null
          },
          {
            "id": 8,
            "axis": null,
            "text": "Rear Gear",
            "color": "#666666FF",
            "extras": [],
            "legend": true,
            "stream": "RearGear111",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 0.8,
            "transformArgs": null
          }
        ],
        "title": "Speed Chart",
        "height": 90,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 178,
      "index": 11,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-02-24T15:20:02.639+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396110,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "kJ/h",
      "description": "Total work per moving_time",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "WorkHour",
        "icon": "battery_5_bar",
        "link": null,
        "type": "numeric",
        "color": "#037E65",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "(activity.icu_joules/1000)/(activity. moving_time/3600)",
        "suffix": " kJ/h",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "AVERAGE",
        "pace_units": null,
        "number_format": ".1f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "kJ/h"
      },
      "usage_count": 41,
      "index": 11,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-17T14:09:41.445+00:00",
      "from_athlete": {
        "id": "i62859",
        "name": "OSCAR MARTINEZ",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c295a232-660c-4a1c-abdb-a7ff5be4aaac",
        "city": "Paterna",
        "state": "Valencia",
        "country": "Spain",
        "timezone": "Europe/Madrid",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 127973
    },
    {
      "id": 402935,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HISTOGRAM",
      "visibility": "FOLLOWERS",
      "name": "Gradient 3s",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Gradient 3s",
        "plots": [
          {
            "id": 1,
            "max": null,
            "min": null,
            "text": "Gradient",
            "type": "bars",
            "color": "#34ace4",
            "scale": "watts",
            "extras": [],
            "legend": false,
            "stream": "grade_smooth",
            "transform": "moving_avg",
            "bucketSize": 0.5,
            "areaOpacity": 0.7,
            "lineOpacity": 0.7,
            "trimPercent": 0.5,
            "transformArgs": {
              "secs": 3
            },
            "hideLastBucket": false,
            "hideFirstBucket": false
          }
        ],
        "width": 510,
        "height": 350
      },
      "usage_count": 0,
      "index": 11,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:16:05.104+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 681239,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "PIAN HC",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "400px",
        "script": "function getBestAverageOverNSeconds(data, n, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let bestAvg = 0;\n    for (let i = 0; i <= data.length - windowSize; i++) {\n        const window = data.slice(i, i + windowSize);\n        const avg = window.reduce((a, b) => a + b, 0) / window.length;\n        if (avg > bestAvg) bestAvg = avg;\n    }\n    return bestAvg;\n}\n\n{\n   // Variabili di configurazione\n    const SECTION_LENGTH = 25;\n    const MIN_SEGMENTS = 40;\n    const MIN_GRADE = 5;\n    const MAX_GRADE_END = 2;\n    const MAX_GAP_SEGMENTS = 20;\n    const MIN_DIFFICULTY = 25;\n    const MAX_FLAT_SEGMENTS_IN_CLIMB = 6;\n\n\n    // Funzione per recuperare i dati dei flussi\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n    \n    // Recupero dei flussi dati\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\"); // Flusso distanza in metri\n    const distanceKm = distance.map(d => d / 1000); // Conversione distanza in chilometri\n    const power = getStreamData(\"fixed_watts\"); // Flusso potenza in watt\n    const heartrate = getStreamData(\"fixed_heartrate\"); // Flusso frequenza cardiaca in bpm\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\"); // Flusso tempo (in secondi)\n    \n    // Correggi i valori iniziali del profilo altimetrico\n    const firstNonZeroAltitude = altitude.find(value => value !== 0);\n    if (firstNonZeroAltitude !== undefined) {\n        for (let i = 0; i < altitude.length; i++) {\n            if (altitude[i] === 0) {\n                altitude[i] = firstNonZeroAltitude;\n            } else {\n                break;\n            }\n        }\n    }\n    \n     \n    let sections = [];\n    let currentStartIndex = 0;\n    \n    // Suddivisione in sezioni\n    for (let i = 1; i < distance.length; i++) {\n        const distDiff = distance[i] - distance[currentStartIndex];\n        if (distDiff >= SECTION_LENGTH || i === distance.length - 1) {\n            const altDiff = altitude[i] - altitude[currentStartIndex];\n            const sectionGrade = (altDiff / distDiff) * 100;\n    \n            sections.push({\n                   sectionIndex: sections.length,\n                startIndex: currentStartIndex,\n                endIndex: i,\n                distance: distDiff,\n                elevation: altDiff,\n                grade: sectionGrade\n            });\n    \n            currentStartIndex = i;\n        }\n    }\n    \n    // Identificazione delle salite in base ai criteri\n    let climbs = [];\n    let currentClimb = { startSegment: null, endSegment: null };\n    let flatSegmentCount = 0;\n\n    sections.forEach((section, index) => {\n        if (currentClimb.startSegment === null && section.grade >= MIN_GRADE) {\n            currentClimb.startSegment = section.sectionIndex;\n            flatSegmentCount = 0;\n        } else if (currentClimb.startSegment !== null) {\n            if (section.grade >= MIN_GRADE) {\n                flatSegmentCount = 0;\n            } else if (section.grade < MAX_GRADE_END) {\n                flatSegmentCount++;\n                if (flatSegmentCount > MAX_FLAT_SEGMENTS_IN_CLIMB || index === sections.length - 1) {\n                    currentClimb.endSegment = section.sectionIndex - flatSegmentCount;\n                    if (currentClimb.endSegment - currentClimb.startSegment >= MIN_SEGMENTS) {\n                        climbs.push({ ...currentClimb });\n                    }\n                    currentClimb = { startSegment: null, endSegment: null };\n                    flatSegmentCount = 0;\n                }\n            }\n        }\n    });\n      \n    // Unisci salite e gap come parte della salita\n    for (let i = 1; i < climbs.length; i++) {\n        const prevClimb = climbs[i - 1];\n        const currentClimb = climbs[i];\n        const gapSegments = currentClimb.startSegment - prevClimb.endSegment;\n    \n        if (gapSegments <= MAX_GAP_SEGMENTS) {\n            // Unisci gap e salite\n            prevClimb.endSegment = currentClimb.endSegment;\n            climbs.splice(i, 1);\n            i--; // Aggiorna l'indice perch una salita  stata rimossa\n        }\n    }\n    \n    // Visualizzazione delle salite identificate\n    let annotations = [];\n    let traces = [];\n    let climbNo = 0;\n    //climbs.forEach((climb, climbNo) => {\n    climbs.forEach(climb => {\n        const startIndex = sections[climb.startSegment].startIndex;\n        const endIndex = sections[climb.endSegment].endIndex;\n    const climbSections = sections.slice(climb.startSegment, climb.endSegment);\n    // Calcolo dati salita: distanza e dislivello come differenza tra quota finale e iniziale\n    const dist = distance[endIndex] - distance[startIndex];\n    const elevationGain = altitude[endIndex] - altitude[startIndex];\n    const avgGrade = elevationGain / dist * 100;\n        const difficultyCoefficient = Math.pow(avgGrade, 2) * (dist / 1000);\n\n        // Filtra le salite con difficolt inferiore a 5\n        if (difficultyCoefficient < MIN_DIFFICULTY) {\n            return; // Ignora questa salita\n        }\n\n        climbNo++; \n    const climbPowers = power.slice(startIndex, endIndex);\n    // Calcolo potenza media prima e seconda met salita e rapporto\n    const half = Math.floor(climbPowers.length / 2);\n    const rat_1 = half > 0 ? climbPowers.slice(0, half).reduce((a, b) => a + b, 0) / half : 0;\n    const rat_2 = (climbPowers.length - half) > 0 ? climbPowers.slice(half).reduce((a, b) => a + b, 0) / (climbPowers.length - half) : 0;\n    const ratio = rat_1 > 0 ? rat_2 / rat_1 : 0;\n\n    // climbPowers gi dichiarato sopra\n        const climbHRs = heartrate.slice(startIndex, endIndex);\n        const climbCadence = getStreamData(\"cadence\").slice(startIndex, endIndex);\n        const avgPower = climbPowers.reduce((a, b) => a + b, 0) / climbPowers.length;\n        const best5sWatts = getBestAverageOverNSeconds(climbPowers, 5);\n    const hasHR = climbHRs.some(hr => hr > 0);\n    const avgHR = hasHR ? climbHRs.reduce((a, b) => a + b, 0) / climbHRs.length : null;\n    const maxHR = hasHR ? Math.max(...climbHRs) : null;\n        const avgCadence = climbCadence.length ? climbCadence.reduce((a, b) => a + b, 0) / climbCadence.length : 0;\n        const climbTimeInSeconds = time[endIndex] - time[startIndex];\n        function formatSecondsToHHMMSS(seconds) {\n            const sec = Math.floor(seconds % 60);\n            const min = Math.floor((seconds / 60) % 60);\n            const hr = Math.floor(seconds / 3600);\n            return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n        }\n        const formattedTime = `${Math.floor(climbTimeInSeconds / 60)}m${climbTimeInSeconds % 60}s`;\n        const formattedTimeHHMMSS = formatSecondsToHHMMSS(climbTimeInSeconds);\n        const ascentSpeed = elevationGain / (climbTimeInSeconds / 3600);\n        const avgHorizontalSpeed = (dist / 1000) / (climbTimeInSeconds / 3600);\n        const maxGrade = Math.max(...grade.slice(startIndex, endIndex));\n        const weight = icu.activity.icu_weight;\n        const avgPowerPerKg = weight ? avgPower / weight : 0;\n        const best5sPerKg = weight ? best5sWatts / weight : 0;\n        const gradientFactor = (2 + avgGrade / 10) * 100;\n        const TEORICWKG = ascentSpeed / gradientFactor;\n        const TEORICVAM = avgPowerPerKg * gradientFactor;\n        const vamDiff = ascentSpeed - TEORICVAM;\n        let vamArrow = '';\n        if (vamDiff > 10) {\n            vamArrow = ` +${vamDiff.toFixed(0)} m/h`;\n        } else if (vamDiff < -10) {\n            vamArrow = ` ${vamDiff.toFixed(0)} m/h`;\n        } else {\n            vamArrow = `  ${vamDiff.toFixed(0)} m/h`;\n        }\n\n        // Calcolo percentuale differenza tra TEORICWKG e avgPowerPerKg\n        let teoricWkgDiffPerc = '';\n        if (TEORICWKG && avgPowerPerKg) {\n            teoricWkgDiffPerc = ((avgPowerPerKg - TEORICWKG) / avgPowerPerKg * 100).toFixed(1) + '%';\n        }\n        // Calcolo kJ accumulati fino all'inizio della salita\n        let kJ_accum = 0, kJ_accum_overCP = 0;\n        const FTP = icu.activity.icu_ftp;\n        for (let i = 1; i < startIndex; i++) {\n            const dt = time[i] - time[i - 1];\n            kJ_accum += power[i] * dt / 1000;\n            if (power[i] >= FTP) kJ_accum_overCP += power[i] * dt / 1000;\n        }\n        const hours = time[startIndex] / 3600;\n        const kJ_per_h_kg = (weight && hours > 0) ? kJ_accum / hours / weight : 0;\n        const kJ_overCP_per_h_kg = (weight && hours > 0) ? kJ_accum_overCP / hours / weight : 0;\n        \n        // Determina il colore secondo la scala\n        let bgColor = \"grey\";\n        if (difficultyCoefficient >= 25 && difficultyCoefficient < 75) bgColor = \"yellowgreen\";\n        else if (difficultyCoefficient >= 75 && difficultyCoefficient < 150) bgColor = \"orange\";\n        else if (difficultyCoefficient >= 150 && difficultyCoefficient < 300) bgColor = \"darkorange\";\n        else if (difficultyCoefficient >= 300 && difficultyCoefficient < 600) bgColor = \"orangered\";\n        else if (difficultyCoefficient >= 600 && difficultyCoefficient < 900) bgColor = \"firebrick\";\n        else if (difficultyCoefficient >= 900 && difficultyCoefficient < 1200) bgColor = \"maroon\";\n        else if(difficultyCoefficient >= 1200) bgColor = \"black\";\n        \n        traces.push({\n            x: distanceKm.slice(startIndex, endIndex),\n            y: altitude.slice(startIndex, endIndex),\n            type: 'scatter',\n            mode: 'lines',\n            line: { color: bgColor, width: 2 },\n            name: `Anstieg ${climbNo}`,\n            hoverinfo: 'text',\n            text: `Climb ${climbNo}<br>\n ${(dist / 1000).toFixed(2)} km (${elevationGain.toFixed(0)} hm)<br>\n  ${avgGrade.toFixed(1)}% | max. ${maxGrade.toFixed(1)}%<br>\n ${avgPower.toFixed(0)} W | 5${best5sWatts.toFixed(0)}W   ${avgCadence.toFixed(0)} rpm<br>\n ${avgPowerPerKg.toFixed(2)} W/kg | 5 ${best5sPerKg.toFixed(2)} W/kg<br>\n ${rat_1.toFixed(0)} W | ${rat_2.toFixed(0)} W | ${ratio.toFixed(2)}<br>\n${hasHR ? `  ${avgHR.toFixed(0)} bpm | max. ${maxHR} bpm<br>` : ''}\n ${formattedTimeHHMMSS} |  ${avgHorizontalSpeed.toFixed(1)} km/h<br>\n ${ascentSpeed.toFixed(0)} m/h${vamArrow} | ${(avgPowerPerKg - TEORICWKG).toFixed(2)} W/kg<br>\n ${TEORICWKG.toFixed(2)} W/kg | ${TEORICVAM.toFixed(0)} VAM | ${teoricWkgDiffPerc}<br>\n ${formatSecondsToHHMMSS(time[startIndex])}<br>\n ${Math.round(kJ_accum)} kJ | ${Math.round(kJ_accum_overCP)} kJ > CP<br>\n ${kJ_per_h_kg.toFixed(1)} kJ/h/kg | ${kJ_overCP_per_h_kg.toFixed(1)} kJ/h/kg > CP`\n        });\n\n        // Annotazione permanente: coefficiente di difficolt (scala colori)\n        annotations.push({\n            x: (distanceKm[startIndex] + distanceKm[endIndex]) / 2,\n            y: Math.max(...altitude) + 130,\ntext: `QDH ${difficultyCoefficient.toFixed(0)}<br> ${avgPower.toFixed(0)} <br> ${avgHR.toFixed(0)} <br> ${Math.floor(climbTimeInSeconds / 60)}m${climbTimeInSeconds % 60}s`,\n            showarrow: false,\n            font: {\n                family: 'Arial',\n                size: 12,\n                color: 'white'\n            },\n            align: 'center',\n            bgcolor: bgColor,\n            bordercolor: difficultyCoefficient > 900 ? 'red' : null,\n            borderwidth: difficultyCoefficient > 900 ? 2 : 0,\n            opacity: 0.9\n        });\n    });\n    \n    // Aggiungi il profilo altimetrico di sfondo\n    traces.unshift({\n        x: distanceKm,\n        y: altitude,\n        text: altitude.map(alt => `${alt.toFixed(1)} m`),\n        hoverinfo: 'text',\n        fill: 'tozeroy',\n        type: 'scatter',\n        fillcolor: 'whitesmoke',\n        mode: 'none',\n        name: 'Hhe'\n    });\n    \n    // Crea il layout Plotly\n    const layout = {\n        title: 'Elevation profile',\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: false,\n        margin: {\n            t: 100,\n            l: 50,\n            r: 50,\n            b: 50\n        }\n    };\n    \n    // Crea il grafico\n    const chart = { data: traces, layout };\n    chart;\n    \n}",
        "name": "PIAN HC"
      },
      "usage_count": 0,
      "index": 11,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-09T12:22:50.285+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396125,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PUBLIC",
      "name": "kJ/h/kg",
      "description": "Kj/hour/kg",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "WorkHourKg",
        "icon": "balance",
        "link": null,
        "type": "numeric",
        "color": "#037E65",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "(activity.icu_joules/1000)/(activity. moving_time/3600)/(activity.icu_weight)",
        "suffix": " kJ/h/kg",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "AVERAGE",
        "pace_units": null,
        "number_format": ".1f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "kJ/h/kg"
      },
      "usage_count": 89,
      "index": 12,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-17T14:09:35.738+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 417308,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PUBLIC",
      "name": "2m power",
      "description": "zone coloured like 30s, log and avg, with W/Kg (custom stream needed)",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/4d76b4b4-7ed7-4c5e-b1a8-d6bb033d9c2e",
      "content": {
        "id": null,
        "name": "2m power",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "2m Power",
            "color": "#6633cc",
            "extras": [],
            "legend": false,
            "stream": "watts_30s",
            "transform": "moving_avg",
            "areaOpacity": 1,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 120
            }
          },
          {
            "id": 2,
            "axis": null,
            "text": "2m Power",
            "color": "#6633cc",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 0.5,
            "transformArgs": {
              "secs": 120
            }
          },
          {
            "id": 3,
            "axis": null,
            "text": "2m W/Kg",
            "color": "#1F77B4",
            "extras": [],
            "legend": true,
            "stream": "WKg",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": {
              "secs": 120
            }
          }
        ],
        "title": null,
        "height": 60,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 42,
      "index": 12,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-01T20:37:58.889+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 435200,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HISTOGRAM",
      "visibility": "PRIVATE",
      "name": "Cadence",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Cadence",
        "plots": [
          {
            "id": 1,
            "max": null,
            "min": null,
            "axis": null,
            "text": "Cadence",
            "type": "bars",
            "color": "#ff00ff",
            "extras": [],
            "legend": false,
            "stream": "cadence",
            "transform": "none",
            "bucketSize": 3,
            "areaOpacity": 0.7,
            "lineOpacity": 0.7,
            "trimPercent": null,
            "transformArgs": null,
            "hideFirstBucket": false
          }
        ],
        "width": 510,
        "height": 350
      },
      "usage_count": 0,
      "index": 12,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:17:21.147+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 682991,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "Punch",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "400px",
        "script": "// =====================\n// CONFIGURAZIONE INIZIALE\n// Modifica qui per cambiare facilmente i parametri principali\nconst CONFIG = {\n    SECTION_LENGTH: 25, // lunghezza sezione in metri\n    MIN_SEGMENTS: 2,    // numero minimo di segmenti per una salita valida\n    MIN_GRADE: 4,       // pendenza minima per considerare salita (%)\n    MAX_GRADE_END: 4,   // pendenza massima per considerare la fine salita (%)\n    MAX_GAP_SEGMENTS: 2, // massimo gap tra due salite per unirle\n    MIN_DIFFICULTY: 1,   // coefficiente minimo di difficolt per mostrare salita\n    MAX_FLAT_SEGMENTS_IN_CLIMB: 1, // max segmenti consecutivi \"troppo piatti\" accettabili\n    // Colori per zona potenza media salita\n    COLORS: [\n        { min: 151, color: \"#DC143C\" },\n        { min: 121, color: \"#FF4500\" },\n        { min: 106, color: \"#FFA500\" },\n        { min: 91, color: \"#FFD700\" },\n        { min: 76, color: \"#32CD32\" },\n        { min: 55, color: \"#90EE90\" },\n        { min: 0, color: \"#87CEFA\" }\n    ]\n};\n// =====================\n\nfunction getBestAverageOverNSeconds(data, n, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let bestAvg = 0;\n    for (let i = 0; i <= data.length - windowSize; i++) {\n        const window = data.slice(i, i + windowSize);\n        const avg = window.reduce((a, b) => a + b, 0) / window.length;\n        if (avg > bestAvg) bestAvg = avg;\n    }\n    return bestAvg;\n}\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n\n    const firstNonZeroAltitude = altitude.find(value => value !== 0);\n    if (firstNonZeroAltitude !== undefined) {\n        for (let i = 0; i < altitude.length; i++) {\n            if (altitude[i] === 0) {\n                altitude[i] = firstNonZeroAltitude;\n            } else {\n                break;\n            }\n        }\n    }\n\n    let sections = [];\n    let currentStartIndex = 0;\n\n    for (let i = 1; i < distance.length; i++) {\n        const distDiff = distance[i] - distance[currentStartIndex];\n        if (distDiff >= CONFIG.SECTION_LENGTH || i === distance.length - 1) {\n            const altDiff = altitude[i] - altitude[currentStartIndex];\n            const sectionGrade = (altDiff / distDiff) * 100;\n            sections.push({\n                sectionIndex: sections.length,\n                startIndex: currentStartIndex,\n                endIndex: i,\n                distance: distDiff,\n                elevation: altDiff,\n                grade: sectionGrade\n            });\n            currentStartIndex = i;\n        }\n    }\n\n    let climbs = [];\n    let currentClimb = { startSegment: null, endSegment: null };\n    let flatSegmentCount = 0;\n\n    sections.forEach((section, index) => {\n        if (currentClimb.startSegment === null && section.grade >= CONFIG.MIN_GRADE) {\n            currentClimb.startSegment = section.sectionIndex;\n            flatSegmentCount = 0;\n        } else if (currentClimb.startSegment !== null) {\n            if (section.grade >= CONFIG.MIN_GRADE) {\n                flatSegmentCount = 0;\n            } else if (section.grade < CONFIG.MAX_GRADE_END) {\n                flatSegmentCount++;\n                if (flatSegmentCount > CONFIG.MAX_FLAT_SEGMENTS_IN_CLIMB || index === sections.length - 1) {\n                    currentClimb.endSegment = section.sectionIndex - flatSegmentCount;\n                    if (currentClimb.endSegment - currentClimb.startSegment >= CONFIG.MIN_SEGMENTS) {\n                        climbs.push({ ...currentClimb });\n                    }\n                    currentClimb = { startSegment: null, endSegment: null };\n                    flatSegmentCount = 0;\n                }\n            }\n        }\n    });\n\n    for (let i = 1; i < climbs.length; i++) {\n        const prevClimb = climbs[i - 1];\n        const currentClimb = climbs[i];\n        const gapSegments = currentClimb.startSegment - prevClimb.endSegment;\n        if (gapSegments <= CONFIG.MAX_GAP_SEGMENTS) {\n            prevClimb.endSegment = currentClimb.endSegment;\n            climbs.splice(i, 1);\n            i--;\n        }\n    }\n\n    let annotations = [];\n    let traces = [];\n    let climbNo = 0;\n\n\n    // Funzione per colorazione zona potenza secondo la CONFIG\n    function getZoneColor(avgPower, ftp) {\n        const percentage = (avgPower / ftp) * 100;\n        for (let i = 0; i < CONFIG.COLORS.length; i++) {\n            if (percentage >= CONFIG.COLORS[i].min) {\n                return CONFIG.COLORS[i].color;\n            }\n        }\n        return CONFIG.COLORS[CONFIG.COLORS.length - 1].color;\n    }\n\n    climbs.forEach(climb => {\n        const startIndex = sections[climb.startSegment].startIndex;\n        const endIndex = sections[climb.endSegment].endIndex;\n        const climbSections = sections.slice(climb.startSegment, climb.endSegment + 1);\n\n        const dist = climbSections.reduce((sum, section) => sum + section.distance, 0);\n        const elevationGain = climbSections.reduce((sum, section) => sum + section.elevation, 0);\n        const avgGrade = elevationGain / dist * 100;\n        const difficultyCoefficient = Math.pow(avgGrade, 2) * (dist / 1000);\n        if (difficultyCoefficient < CONFIG.MIN_DIFFICULTY) return;\n        climbNo++;\n        const sectionPower = power.slice(startIndex, endIndex);\n        const sectionHRs = heartrate.slice(startIndex, endIndex);\n        // Calcoli robusti su array vuoti\n        const avgPower = sectionPower.length > 0 ? sectionPower.reduce((a, b) => a + b, 0) / sectionPower.length : 0;\n        const avgHR = sectionHRs.length > 0 ? sectionHRs.reduce((a, b) => a + b, 0) / sectionHRs.length : 0;\n        const best5sWatts = sectionPower.length > 0 ? getBestAverageOverNSeconds(sectionPower, 5) : 0;\n        const maxHR = sectionHRs.length > 0 ? Math.max(...sectionHRs) : 0;\n        const climbTimeInSeconds = time[endIndex] - time[startIndex];\n        const formattedTime = `${Math.floor(climbTimeInSeconds / 60)}m${climbTimeInSeconds % 60}s`;\n        const ascentSpeed = climbTimeInSeconds > 0 ? elevationGain / (climbTimeInSeconds / 3600) : 0;\n        const avgHorizontalSpeed = climbTimeInSeconds > 0 ? (dist / 1000) / (climbTimeInSeconds / 3600) : 0;\n        const maxGrade = grade.length > 0 ? Math.max(...grade.slice(startIndex, endIndex)) : 0;\n        const weight = icu.activity.icu_weight || 1;\n        const FTP = icu.activity.icu_ftp || 1;\n        const avgPowerPerKg = avgPower / weight;\n        const best5sPerKg = best5sWatts / weight;\n        const gradientFactor = (2 + avgGrade / 10) * 100;\n        const TEORICWKG = gradientFactor !== 0 ? ascentSpeed / gradientFactor : 0;\n        const TEORICVAM = avgPowerPerKg * gradientFactor;\n        const vamDiff = ascentSpeed - TEORICVAM;\n        // Calculate first and second half average power and their ratio\n        let rat_1 = 0, rat_2 = 0, ratio = 0;\n        if (sectionPower.length > 1) {\n            const half = Math.floor(sectionPower.length / 2);\n            rat_1 = half > 0 ? sectionPower.slice(0, half).reduce((a, b) => a + b, 0) / half : 0;\n            rat_2 = (sectionPower.length - half) > 0 ? sectionPower.slice(half).reduce((a, b) => a + b, 0) / (sectionPower.length - half) : 0;\n            ratio = rat_1 !== 0 ? rat_2 / rat_1 : 0;\n        }\n        // VAM arrow (solo testo, nessuna emoji)\n        let vamArrow = '';\n        if (vamDiff > 10) {\n            vamArrow = ` +${vamDiff.toFixed(0)} m/h`;\n        } else if (vamDiff < -10) {\n            vamArrow = ` -${vamDiff.toFixed(0)} m/h`;\n        } else {\n            vamArrow = ` ~${vamDiff.toFixed(0)} m/h`;\n        }\n        let bgColor = getZoneColor(avgPower, FTP);\n        let hrText = '';\n        if (sectionHRs.length > 0 && sectionHRs.some(hr => hr > 0)) {\n            hrText = `  ${avgHR.toFixed(0)} bpm | max. ${maxHR} bpm<br>`;\n        }\n        traces.push({\n            x: distanceKm.slice(startIndex, endIndex),\n            y: altitude.slice(startIndex, endIndex),\n            type: 'scatter',\n            mode: 'lines',\n            line: { color: bgColor, width: 2 },\n            name: `Anstieg ${climbNo}`,\n            hoverinfo: 'text',\n            text: `Climb ${climbNo}<br>\n ${(dist / 1000).toFixed(2)} km |  ${elevationGain.toFixed(0)}m <br>\n  ${avgGrade.toFixed(1)}% | max. ${maxGrade.toFixed(1)}%<br>\n ${avgPower.toFixed(0)} W | 5s ${best5sWatts.toFixed(0)} W<br>\n ${avgPowerPerKg.toFixed(2)} W/kg | 5s ${best5sPerKg.toFixed(2)} W/kg<br> \n ${rat_1.toFixed(0)} W | ${rat_2.toFixed(0)} W | ${(ratio).toFixed(2)}<br>\n${hrText}\n ${formattedTime} |  ${avgHorizontalSpeed.toFixed(1)} km/h<br>\n ${ascentSpeed.toFixed(0)} m/h${vamArrow}`\n        });\n\n        let hrAnn = '';\n        if (sectionHRs.length > 0 && sectionHRs.some(hr => hr > 0)) {\n            hrAnn = ` ${avgHR.toFixed(0)} <br>`;\n        }\n        annotations.push({\n            x: (distanceKm[startIndex] + distanceKm[endIndex]) / 2,\n            y: Math.max(...altitude) + 130,\n            text: `QDH ${difficultyCoefficient.toFixed(0)}<br> ${avgPower.toFixed(0)} <br>${hrAnn} ${climbTimeInSeconds.toFixed(0)} s`,\n            showarrow: false,\n            font: {\n                family: 'Arial',\n                size: 12,\n                color: 'white'\n            },\n            align: 'center',\n            bgcolor: bgColor,\n            bordercolor: difficultyCoefficient > 900 ? 'red' : null,\n            borderwidth: difficultyCoefficient > 900 ? 2 : 0,\n            opacity: 0.9\n        });\n    });\n\n    traces.unshift({\n        x: distanceKm,\n        y: altitude,\n        text: altitude.map(alt => `${alt.toFixed(1)} m`),\n        hoverinfo: 'text',\n        fill: 'tozeroy',\n        type: 'scatter',\n        fillcolor: 'whitesmoke',\n        mode: 'none',\n        name: 'Hhe'\n    });\n\n    const layout = {\n        title: 'Elevation profile',\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: false,\n        margin: {\n            t: 100,\n            l: 50,\n            r: 50,\n            b: 50\n        }\n    };\n\n    const chart = { data: traces, layout };\n    chart;",
        "name": "Punch"
      },
      "usage_count": 0,
      "index": 12,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-17T09:48:08.081+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 759402,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "FOLLOWERS",
      "name": "Volume Trend",
      "description": "",
      "image": null,
      "content": {
        "id": "fgw9tmas",
        "name": "Volume Trend",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#00000045",
            "text": "Day",
            "type": "dot",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#00000029",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "none",
            "strokeWidth": 0.2,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#50486180",
            "text": "Weekly",
            "type": "bars",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#33333380",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "moving_avg",
            "min": 0,
            "band": 0,
            "fill": "rgba(44,160,44, 0.4)",
            "text": "W 28d",
            "type": "line",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#009e00ff",
            "aggArgs": {
              "days": 28,
              "factor": 7
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "moving_avg",
            "min": 0,
            "band": 0,
            "fill": "#009e00ff",
            "text": "W 84d",
            "type": "line",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#334cccff",
            "aggArgs": {
              "days": 84,
              "factor": 7
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 7,
            "agg": "moving_avg",
            "min": 0,
            "band": 0,
            "fill": "rgba(44,160,44, 0.4)",
            "text": "W 182d",
            "type": "line",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#dd04a7ff",
            "aggArgs": {
              "days": 182,
              "factor": 7
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Volume Trend",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "h",
        "y2AxisLabel": " ",
        "stackTo100Percent": false
      },
      "usage_count": 1,
      "index": 12,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-04T21:32:29.155+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396248,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "kJ/h>CP",
      "description": "kJ per hour over CP considering total work above and belove power curve",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "WorkHourOverCP",
        "icon": "battery_5_bar",
        "link": null,
        "type": "numeric",
        "color": "#EE2C6D",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntime =  streams.get(\"time\").data\nftp = activity.icu_ftp\njoules = 0\nfor (let i = 0; i < watts.length; i++) {\n  let w = watts[i]\n  if (w >= ftp) { \n    let secs = time[i] - (i > 0 ? time[i - 1] : 0)\n    if (secs < 30) joules += w * secs\n  }\n}\njoules/1000\n/(activity. moving_time/3600)",
        "suffix": " kJ/h",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "AVERAGE",
        "pace_units": null,
        "number_format": ".1f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "kJ/h>CP"
      },
      "usage_count": 42,
      "index": 13,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-17T14:09:38.828+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 400938,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "FOLLOWERS",
      "name": "Peso",
      "description": null,
      "image": null,
      "content": {
        "id": "u3rti7ck",
        "name": "Peso",
        "plots": [
          {
            "id": 3,
            "agg": "moving_avg",
            "min": null,
            "band": 0,
            "fill": "#8D82474A",
            "text": "Weight 7d",
            "type": "bars",
            "field": "weight",
            "gauge": true,
            "scale": "weight",
            "stack": "",
            "title": "Fatness",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#8d8247",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Weight",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Fatness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 7,
            "agg": "fill_in",
            "min": null,
            "band": 0,
            "fill": "#8d824780",
            "text": "Weight day",
            "type": "dot",
            "field": "weight",
            "gauge": true,
            "scale": "weight",
            "stack": "",
            "title": "Fatness",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#8D82474A",
            "filters": [],
            "i18nKey": "Weight",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Fatness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 9,
            "agg": "moving_avg",
            "min": null,
            "band": 0.3,
            "fill": "#8D824740",
            "text": "Weight 31d",
            "type": "dot",
            "field": "weight",
            "gauge": true,
            "scale": "weight",
            "stack": "",
            "title": "Fatness",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#8D824700",
            "aggArgs": {
              "days": 31,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Weight",
            "markerValue": "right",
            "strokeWidth": 0.1,
            "i18nTitleKey": "Fatness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 10,
            "agg": "month_avg",
            "min": null,
            "band": 0,
            "fill": "#8d824780",
            "text": "Monthly Avg",
            "type": "line",
            "field": "weight",
            "gauge": true,
            "scale": "weight",
            "stack": "",
            "title": "Fatness",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#8D8247C4",
            "aggArgs": {
              "days": 90,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Weight",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Fatness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 11,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "rgba(221,4,71,0.5)",
            "text": "Period",
            "type": "dot",
            "field": "period",
            "scale": "period",
            "stack": "",
            "title": "Period days",
            "extras": [],
            "filter": "period",
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "filters": [],
            "i18nKey": "Period",
            "markerValue": "none",
            "strokeWidth": 0,
            "i18nTitleKey": "Period days",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 12,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#000000FF",
            "text": "Fase",
            "type": "dot",
            "field": "Ciclo",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "Ciclo",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "tickFormat": "customInput",
            "customInput": {
              "id": 660383,
              "name": "Fasi ciclo",
              "type": "INPUT_FIELD",
              "image": null,
              "index": 5,
              "content": {
                "max": null,
                "min": null,
                "code": "Ciclo",
                "icon": "",
                "link": null,
                "name": "Fasi ciclo",
                "type": "select",
                "color": "#009E00",
                "gauge": true,
                "total": null,
                "units": null,
                "prefix": null,
                "script": null,
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 3,
                "options": [
                  {
                    "icon": null,
                    "text": " Mestruale",
                    "color": "#D62728",
                    "value": 1
                  },
                  {
                    "icon": null,
                    "text": "Follicolare",
                    "color": "#334CCC",
                    "value": 2
                  },
                  {
                    "icon": null,
                    "text": "Luteale",
                    "color": "#FFCB0E",
                    "value": 3
                  },
                  {
                    "icon": null,
                    "text": "Ovulatorio",
                    "color": "#009E00",
                    "value": 4
                  }
                ],
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "processes_fit_messages": false
              },
              "from_id": 660148,
              "updated": "2025-05-23T16:40:07.482+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": "fase mestruale",
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": "i180702",
                "bio": null,
                "sex": "F",
                "city": null,
                "name": "campanella",
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": "Europe/Rome",
                "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/f458629b-7f60-4554-bf9f-c5e5b88bc1a3"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 13,
            "agg": "moving_avg",
            "min": null,
            "band": 0,
            "fill": "#50486180",
            "text": "BF 10d",
            "type": "line",
            "field": "body_fat",
            "gauge": true,
            "scale": "percent",
            "stack": "",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#504861",
            "aggArgs": {
              "days": 10,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Body Fat",
            "markerValue": "right",
            "strokeWidth": 1,
            "invertSubWellness": false
          }
        ],
        "title": "Weight",
        "height": 330,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Kg",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 13,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-11-07T12:35:37.589+00:00",
      "from_athlete": {
        "id": "i180702",
        "name": "campanella",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/f458629b-7f60-4554-bf9f-c5e5b88bc1a3",
        "city": "Trento",
        "state": "Trentino",
        "country": "Italy",
        "timezone": "Europe/Rome",
        "sex": "F",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 400934
    },
    {
      "id": 435212,
      "athlete_id": "i115436",
      "type": "ACTIVITY_HISTOGRAM",
      "visibility": "PRIVATE",
      "name": "Balance",
      "description": "",
      "image": null,
      "content": {
        "id": null,
        "name": "Balance",
        "plots": [
          {
            "id": 1,
            "max": 60,
            "min": 40,
            "axis": null,
            "text": "Balance",
            "type": "bars",
            "color": "#6633cc",
            "scale": "watts",
            "extras": [],
            "legend": false,
            "stream": "left_right_balance",
            "transform": "none",
            "bucketSize": 1,
            "areaOpacity": 0.7,
            "lineOpacity": 0.7,
            "trimPercent": null,
            "transformArgs": null,
            "hideLastBucket": false,
            "hideFirstBucket": false
          }
        ],
        "width": 510,
        "height": 350
      },
      "usage_count": 0,
      "index": 13,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-05T15:17:19.669+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 439188,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "45sTTCHART",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "45sTTCHART",
        "plots": [
          {
            "id": 2,
            "axis": "watts",
            "text": "45s Power",
            "color": "#6633cc",
            "extras": [
              {
                "id": 1,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.2
              },
              {
                "id": 2,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 3,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.2
              },
              {
                "id": 3,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 4,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.2
              },
              {
                "id": 4,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 5,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.2
              }
            ],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 1,
            "strokeWidth": 1.01,
            "transformArgs": {
              "secs": 45
            }
          }
        ],
        "title": null,
        "height": 120,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 13,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-01T20:55:06.959+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396252,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PUBLIC",
      "name": "kJ/h/kg>CP",
      "description": "kJ per hour per kilo over CP considering total work above and belove power curve",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "WorkHourKgoverCP",
        "icon": "balance",
        "link": null,
        "type": "numeric",
        "color": "#EE2C6D",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntime =  streams.get(\"time\").data\nftp = activity.icu_ftp\njoules = 0\nfor (let i = 0; i < watts.length; i++) {\n  let w = watts[i]\n  if (w >= ftp) { \n    let secs = time[i] - (i > 0 ? time[i - 1] : 0)\n    if (secs < 30) joules += w * secs\n  }\n}\njoules/1000\n/(activity. moving_time/3600)/(activity.icu_weight)",
        "suffix": " kJ/h/kg",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "AVERAGE",
        "pace_units": null,
        "number_format": ".1f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "kJ/h/kg>CP"
      },
      "usage_count": 72,
      "index": 14,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-17T14:09:30.636+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 439190,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "10sTTCHART",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "10sTTCHART",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "10s Power",
            "color": "#6633CCFF",
            "extras": [
              {
                "id": 1,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.2
              },
              {
                "id": 2,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 3,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.2
              },
              {
                "id": 3,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 4,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.2
              },
              {
                "id": 4,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 5,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.2
              }
            ],
            "legend": false,
            "stream": "watts_10s",
            "transform": "none",
            "areaOpacity": 0.05,
            "lineOpacity": 1,
            "strokeWidth": 1.01,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 120,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 14,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-02-28T07:48:58.521+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 688703,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "VAM chart",
      "description": "1' minute MMV. 1'-90' range",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/11b1e541-ab7f-4197-acec-8777a3e91c07",
      "content": {
        "link": null,
        "width": "100%",
        "height": "600px",
        "script": "{\n  // --- CONFIGURAZIONE INIZIALE ---\n  const CONFIG = {\n\n    // Colori\n    COLOR_LINE: '#365A98',         // Colore della linea principale\n    COLOR_MARKER: '#365A98',       // Colore dei marker\n\n    // Marker\n    MARKER_SYMBOL: 'circle',       // Simbolo marker (Plotly symbol)\n    MARKER_SIZE: 8,                // Dimensione marker\n\n    // Titoli e font\n    TITLE: 'VAM Peak Chart',       // Titolo del grafico\n    XAXIS_TITLE: 'Duration (min)', // Titolo asse X\n    YAXIS_TITLE: 'VAM (m/h)',      // Titolo asse Y\n    FONT_SIZE: 12,                 // Dimensione font tick e label\n    TICKANGLE_X: -90,              // Angolo etichette asse X\n    TICKANGLE_Y: 0,                // Angolo etichette asse Y\n\n    // Margini e shape\n    MARGIN: { t: 50, l: 60, r: 20, b: 100 }, // Margini del grafico\n    SHAPE_WIDTH_X: 1,              // Spessore linea shape orizzontale (X)\n    SHAPE_WIDTH_Y: 2,              // Spessore linea shape verticale (Y)\n\n    // Intervalli (personalizzati)\n    INTERVAL_1_STEP: 60,           // Step 1: ogni 60s\n    INTERVAL_1_END: 900,           // Step 1: fino a 15' (900s)\n    INTERVAL_2_STEP: 300,          // Step 2: ogni 5' (300s)\n    INTERVAL_2_END: 3600,          // Step 2: fino a 60' (3600s)\n    INTERVAL_3_STEP: 600,          // Step 3: ogni 10' (600s)\n    INTERVAL_END: 5400             // Fine intervallo (secondi)\n  };\n  // --- FINE CONFIG ---\n\n  const stream = icu.streams;\n  const maxTime = icu.activity.moving_time;\n  console.log(`Total moving time: ${maxTime}s`);\n\n  // Intervalli: ogni 60s fino a 15', poi ogni 5' fino a 60', poi ogni 10' fino a INTERVAL_END\n  const intervals = [];\n  const end = Math.min(CONFIG.INTERVAL_END, maxTime);\n  // Ogni 60s fino a 15'\n  for (let s = 60; s <= Math.min(900, end); s += 60) intervals.push(s);\n  // Ogni 5' (300s) da 20' a 60'\n  for (let s = 1200; s <= Math.min(3600, end); s += 300) if (!intervals.includes(s)) intervals.push(s);\n  // Ogni 10' (600s) da 60' a end\n  for (let s = 4200; s <= end; s += 600) if (!intervals.includes(s)) intervals.push(s);\n  intervals.sort((a, b) => a - b);\n\n\n\n  // Guadagno altimetrico cumulativo (solo salite), ignorando salti anomali\n  let altitude = stream.altitude;\n  let time = stream.time;\n  let cumulativeGain = altitude.reduce((arr, alt, i, src) => {\n    if (i === 0) { arr.push(0); return arr; }\n    const delta = alt - src[i - 1];\n    // Se il salto  > 10m in 1 secondo, lo ignoro (probabile errore altimetro)\n    const dt = time[i] - time[i - 1];\n    const isJump = dt > 0 && Math.abs(delta) / dt > 10;\n    arr.push(arr[arr.length - 1] + ((delta > 0 && !isJump) ? delta : 0));\n    return arr;\n  }, []);\n\n  // Calcolo dei picchi di VAM\n  const vamPeaks = intervals.map(interval => {\n    let best = 0;\n    for (let i = 0; i < cumulativeGain.length - interval; i++) {\n      let j = i + interval;\n      if (j >= cumulativeGain.length) break;\n      let deltaGain = cumulativeGain[j] - cumulativeGain[i];\n      if (deltaGain > best) best = deltaGain;\n    }\n    return (best / interval) * 3600;\n  });\n\n  // ASSE X VALUES\n  const xValues = intervals.map(sec => sec / 60);\n  const xLabels = intervals.map(sec => `${Math.round(sec/60)} m`);\n\n  // Plot\n  const traces = [{\n    x: xValues,\n    y: vamPeaks,\n    type: 'scatter',\n    mode: 'lines+markers',\n    marker: {\n      color: CONFIG.COLOR_MARKER,\n      symbol: CONFIG.MARKER_SYMBOL,\n      size: CONFIG.MARKER_SIZE\n    },\n    line: { shape: 'spline', color: CONFIG.COLOR_LINE },\n    name: 'VAM Peaks',\n    hovertemplate:\n      '%{text}<br>VAM: %{y:.0f} m/h<extra></extra>',\n    text: xLabels\n  }];\n\n  const layout = {\n    title: CONFIG.TITLE,\n    xaxis: {\n      title: CONFIG.XAXIS_TITLE,\n      type: 'linear',\n      tickvals: xValues,\n      ticktext: xLabels,\n      tickfont: { size: CONFIG.FONT_SIZE },\n      tickangle: CONFIG.TICKANGLE_X,\n      range: [Math.max(0, Math.min(...xValues) - 2), Math.max(...xValues) + 1]\n    },\n    yaxis: {\n      title: CONFIG.YAXIS_TITLE,\n      tickformat: ',d',\n      tickfont: { size: CONFIG.FONT_SIZE },\n      tickangle: CONFIG.TICKANGLE_Y,\n      range: [\n        Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        null\n      ]\n    },\n    margin: CONFIG.MARGIN,\n    shapes: [\n      {\n        type: 'line',\n        xref: 'paper',\n        x0: 0,\n        x1: 1,\n        yref: 'y',\n        y0: Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        y1: Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        line: {\n          color: '#000000b3',\n          width: CONFIG.SHAPE_WIDTH_X\n        }\n      }\n    ]\n  };\n\n  const chart = { data: traces, layout };\n  chart;\n}",
        "name": "VAM chart"
      },
      "usage_count": 4,
      "index": 14,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-26T08:24:25.803+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 874580,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Form - FEEL",
      "description": null,
      "image": null,
      "content": {
        "id": "tzdgl7er",
        "name": "Form - FEEL",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#50486180",
            "text": "Form %",
            "type": "line",
            "field": "form_percent",
            "scale": "form_percent",
            "stack": "",
            "title": "Form as % of fitness",
            "extras": [
              {
                "id": 1,
                "y1": 30,
                "y2": 50,
                "fill": "#ffcb0eff",
                "text": "Transition",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#ffcb0eff",
                "opacity": 0.3
              },
              {
                "id": 2,
                "y1": 10,
                "y2": 30,
                "fill": "#34ace466",
                "text": "Fresh",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#34ace466",
                "opacity": 0.3
              },
              {
                "id": 3,
                "y1": -10,
                "y2": 10,
                "fill": "#7f7f7f66",
                "text": "Grey Zone",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#7f7f7f66",
                "opacity": 0.3
              },
              {
                "id": 4,
                "y1": -30,
                "y2": -10,
                "fill": "#009e0066",
                "text": "Optimal",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#009e0080",
                "opacity": 0.3
              },
              {
                "id": 5,
                "y1": -50,
                "y2": -30,
                "fill": "#d62728ff",
                "text": "High Risk",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#d62728ff",
                "opacity": 0.3
              }
            ],
            "filter": "round0",
            "future": true,
            "radius": 3,
            "stroke": "#334ccc91",
            "filters": [],
            "i18nKey": "Form %",
            "markerValue": "top",
            "strokeWidth": 2,
            "i18nTitleKey": "Form as % of fitness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#2ca02cff",
            "text": "Feel",
            "type": "dot",
            "field": "feel",
            "gauge": true,
            "scale": "feel",
            "stack": "",
            "title": "How did you feel?",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "TrackRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Feel",
            "markerValue": "top",
            "strokeWidth": 1,
            "i18nTitleKey": "feel",
            "showOnCalendar": false,
            "invertSubWellness": true
          }
        ],
        "title": "",
        "height": 220,
        "yAxisMax": 50.0,
        "yAxisMin": -50.0,
        "y2AxisMax": 5.0,
        "y2AxisMin": 1.0,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "",
        "y2AxisLabel": "",
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 14,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-22T10:08:37.522+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 396327,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Bonvifactor",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Bonvifactor",
        "icon": "android",
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "(((activity.icu_joules/1000)/(activity. moving_time/3600)/(activity.icu_weight)) * ((activity.icu_joules/1000)/(activity. moving_time/3600)/(activity.icu_weight)) * ((activity. power_load) + (activity. hr_load)) / 1.5) / 100",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "pace_units": null,
        "number_format": ".1f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Bonvifactor"
      },
      "usage_count": 5,
      "index": 15,
      "hide_script": true,
      "hidden_by_id": "i115436",
      "updated": "2024-08-14T19:00:08.052+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 439191,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "CadenceTT",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "CadenceTT",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "Cadence",
            "color": "#1F77B4FF",
            "extras": [],
            "legend": false,
            "stream": "cadence",
            "transform": "none",
            "areaOpacity": 0.9,
            "lineOpacity": 1,
            "strokeWidth": 1.5,
            "transformArgs": null
          },
          {
            "id": 2,
            "axis": null,
            "text": "TREND",
            "color": "#1BFF00FF",
            "extras": [],
            "legend": true,
            "stream": "cadence",
            "transform": "interval_linear_trend",
            "areaOpacity": 0.05,
            "lineOpacity": 15,
            "strokeWidth": 2,
            "transformArgs": null
          },
          {
            "id": 3,
            "axis": null,
            "text": "AVG",
            "color": "#FF00FFFF",
            "extras": [],
            "legend": true,
            "stream": "cadence",
            "transform": "interval_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 15,
            "strokeWidth": 1.75,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 90,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 15,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-01T20:58:27.076+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504071,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "RPE Chart",
      "description": "RPE chart for Cycling, alternatives and Strenght training",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/1c08d01f-3e45-443a-ac2c-a354a6d0c121",
      "content": {
        "id": "i5v2pef8",
        "name": "RPE Chart",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#000000FF",
            "text": "RPE END",
            "type": "dot",
            "field": "rpe",
            "gauge": true,
            "scale": "rpe",
            "stack": "",
            "title": "Rate of Perceived Exertion",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#009E80FF",
                "text": "1 - Nothing at all",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#009E80FF",
                "text": "2 - Very easy",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#009E00FF",
                "text": "3 - Easy",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#DBAC00FF",
                "text": "4 - Confortable",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 5,
                "y1": 4.5,
                "y2": 5.5,
                "fill": "#FF7F0EFF",
                "text": "5 - Slightly challenging",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 6,
                "y1": 5.5,
                "y2": 6.5,
                "fill": "#FF7F0EFF",
                "text": "6 - Difficoult",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 7,
                "y1": 6.5,
                "y2": 7.5,
                "fill": "#DD0447FF",
                "text": "7 - Hard",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 8,
                "y1": 7.5,
                "y2": 8.5,
                "fill": "#DD0447FF",
                "text": "8 - Very hard",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 9,
                "y1": 8.5,
                "y2": 9.5,
                "fill": "#6633CCFF",
                "text": "9 - Extremely hard",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 10,
                "y1": 9.5,
                "y2": 10.5,
                "fill": "#504861FF",
                "text": "10 - Max effort",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              }
            ],
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "RPE",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Rate of Perceived Exertion",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#D6272800",
            "text": "RPE STR",
            "type": "dot",
            "field": "rpe",
            "gauge": true,
            "scale": "rpe",
            "stack": "",
            "title": "Rate of Perceived Exertion",
            "extras": [],
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "WeightTraining",
                  "Workout"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "RPE",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Rate of Perceived Exertion",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#8D824700",
            "text": "RPE",
            "type": "bars",
            "field": "rpe",
            "gauge": true,
            "scale": "rpe",
            "stack": "",
            "title": "Rate of Perceived Exertion",
            "extras": [],
            "radius": 3,
            "stroke": "rgb(102,51,204)",
            "filters": [],
            "i18nKey": "RPE",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Rate of Perceived Exertion",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#6633CC80",
            "text": "RPE",
            "type": "dot",
            "field": "rpe",
            "gauge": true,
            "scale": "rpe",
            "stack": "",
            "title": "Rate of Perceived Exertion",
            "extras": [],
            "radius": 3,
            "stroke": "#0E7BF1FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Run",
                  "TrailRun",
                  "Swim",
                  "VirtualRun",
                  "Hike",
                  "Walk"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "RPE",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Rate of Perceived Exertion",
            "invertSubWellness": false
          }
        ],
        "title": "RPE",
        "height": 220,
        "yAxisMax": 10.5,
        "yAxisMin": 0.5,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "RPE",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 13,
      "index": 15,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:18:00.848+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 688718,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "VAMpeak",
      "description": "Shows the best vertical ascent rates over 1 minute window time intervals",
      "image": null,
      "content": {
        "link": "https://forum.intervals.icu/t/vam-peaks-chart-is-this-graph-possible-in-intervals/107660",
        "width": "100%",
        "height": "300px",
        "script": "{\n\nconst stream = icu.streams;\nconst maxTime = icu.activity.moving_time; // total moving time in seconds\nconsole.log(maxTime);\n\n// Generate 1-minute step intervals up to maxTime (rounded down to nearest minute)\nlet intervals = [];\nfor (let t = 120; t <= Math.floor(maxTime / 60) * 60; t += 120) {\n  intervals.push(t);\n}\n// Or use fix intervals\n//let intervals = [60, 120, 180, 240, 300, 360, 420, 480, 540, 600]; // 1min, 2min, 5min, 10min\n\nlet vamPeaks = [];\n\n// Find the first valid (non-zero) altitude index  in case altitude data is not available at beginning of an activity\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nintervals.forEach(interval => {\n  let best = 0;\n  for (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n    let gain = stream.altitude[i + interval] - stream.altitude[i];\n    if (gain > best) best = gain;\n  }\n\n  let vam = (best / interval) * 3600; // Convert to m/h\n  vamPeaks.push(vam);\n});\n\n// Define the X-axis labels (duration in minutes)\nlet xLabels = intervals.map(sec => `${sec / 60} min`);\n\n// Step 1: Create traces array\nlet traces = [{\n  x: xLabels,\n  y: vamPeaks,\n  type: 'bar',\n  marker: { color: 'darkorange' },\n  name: 'VAM Peaks'\n}];\n\n// Step 2: Define layout object\nlet layout = {\n  title: 'VAM Peak Chart',\n  xaxis: { title: 'Duration (minutes)' },\n  yaxis: { title: 'VAM (m/h)', rangemode: 'tozero' },\n  margin: { t: 50, l: 60, r: 20, b: 80 }\n};\n\n// Step 3: Combine into chart\nconst chart = { data: traces, layout };\nchart;\n\n\n}",
        "name": "VAMpeak"
      },
      "usage_count": 0,
      "index": 15,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-06-26T12:21:28.138+00:00",
      "from_athlete": {
        "id": "i85346",
        "name": "R2Tom",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/9effd3aa-d71f-4dc5-a60b-bd8a7af746e5",
        "city": "Altdorf",
        "state": "Bavaria",
        "country": "Germany",
        "timezone": "Europe/Berlin",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 688046
    },
    {
      "id": 405268,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Bonvifactor 2.0",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Bonvifactor20",
        "icon": "android",
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "((activity.icu_joules_above_ftp/1000)+(((activity.icu_joules/1000)/(activity. moving_time/3600)/(activity.icu_weight))) * ((activity. power_load) + (activity. hr_load)) / 1.5) / 10",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "pace_units": null,
        "number_format": ".1f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Bonvifactor 2.0"
      },
      "usage_count": 4,
      "index": 16,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-08-21T20:28:50.694+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 453467,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "Aeropoint beta",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "Aeropoint beta",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "Aeropoint2.0",
            "color": "#334CCCFF",
            "extras": [],
            "legend": true,
            "stream": "Aeropoint20",
            "transform": "moving_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 1,
            "transformArgs": {
              "secs": 30
            }
          },
          {
            "id": 2,
            "axis": null,
            "text": "Power",
            "color": "#6633cc",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 0.1,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 10
            }
          },
          {
            "id": 3,
            "axis": null,
            "text": "Speed",
            "color": "#34ace4",
            "extras": [],
            "legend": true,
            "stream": "velocity_smooth",
            "transform": "moving_avg",
            "areaOpacity": 0.1,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 10
            }
          },
          {
            "id": 4,
            "axis": null,
            "text": "Aeropoint2.0",
            "color": "#666666FF",
            "extras": [],
            "legend": true,
            "stream": "Aeropoint20",
            "transform": "interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 0.7,
            "transformArgs": null
          },
          {
            "id": 5,
            "axis": null,
            "text": "Aeropoint2.0",
            "color": "#FF00FFFF",
            "extras": [],
            "legend": true,
            "stream": "Aeropoint20",
            "transform": "zoom_avg",
            "areaOpacity": 0,
            "lineOpacity": 0.7,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 120,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 16,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-13T15:32:17.665+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504093,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Feel",
      "description": "Feeling chart for Cycling, alternatives and Strenght training",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/9dffbb26-10df-48dd-8563-43775570a96f",
      "content": {
        "id": "op25pzqz",
        "name": "Feel",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#000000FF",
            "text": "Feel",
            "type": "dot",
            "field": "feel",
            "gauge": true,
            "scale": "feel",
            "stack": "",
            "title": "How did you feel?",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#DD0447FF",
                "text": "WEAK",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#FC7C0CFF",
                "text": "POOR",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#E5A718FF",
                "text": "NORMAL",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#16BB16FF",
                "text": "GOOD",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 5,
                "y1": 4.5,
                "y2": 5.5,
                "fill": "#1F77B4FF",
                "text": "STRONG",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Feel",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "feel",
            "showOnCalendar": false,
            "invertSubWellness": true
          },
          {
            "id": 2,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#8D824700",
            "text": "Feel",
            "type": "dot",
            "field": "feel",
            "gauge": true,
            "scale": "feel",
            "stack": "",
            "title": "How did you feel?",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "WeightTraining",
                  "Workout"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Feel",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "feel",
            "showOnCalendar": false,
            "invertSubWellness": true
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#8D824700",
            "text": "Feel",
            "type": "bars",
            "field": "feel",
            "gauge": true,
            "scale": "feel",
            "stack": "",
            "title": "How did you feel?",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(0,158,0)",
            "filters": [],
            "i18nKey": "Feel",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "feel",
            "showOnCalendar": false,
            "invertSubWellness": true
          },
          {
            "id": 4,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#6633CC80",
            "text": "Feel",
            "type": "dot",
            "field": "feel",
            "gauge": true,
            "scale": "feel",
            "stack": "",
            "title": "How did you feel?",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#0E7BF1FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Run",
                  "TrailRun",
                  "Swim",
                  "VirtualRun",
                  "Hike",
                  "Walk"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Feel",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "feel",
            "showOnCalendar": false,
            "invertSubWellness": true
          }
        ],
        "title": "Feel",
        "height": 110,
        "yAxisMax": 5.5,
        "yAxisMin": 0.5,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 18,
      "index": 16,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-10-24T09:48:38.385+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 688728,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PUBLIC",
      "name": "VAM chart SHORT",
      "description": null,
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/e051a329-b836-47a9-9c3f-7c4745b56b78",
      "content": {
        "link": null,
        "width": "100%",
        "height": "600px",
        "script": "{\n  const stream = icu.streams;\n  const maxTime = icu.activity.moving_time;\n  console.log(`Total moving time: ${maxTime}s`);\n\n  // Intervals: every 20s from 20s to 480s\n  let intervals = [];\n  for (let s = 20; s <= 480; s += 20) intervals.push(s);\n  intervals = intervals.filter(interval => interval <= maxTime);\n\n  let vamPeaks = [];\n\n  // Monotonic elevation gain (cumulative)\n  let cumulativeGain = [];\n  let gain = 0;\n  let altitude = stream.altitude;\n    // Trova il primo indice con altitudine > 1\n  let startIdx = 0;\n  while (startIdx < altitude.length && altitude[startIdx] <= 1) {\n    startIdx++;\n  }\n  // Se trovato, filtra tutti gli array da startIdx\n  if (startIdx > 0) {\n    altitude = altitude.slice(startIdx);\n  }\n\n  cumulativeGain[0] = 0;\n  for (let i = 1; i < altitude.length; i++) {\n    let delta = altitude[i] - altitude[i - 1];\n    if (delta > 0) gain += delta;\n    cumulativeGain[i] = gain;\n  }\n\n  // Best VAM calculation\n  intervals.forEach(interval => {\n    let best = 0;\n    for (let i = 0; i < cumulativeGain.length - interval; i++) {\n      let j = i + interval;\n      if (j >= cumulativeGain.length) break;\n      let deltaGain = cumulativeGain[j] - cumulativeGain[i];\n      if (deltaGain > best) best = deltaGain;\n    }\n    let vam = (best / interval) * 3600;\n    vamPeaks.push(vam);\n  });\n\n  // ASSE X VALUES\n  let xValues = intervals;\n  let xLabels = intervals.map(sec => `${sec} s`);\n\n  // Plot\n  let traces = [{\n    x: xValues,\n    y: vamPeaks,\n    type: 'scatter',\n    mode: 'lines+markers',\n    marker: { color: '365A98' },\n    line: { shape: 'spline' },\n    name: 'VAM Peaks',\n    hovertemplate:\n      '%{text}<br>VAM: %{y:.0f} m/h<extra></extra>',\n    text: xLabels\n  }];\n  let layout = {\n    title: 'VAM Peak Chart',\n    xaxis: {\n      title: 'Duration (s)',\n      type: 'linear',\n      tickvals: xValues,\n      ticktext: xLabels,\n      tickfont: { size: 12 },\n      tickangle: 0,\n      range: [Math.max(0, Math.min(...xValues) - 20), Math.max(...xValues) + 10]  //DISTANZA grafico a lato sx e dx\n    },\n    yaxis: {\n      title: 'VAM (m/h)',\n      tickformat: ',d',\n      tickfont: { size: 12 },\n      range: [\n        Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        null\n      ]\n    },\n    margin: { t: 50, l: 60, r: 20, b: 100 },\n    shapes: [\n      // Linea orizzontale meno spessa sull'asse y al minimo arrotondato\n      {\n        type: 'line',\n        xref: 'paper',\n        x0: 0,\n        x1: 1,\n        yref: 'y',\n        y0: Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        y1: Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        line: {\n          color: 'rgba(0,0,0,0.7)',\n          width: 1  //asse y spessore\n        }\n      },\n      // Linea verticale meno spessa sull'asse x a x=0\n      {\n        type: 'line',\n        xref: 'x',\n        x0: 0,\n        x1: 0,\n        yref: 'paper',\n        y0: 0,\n        y1: 1,\n        line: {\n          color: 'rgba(0,0,0,0.7)',\n          width: 2  //asse x spessore\n        }\n      }\n    ]\n  };\n\n  const chart = { data: traces, layout };\n  chart;\n}",
        "name": "VAM chart SHORT"
      },
      "usage_count": 8,
      "index": 16,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-12T16:47:54.675+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 407508,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "FOLLOWERS",
      "name": "% All Work>CP",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "AllworkCPPercentage",
        "icon": "mdi-battery_unknown",
        "link": null,
        "type": "numeric",
        "color": "#EE2C6D",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntime =  streams.get(\"time\").data\nftp = activity.icu_ftp\njoules = 0\nfor (let i = 0; i < watts.length; i++) {\n  let w = watts[i]\n  if (w >= ftp) { \n    let secs = time[i] - (i > 0 ? time[i - 1] : 0)\n    if (secs < 30) joules += w * secs\n  }\n}\njoules/1000/\nactivity.icu_joules*1000*100",
        "suffix": "%",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "AVERAGE",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".1f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "% All Work>CP"
      },
      "usage_count": 41,
      "index": 17,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-02T14:15:52.065+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 460351,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Soreness",
      "description": "Soreness day + avg7days trend chart",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/bc04965f-e11e-4983-85c9-c71fce3d0059",
      "content": {
        "id": "z272pu89",
        "name": "Soreness",
        "plots": [
          {
            "id": 2,
            "agg": "none",
            "min": 1,
            "band": 0,
            "fill": "#000000FF",
            "text": "Soreness",
            "type": "dot",
            "field": "soreness",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Soreness",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#34ACE4FF",
                "text": "LOW",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#16BB16FF",
                "text": "AVERAGE",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#FFB000FF",
                "text": "HIGH",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#FF520EFF",
                "text": "EXTREME",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Soreness",
            "markerValue": "right",
            "strokeWidth": 1.3,
            "i18nTitleKey": "Soreness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": 1,
            "band": 0,
            "fill": "#50486180",
            "text": "Soreness 7d",
            "type": "line",
            "field": "soreness",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Soreness",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Soreness",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Soreness",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Soreness",
        "height": 165,
        "yAxisMax": 4.5,
        "yAxisMin": 0.5,
        "y2AxisMax": 4.5,
        "y2AxisMin": 0.5,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Soreness",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 7,
      "index": 17,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:18:53.916+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 464661,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "Custom Chart 2",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "Custom Chart 2",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "AEROPOINT beta",
            "color": "#24A122FF",
            "extras": [],
            "legend": true,
            "stream": "AEROPOINT",
            "transform": "none",
            "areaOpacity": 0.05,
            "lineOpacity": 2,
            "transformArgs": null
          },
          {
            "id": 2,
            "axis": null,
            "text": "Aeropoint2.0",
            "color": "#666666FF",
            "extras": [],
            "legend": true,
            "stream": "Aeropoint20",
            "transform": "none",
            "areaOpacity": 0.05,
            "lineOpacity": 1,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 150,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 17,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-30T12:12:16.504+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 453360,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "AeroPoint",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "AeroPoint",
        "icon": "airplanemode_inactive",
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "((activity.average_speed)/(activity.icu_average_watts))*1000",
        "suffix": "",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".1f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "AeroPoint"
      },
      "usage_count": 9,
      "index": 18,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T09:38:55.960+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504017,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Subjective Fatigue",
      "description": "Fatigue day + avg7days trend chart",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/205d1eee-1bb7-49a7-b4a1-e77cab51a1fd",
      "content": {
        "id": "cyx3q29c",
        "name": "Subjective Fatigue",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": 1,
            "band": 0,
            "fill": "#000000FF",
            "text": "Fatigue",
            "type": "dot",
            "field": "wellness_fatigue",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Subjective fatigue",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#34ACE4FF",
                "text": "LOW",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#16BB16FF",
                "text": "AVERAGE",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#FFB000FF",
                "text": "HIGH",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#FF520EFF",
                "text": "EXTREME",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Subj Fatigue",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Subjective fatigue",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": 1,
            "band": 0,
            "fill": "#000000FF",
            "text": "Fatigue 7d",
            "type": "line",
            "field": "wellness_fatigue",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Subjective fatigue",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Subj Fatigue",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Subjective fatigue",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Fatigue",
        "height": 165,
        "yAxisMax": 4.5,
        "yAxisMin": 0.5,
        "y2AxisMax": 4.5,
        "y2AxisMin": 0.5,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Fatigue",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 5,
      "index": 18,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:19:06.294+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 579744,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "SS Power",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "SS Power",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "10s",
            "color": "#646FFFFF",
            "extras": [
              {
                "id": 1,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 1,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.3
              },
              {
                "id": 2,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.3
              },
              {
                "id": 3,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 3,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.3
              },
              {
                "id": 4,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 4,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.3
              },
              {
                "id": 5,
                "y1": 0,
                "y2": 1,
                "fill": "#009E0066",
                "text": "",
                "type": "zone",
                "zone": 5,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.3
              }
            ],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 3,
            "lineOpacity": 0.5,
            "strokeWidth": 1.01,
            "transformArgs": {
              "secs": 10
            }
          },
          {
            "id": 2,
            "axis": null,
            "text": "W/Kg",
            "color": "#646FFFFF",
            "extras": [],
            "legend": true,
            "stream": "WKg",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": {
              "secs": 10
            }
          },
          {
            "id": 3,
            "axis": null,
            "text": "60s",
            "color": "#000000FF",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "strokeWidth": 3,
            "transformArgs": {
              "secs": 60
            }
          },
          {
            "id": 4,
            "axis": null,
            "text": "W/Kg",
            "color": "#000000FF",
            "extras": [],
            "legend": true,
            "stream": "WKg",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": {
              "secs": 60
            }
          },
          {
            "id": 5,
            "axis": null,
            "text": "HR 5s",
            "color": "#dd0447",
            "extras": [],
            "legend": true,
            "stream": "raw_heartrate",
            "transform": "moving_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 5
            }
          }
        ],
        "title": null,
        "height": 90,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "power",
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 18,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-02-28T08:09:55.096+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 453362,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "AeroPoint/Kg",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "AeroPointKg",
        "icon": "airplanemode_active",
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "((activity.average_speed)/(activity.icu_average_watts/activity.icu_weight))*20",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".1f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "AeroPoint/Kg"
      },
      "usage_count": 10,
      "index": 19,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T09:38:52.365+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504066,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Stress",
      "description": "Stress day + avg7days trend chart",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/79ae592d-6fbf-4576-bbbd-e05934c6fe11",
      "content": {
        "id": "2g52vseb",
        "name": "Stress",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": 1,
            "band": 0,
            "fill": "#000000FF",
            "text": "Stress",
            "type": "dot",
            "field": "stress",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Stress",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#34ACE4FF",
                "text": "LOW",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#16BB16FF",
                "text": "AVERAGE",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#FFB000FF",
                "text": "HIGH",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#FF520EFF",
                "text": "EXTREME",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Stress",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Stress",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": 1,
            "band": 0,
            "fill": "rgba(140,86,75,0.4)",
            "text": "Stress 7d",
            "type": "line",
            "field": "stress",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Stress",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Stress",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Stress",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Stress",
        "height": 165,
        "yAxisMax": 4.5,
        "yAxisMin": 0.5,
        "y2AxisMax": 4.5,
        "y2AxisMin": 0.5,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Stress",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 16,
      "index": 19,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:19:17.493+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 579751,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "5m Power",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "5m Power",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "5m Power",
            "color": "#6633cc",
            "extras": [],
            "legend": true,
            "stream": "watts_30s",
            "transform": "moving_avg",
            "areaOpacity": 1,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 300
            }
          },
          {
            "id": 2,
            "axis": null,
            "text": "5m Power",
            "color": "#6633cc",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 0.5,
            "transformArgs": {
              "secs": 300
            }
          },
          {
            "id": 3,
            "axis": null,
            "text": "5m W/Kg",
            "color": "#1F77B4",
            "extras": [],
            "legend": true,
            "stream": "WKg",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 0,
            "transformArgs": {
              "secs": 300
            }
          }
        ],
        "title": null,
        "height": 60,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 19,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-02-28T08:09:19.635+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 514516,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Motivation",
      "description": "Motivation day + avg7days trend chart",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/3ab1d5de-73ff-4e6e-b08e-27111123756c",
      "content": {
        "id": "ig0w4t7p",
        "name": "Motivation",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": 1,
            "band": 0,
            "fill": "#000000FF",
            "text": "Motivation",
            "type": "dot",
            "field": "motivation",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Motivation",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#34ACE4FF",
                "text": "EXTREME",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#16BB16FF",
                "text": "HIGH",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#FFB000FF",
                "text": "AVERAGE",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#FF520EFF",
                "text": "LOW",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Motivation",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Motivation",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": 1,
            "band": 0,
            "fill": "rgba(23,190,207, 0.3)",
            "text": "Motivation",
            "type": "line",
            "field": "motivation",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Motivation",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Motivation",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Motivation",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Motivation",
        "height": 165,
        "yAxisMax": 4.5,
        "yAxisMin": 0.5,
        "y2AxisMax": 4.5,
        "y2AxisMin": 0.5,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Motivation",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 6,
      "index": 20,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-29T18:38:01.247+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 603910,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Peak 5s",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Peak5s",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nicu.powerCurve.getWatts(5)\n}",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Peak 5s"
      },
      "usage_count": 1,
      "index": 20,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-26T10:36:24.961+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 658956,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "FOLLOWERS",
      "name": "SURGES",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "SURGES",
        "plots": [
          {
            "id": 1,
            "axis": "watts",
            "text": "Power 3s",
            "color": "#FF00FFFF",
            "extras": [
              {
                "id": 1,
                "y1": 1500,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1500",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 2,
                "y1": 1400,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1400",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 3,
                "y1": 1300,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1300",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 4,
                "y1": 1200,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1200",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 5,
                "y1": 1100,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1100",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 6,
                "y1": 1000,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1000",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 7,
                "y1": 900,
                "y2": 1,
                "fill": "#009E0000",
                "text": "900",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 8,
                "y1": 800,
                "y2": 1,
                "fill": "#009E0000",
                "text": "800",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 9,
                "y1": 700,
                "y2": 1,
                "fill": "#009E0000",
                "text": "700",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 10,
                "y1": 600,
                "y2": 1,
                "fill": "#009E0000",
                "text": "600",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 11,
                "y1": 500,
                "y2": 1,
                "fill": "#009E0000",
                "text": "500",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 12,
                "y1": 400,
                "y2": 1,
                "fill": "#009E0000",
                "text": "400",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              }
            ],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "strokeWidth": 1.01,
            "transformArgs": {
              "secs": 3
            }
          },
          {
            "id": 2,
            "axis": null,
            "text": "Power 5s",
            "color": "#648FFFFF",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "transformArgs": {
              "secs": 5
            }
          }
        ],
        "title": null,
        "height": 270,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 1,
      "index": 20,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T12:02:42.148+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 692550,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "3' efforts bar",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "250px",
        "script": "(function() {\n  const CONFIG = {\n    // CONFIGURAZIONE PRINCIPALE\n    // ============================================================================\n    DURATION: 180,                    // Durata finestra sforzo (secondi)\n    MIN_EFFORT_INTENSITY_FTP: 100,    // Soglia minima effort (% FTP)\n    // ============================================================================\n    // Ordinamento barre possibile su (valori stringa):\n    // 'avgPower', 'avgPowerPerKg', 'avgHR', 'maxHR', 'startTime', 'bestStart',\n    // 'dist', 'distKm', 'elevationGain', 'avgGrade', 'maxGrade',\n    // 'rat_1', 'rat_2', 'ratio', 'ascentSpeed', 'avgHorizontalSpeed',\n    // 'best5sWatts', 'best5sPerKg', 'TEORICWKG', 'TEORICVAM'\n    SORT_BY: 'avgPower',\n    BAR_TEXT_COLOR: '#000',                // Colore testo barre\n    BAR_TEXT_FONT: { family: 'Arial Black', size: 13 }, // Font testo barre\n    GRID_X_COLOR: '#eee',                  // Colore griglia X\n    GRID_X_WIDTH: 1,                       // Spessore griglia X\n    GRID_Y_COLOR: '#ccc',                  // Colore griglia Y\n    GRID_Y_WIDTH: 1,                       // Spessore griglia Y\n    VISIBLE_BARS: 7,                 // Numero barre visibili nel grafico\n\n    ZONES: [\n      { name: 'Z2', max: 76, color: '#4c72b0' },\n      { name: 'Z3', max: 91, color: '#55a868' },\n      { name: 'Z4', max: 106, color: '#dd8452' },\n      { name: 'Z5', max: 126, color: '#c44e52' },\n      { name: 'Z6', max: 151, color: '#a64d79' },\n      { name: 'Z7', max: Infinity, color: '#8172b3' }\n    ]\n  };\n// =====================\n// FINE CONFIGURAZIONE\n// =====================\n\n// =====================\n// LAYOUT GRAFICO\n// =====================\nconst LAYOUT = {\n  title: '',\n  barmode: 'group',\n  showlegend: false,\n  height: 250,\n  margin: {l: 40, r: 20, t: 40, b: 40},\n  xaxis: {\n    title: 'Effort',\n    range: [0, CONFIG.VISIBLE_BARS - 0.5],\n    fixedrange: false,\n    autorange: false,\n    tickmode: 'linear',\n    tick0: 1,\n    dtick: 1,\n    showgrid: true,\n    gridcolor: CONFIG.GRID_X_COLOR,\n    gridwidth: CONFIG.GRID_X_WIDTH,\n    scrollZoom: true\n  },\n  yaxis: {\n    title: 'Avg Power (W)',\n    dtick: 50,\n    gridcolor: CONFIG.GRID_Y_COLOR,\n    gridwidth: CONFIG.GRID_Y_WIDTH\n  }\n};\n\n// =====================\n// DATI ATTIVIT\n// =====================\nconst activity = icu.activity;\nconst weight = activity.icu_weight;\nconst FTP = activity.icu_ftp;\n\nfunction getStreamData(streamName) {\n  const stream = icu.streams.get(streamName);\n  return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\nconst power = getStreamData(\"fixed_watts\");\n\n// Trova tutti gli sforzi non sovrapposti sopra una certa soglia\nfunction getNonOverlappingEffortsAboveThreshold(data, n, threshold, samplingRate = 1) {\n  const windowSize = n * samplingRate;\n  let results = [];\n  if (data.length < windowSize) return results;\n  let sum = data.slice(0, windowSize).reduce((a, b) => a + b, 0);\n  let candidates = [];\n  if (sum / windowSize >= threshold) {\n    candidates.push({ avg: sum / windowSize, start: 0 });\n  }\n  for (let i = 1; i <= data.length - windowSize; i++) {\n    sum = sum - data[i - 1] + data[i + windowSize - 1];\n    const avg = sum / windowSize;\n    if (avg >= threshold) {\n      candidates.push({ avg, start: i });\n    }\n  }\n  candidates.sort((a, b) => b.avg - a.avg);\n  let used = Array(data.length).fill(false);\n  for (const cand of candidates) {\n    let overlap = false;\n    for (let j = cand.start; j < cand.start + windowSize; j++) {\n      if (used[j]) {\n        overlap = true;\n        break;\n      }\n    }\n    if (!overlap) {\n      results.push(cand);\n      for (let j = cand.start; j < cand.start + windowSize; j++) {\n        used[j] = true;\n      }\n    }\n  }\n  results.sort((a, b) => a.start - b.start);\n  return results;\n}\n\n\n\nlet x = [];\nlet y = [];\nlet hover = [];\nlet effortData = [];\nconst heartrate = getStreamData(\"fixed_heartrate\");\nconst time = getStreamData(\"time\");\nconst distance = getStreamData(\"distance\");\nconst altitude = getStreamData(\"fixed_altitude\");\nconst grade = getStreamData(\"grade_smooth\");\n\nfunction secondsToHms(seconds) {\n  seconds = Math.floor(seconds);\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds % 3600) / 60);\n  const s = seconds % 60;\n  let str = '';\n  if (h > 0) str += String(h).padStart(2, '0') + ':';\n  str += (h > 0 ? String(m).padStart(2, '0') : m) + ':' + String(s).padStart(2, '0');\n  return str;\n}\n\n// Soglia in watt (da percentuale FTP)\nconst threshold = (CONFIG.MIN_EFFORT_INTENSITY_FTP / 100) * FTP;\n\n\nconst allEfforts = getNonOverlappingEffortsAboveThreshold(\n  power,\n  CONFIG.DURATION,\n  threshold,\n  1\n);\nfor (const [idx, best] of allEfforts.entries()) {\n  const bestStart = best.start;\n  const bestEnd = bestStart + CONFIG.DURATION;\n  const sectionHR = heartrate.slice(bestStart, bestEnd);\n  const sectionDistance = distance.slice(bestStart, bestEnd);\n  const sectionAltitude = altitude.slice(bestStart, bestEnd);\n  const sectionGrade = grade.slice(bestStart, bestEnd);\n  const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n  const maxHR = Math.max(...sectionHR);\n  const startTime = secondsToHms(time[bestStart]);\n  const avgPower = best.avg;\n  const avgPowerPerKg = avgPower / weight;\n  const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n  const distKm = dist / 1000;\n  const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n  const avgGrade = dist > 0 ? (elevationGain / dist * 100) : 0;\n  const maxGrade = Math.max(...sectionGrade);\n  // Ratio: prima met, seconda met, ratio\n  const firstHalf = power.slice(bestStart, bestStart + CONFIG.DURATION/2);\n  const secondHalf = power.slice(bestStart + CONFIG.DURATION/2, bestEnd);\n  const rat_1 = firstHalf.reduce((a,b)=>a+b,0)/firstHalf.length;\n  const rat_2 = secondHalf.reduce((a,b)=>a+b,0)/secondHalf.length;\n  const ratio = rat_2 / rat_1;\n  // VAM\n  const climbTimeH = CONFIG.DURATION / 3600;\n  const ascentSpeed = elevationGain / climbTimeH;\n  const avgHorizontalSpeed = distKm / (CONFIG.DURATION / 3600);\n  // Best 5s\n  let best5sWatts = 0;\n  for (let i = 0; i <= power.slice(bestStart, bestEnd).length - 5; i++) {\n    const avg5 = power.slice(bestStart + i, bestStart + i + 5).reduce((a,b)=>a+b,0)/5;\n    if (avg5 > best5sWatts) best5sWatts = avg5;\n  }\n  const best5sPerKg = best5sWatts / weight;\n  // Teorici (come in PIAN HC)\n  const gradientFactor = (2 + avgGrade / 10) * 100;\n  const TEORICWKG = ascentSpeed / gradientFactor;\n  const TEORICVAM = avgPowerPerKg * gradientFactor;\n  effortData.push({\n    idx,\n    avgPower,\n    avgPowerPerKg,\n    avgHR,\n    maxHR,\n    startTime,\n    bestStart,\n    dist,\n    distKm,\n    elevationGain,\n    avgGrade,\n    maxGrade,\n    rat_1,\n    rat_2,\n    ratio,\n    ascentSpeed,\n    avgHorizontalSpeed,\n    best5sWatts,\n    best5sPerKg,\n    TEORICWKG,\n    TEORICVAM\n  });\n}\n\n// Ordina effort secondo la propriet scelta in config\neffortData.sort((a, b) => b[CONFIG.SORT_BY] - a[CONFIG.SORT_BY]);\nfor (const [i, effort] of effortData.entries()) {\n  x.push(`${i+1}`);\n  y.push(effort.avgPower);\n  hover.push(\n    ` ${(effort.dist / 1000).toFixed(2)} km (${effort.elevationGain.toFixed(0)} m)<br>`+\n    `  ${effort.avgGrade.toFixed(1)}% | max. ${effort.maxGrade.toFixed(1)}%<br>`+\n    ` ${effort.avgPower.toFixed(0)} W | 5 ${effort.best5sWatts.toFixed(0)} W<br>`+\n    ` ${effort.avgPowerPerKg.toFixed(2)} W/kg | 5 ${effort.best5sPerKg.toFixed(2)} W/kg<br>`+\n    ` ${effort.rat_1.toFixed(0)} W | ${effort.rat_2.toFixed(0)} W | ${(effort.ratio).toFixed(2)}<br>`+\n    `  ${effort.avgHR.toFixed(0)} bpm | max. ${effort.maxHR} bpm<br>`+\n    ` ${effort.avgHorizontalSpeed.toFixed(1)} km/h |  ${effort.ascentSpeed.toFixed(0)} m/h<br>`+\n    ` ${effort.startTime}`\n  );\n}\n\n\n\n// Restituisce il colore HEX della zona in base alla % FTP, usando la config\nfunction getZoneColor(avgPower, ftp) {\n  const percentage = (avgPower / ftp) * 100;\n  for (const zone of CONFIG.ZONES) {\n    if (percentage < zone.max) return zone.color;\n  }\n  // fallback (non dovrebbe mai servire)\n  return '#000';\n}\n\nconst barColors = y.map((v) => getZoneColor(v, FTP));\n\n\nconst data = [\n  {\n    x: x,\n    y: y,\n    type: 'bar',\n    marker: {\n      color: barColors\n    },\n    text: x.map((label, i) =>\n      `${y[i].toFixed(0)} W | ${effortData[i].avgPowerPerKg.toFixed(2)} W/kg<br>`\n      + `${effortData[i].rat_1.toFixed(0)} W | ${effortData[i].rat_2.toFixed(0)} W | ${effortData[i].ratio.toFixed(2)}<br>`\n      + ` ${effortData[i].avgHR.toFixed(0)} bpm | ${effortData[i].maxHR} bpm<br>`\n      + `${effortData[i].ascentSpeed.toFixed(0)} m/h |  ${effortData[i].avgGrade.toFixed(1)}%<br>`\n      + `${effortData[i].startTime}`\n    ),\n    textposition: 'inside',\n    insidetextanchor: 'start',\n    textfont: {\n      color: CONFIG.BAR_TEXT_COLOR,\n      size: CONFIG.BAR_TEXT_FONT.size,\n      family: CONFIG.BAR_TEXT_FONT.family\n    },\n    hoverinfo: 'text',\n    hovertext: hover,\n    hoverlabel: { font: { color: CONFIG.BAR_TEXT_COLOR, family: CONFIG.BAR_TEXT_FONT.family, size: CONFIG.BAR_TEXT_FONT.size }, align: 'left' },\n    name: 'Avg Power',\n    visible: true\n  }\n];\n\n\n\n// Aggiorna dinamicamente titolo e range xaxis in base alla config\nconst minEffort = CONFIG.MIN_EFFORT_INTENSITY_FTP;\nconst duration = CONFIG.DURATION;\nconst durationMin = duration % 60 === 0 ? (duration/60) + '' : duration + 's';\nLAYOUT.title = `${durationMin} efforts (>${minEffort}% FTP)`;\nLAYOUT.xaxis.range = [0, CONFIG.VISIBLE_BARS - 0.5];\n\nreturn { data: data, layout: LAYOUT };\n})();",
        "name": "3' efforts bar"
      },
      "usage_count": 0,
      "index": 20,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-23T06:04:33.731+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504067,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Mood",
      "description": "Mood day + avg7days trend chart",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/90d71ccb-2bbb-460b-928c-d7a104042c0d",
      "content": {
        "id": "9i6k0ats",
        "name": "Mood",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": 1,
            "band": 0,
            "fill": "#000000FF",
            "text": "Mood",
            "type": "dot",
            "field": "mood",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Mood",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#34ACE4FF",
                "text": "GREAT",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#16BB16FF",
                "text": "GOOD",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#FFB000FF",
                "text": "OK",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#FF520EFF",
                "text": "GRUMPY",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Mood",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Mood",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": 1,
            "band": 0,
            "fill": "rgba(255,0,255, 0.4)",
            "text": "Mood 7d",
            "type": "line",
            "field": "mood",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Mood",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Mood",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Mood",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Mood",
        "height": 165,
        "yAxisMax": 4.5,
        "yAxisMin": 0.5,
        "y2AxisMax": 4.5,
        "y2AxisMin": 0.5,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Mood",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 11,
      "index": 21,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:19:27.908+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 603911,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Peak 15s",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Peak15s",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nicu.powerCurve.getWatts(15)\n}",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Peak 15s"
      },
      "usage_count": 1,
      "index": 21,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-26T10:35:33.862+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 662589,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "SURGES20",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "SURGES20",
        "plots": [
          {
            "id": 1,
            "axis": "watts",
            "text": "Power 20s",
            "color": "#FF00FFFF",
            "extras": [
              {
                "id": 1,
                "y1": 1500,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1500",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 2,
                "y1": 1400,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1400",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 3,
                "y1": 1300,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1300",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 4,
                "y1": 1200,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1200",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 5,
                "y1": 1100,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1100",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 6,
                "y1": 1000,
                "y2": 1,
                "fill": "#009E0000",
                "text": "1000",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 7,
                "y1": 900,
                "y2": 1,
                "fill": "#009E0000",
                "text": "900",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 8,
                "y1": 800,
                "y2": 1,
                "fill": "#009E0000",
                "text": "800",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 9,
                "y1": 700,
                "y2": 1,
                "fill": "#009E0000",
                "text": "700",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 10,
                "y1": 600,
                "y2": 1,
                "fill": "#009E0000",
                "text": "600",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 11,
                "y1": 500,
                "y2": 1,
                "fill": "#009E0000",
                "text": "500",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 12,
                "y1": 400,
                "y2": 1,
                "fill": "#009E0000",
                "text": "400",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 1
              },
              {
                "id": 13,
                "y1": 300,
                "y2": 1,
                "fill": "#009E0000",
                "text": "300",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333FF",
                "opacity": 0.3
              }
            ],
            "legend": true,
            "stream": "watts",
            "transform": "moving_avg",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "strokeWidth": 1.01,
            "transformArgs": {
              "secs": 20
            }
          }
        ],
        "title": null,
        "height": 270,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 21,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-26T14:29:07.118+00:00",
      "from_athlete": {
        "id": "i180702",
        "name": "campanella",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/f458629b-7f60-4554-bf9f-c5e5b88bc1a3",
        "city": "Trento",
        "state": "Trentino",
        "country": "Italy",
        "timezone": "Europe/Rome",
        "sex": "F",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 660386
    },
    {
      "id": 692558,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "4' efforts bar",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "250px",
        "script": "// Bar chart for best 5 efforts (4 minutes)\nconst DURATION_4mbar = 240;\nconst TOP_N_4mbar = 5;\nconst LABEL_4mbar = \"4'\";\nconst activity_4mbar = icu.activity;\nconst weight_4mbar = activity_4mbar.icu_weight;\n\nfunction getStreamData_4mbar(streamName) {\n    const stream = icu.streams.get(streamName);\n    return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\nconst power_4mbar = getStreamData_4mbar(\"fixed_watts\");\n\nfunction getTopNBestAveragesOverNSeconds_4mbar(data, n, topN = 5, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let results = [];\n    let sum = 0;\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    results.push({ avg: sum / windowSize, start: 0 });\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        results.push({ avg, start: i });\n    }\n    results.sort((a, b) => b.avg - a.avg);\n    let nonOverlapping = [];\n    for (let i = 0; i < results.length && nonOverlapping.length < topN; i++) {\n        if (nonOverlapping.every(r => Math.abs(r.start - results[i].start) >= windowSize)) {\n            nonOverlapping.push(results[i]);\n        }\n    }\n    return nonOverlapping;\n}\n\nlet x_4mbar = [];\nlet y_4mbar = [];\nlet hover_4mbar = [];\nlet effortData_4mbar = [];\nconst heartrate_4mbar = getStreamData_4mbar(\"fixed_heartrate\");\nconst time_4mbar = getStreamData_4mbar(\"time\");\nconst distance_4mbar = getStreamData_4mbar(\"distance\");\nconst altitude_4mbar = getStreamData_4mbar(\"fixed_altitude\");\nconst grade_4mbar = getStreamData_4mbar(\"grade_smooth\");\nfunction secondsToHms_4mbar(seconds) {\n    seconds = Math.floor(seconds);\n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = seconds % 60;\n    let str = '';\n    if (h > 0) str += String(h).padStart(2, '0') + ':';\n    str += (h > 0 ? String(m).padStart(2, '0') : m) + ':' + String(s).padStart(2, '0');\n    return str;\n}\nfor (const [idx, best] of getTopNBestAveragesOverNSeconds_4mbar(power_4mbar, DURATION_4mbar, TOP_N_4mbar, 1).entries()) {\n    const bestStart = best.start;\n    const bestEnd = bestStart + DURATION_4mbar;\n    const sectionHR = heartrate_4mbar.slice(bestStart, bestEnd);\n    const sectionDistance = distance_4mbar.slice(bestStart, bestEnd);\n    const sectionAltitude = altitude_4mbar.slice(bestStart, bestEnd);\n    const sectionGrade = grade_4mbar.slice(bestStart, bestEnd);\n    const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n    const maxHR = Math.max(...sectionHR);\n    const startTime = secondsToHms_4mbar(time_4mbar[bestStart]);\n    const avgPower = best.avg;\n    const avgPowerPerKg = avgPower / weight_4mbar;\n    const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n    const distKm = dist / 1000;\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const avgGrade = elevationGain / dist * 100;\n    const maxGrade = Math.max(...sectionGrade);\n    // Ratio: prima met, seconda met, ratio\n    const firstHalf = power_4mbar.slice(bestStart, bestStart + DURATION_4mbar/2);\n    const secondHalf = power_4mbar.slice(bestStart + DURATION_4mbar/2, bestEnd);\n    const rat_1 = firstHalf.reduce((a,b)=>a+b,0)/firstHalf.length;\n    const rat_2 = secondHalf.reduce((a,b)=>a+b,0)/secondHalf.length;\n    const ratio = rat_2 / rat_1;\n    // VAM\n    const climbTimeH = DURATION_4mbar / 3600;\n    const ascentSpeed = elevationGain / climbTimeH;\n    const avgHorizontalSpeed = distKm / (DURATION_4mbar / 3600);\n    // Best 5s\n    let best5sWatts = 0;\n    for (let i = 0; i <= power_4mbar.slice(bestStart, bestEnd).length - 5; i++) {\n        const avg5 = power_4mbar.slice(bestStart + i, bestStart + i + 5).reduce((a,b)=>a+b,0)/5;\n        if (avg5 > best5sWatts) best5sWatts = avg5;\n    }\n    const best5sPerKg = best5sWatts / weight_4mbar;\n    // Teorici (come in PIAN HC)\n    const gradientFactor = (2 + avgGrade / 10) * 100;\n    const TEORICWKG = ascentSpeed / gradientFactor;\n    const TEORICVAM = avgPowerPerKg * gradientFactor;\n    effortData_4mbar.push({\n        idx,\n        avgPower,\n        avgPowerPerKg,\n        avgHR,\n        maxHR,\n        startTime,\n        bestStart,\n        dist,\n        distKm,\n        elevationGain,\n        avgGrade,\n        maxGrade,\n        rat_1,\n        rat_2,\n        ratio,\n        ascentSpeed,\n        avgHorizontalSpeed,\n        best5sWatts,\n        best5sPerKg,\n        TEORICWKG,\n        TEORICVAM\n    });\n}\n// Ordina per tempo di inizio (bestStart)\neffortData_4mbar.sort((a, b) => a.bestStart - b.bestStart);\nfor (const [i, effort] of effortData_4mbar.entries()) {\n    x_4mbar.push(`${i+1}`); // Solo Effort 1, Effort 2, ...\n    y_4mbar.push(effort.avgPower);\n    hover_4mbar.push(\n        ` ${(effort.dist / 1000).toFixed(2)} km (${effort.elevationGain.toFixed(0)} m)<br>`+\n        `  ${effort.avgGrade.toFixed(1)}% | max. ${effort.maxGrade.toFixed(1)}%<br>`+\n        ` ${effort.avgPower.toFixed(0)} W | 5 ${effort.best5sWatts.toFixed(0)} W<br>`+\n        ` ${effort.avgPowerPerKg.toFixed(2)} W/kg | 5 ${effort.best5sPerKg.toFixed(2)} W/kg<br>`+\n        ` ${effort.rat_1.toFixed(0)} W | ${effort.rat_2.toFixed(0)} W | ${(effort.ratio).toFixed(2)}<br>`+\n        `  ${effort.avgHR.toFixed(0)} bpm | max. ${effort.maxHR} bpm<br>`+\n        ` ${effort.avgHorizontalSpeed.toFixed(1)} km/h |  ${effort.ascentSpeed.toFixed(0)} m/h<br>`+\n        ` ${effort.TEORICWKG.toFixed(2)} W/kg | ${effort.TEORICVAM.toFixed(0)} VAM`+\n        `<br> ${effort.startTime}`\n    );\n}\n\nconst FTP_4mbar = activity_4mbar.icu_ftp;\nfunction getZoneColor_4mbar(avgPower, ftp) {\n    const percentage = (avgPower / ftp) * 100;\n\n    if (percentage < 76) return \"4c72b0\";        // Z2\n    if (percentage < 91) return \"55a868\";         // Z3\n    if (percentage < 106) return \"dd8452\";        // Z4 (ex gold, ora come Z3)\n    if (percentage < 121) return \"c44e52\";           // Z5\n    if (percentage < 151) return \"a64d79\";        // Z6\n    return \"8172b3\";                                // Z7+;\n}\n\nconst barColors_4mbar = y_4mbar.map((v) => getZoneColor_4mbar(v, FTP_4mbar));\n\n\nconst data_4mbar = [\n  {\n    x: x_4mbar,\n    y: y_4mbar,\n    type: 'bar',\n    marker: {\n      color: barColors_4mbar\n    },\n    text: x_4mbar.map((label, i) =>\n      `${y_4mbar[i].toFixed(0)} W | ${effortData_4mbar[i].avgPowerPerKg.toFixed(2)} W/kg<br>`\n      + `${effortData_4mbar[i].rat_1.toFixed(0)} W | ${effortData_4mbar[i].rat_2.toFixed(0)} W | ${effortData_4mbar[i].ratio.toFixed(2)}<br>`\n      + ` ${effortData_4mbar[i].avgHR.toFixed(0)} bpm | max. ${effortData_4mbar[i].maxHR} bpm<br>`\n      + `${effortData_4mbar[i].ascentSpeed.toFixed(0)} m/h |  ${effortData_4mbar[i].avgGrade.toFixed(1)}%<br>`\n      + `${effortData_4mbar[i].startTime}`\n    ),\n    textposition: 'inside',\n    insidetextanchor: 'start',\n    textfont: {\n      color: '#000',\n      size: 13,\n      family: 'Arial Black'\n    },\n    hoverinfo: 'text',\n    hovertext: hover_4mbar,\n    hoverlabel: { font: { color: '#000', family: 'Arial', size: 13 }, align: 'left' },\n    name: 'Avg Power',\n    visible: true\n  }\n];\n\nconst layout_4mbar = {\n  title: \"4' efforts\",\n  barmode: 'group',\n  showlegend: false,\n  height: 250,\n  margin: {l: 40, r: 20, t: 40, b: 40},\n  xaxis: {title: 'Effort'},\n  yaxis: {\n    title: 'Avg Power (W)',\n    dtick: 50, // Griglia ogni 50 watt\n    gridcolor: '#ccc',\n    gridwidth: 1\n  },\n};\n\nchart = { data: data_4mbar, layout: layout_4mbar };\nchart;",
        "name": "4' efforts bar"
      },
      "usage_count": 0,
      "index": 21,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-03T18:07:44.708+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504084,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Soreness CHR",
      "description": "Soreness trend on 42days and 7days",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/a956d7a6-55d9-4484-867a-b094e6523ce6",
      "content": {
        "id": "tf27f0ap",
        "name": "Soreness CHR",
        "plots": [
          {
            "id": 2,
            "agg": "none",
            "min": 1,
            "band": 0,
            "fill": "#8D824700",
            "text": "Soreness",
            "type": "bars",
            "field": "soreness",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Soreness",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#34ACE4FF",
                "text": "LOW",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#16BB16FF",
                "text": "AVERAGE",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#FFB000FF",
                "text": "HOGH",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#FF520EFF",
                "text": "EXTREME",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Soreness",
            "markerValue": "none",
            "strokeWidth": 1.3,
            "i18nTitleKey": "Soreness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": 1,
            "band": 0,
            "fill": "#50486180",
            "text": "Soreness 7d",
            "type": "line",
            "field": "soreness",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Soreness",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Soreness",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Soreness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "moving_avg",
            "min": 1,
            "band": 0.6,
            "fill": "#50486180",
            "text": "Soreness 42d",
            "type": "line",
            "field": "soreness",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Soreness",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Soreness",
            "markerValue": "right",
            "strokeWidth": 1.8,
            "i18nTitleKey": "Soreness",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Chronic Soreness",
        "height": 165,
        "yAxisMax": 4.5,
        "yAxisMin": 0.5,
        "y2AxisMax": 4.5,
        "y2AxisMin": 0.5,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Soreness",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 1,
      "index": 22,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:20:01.306+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 603912,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Peak 60s",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Peak60s",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nicu.powerCurve.getWatts(60)\n}",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Peak 60s"
      },
      "usage_count": 1,
      "index": 22,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-26T10:36:49.051+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 662640,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "Core Temp with Thresholds",
      "description": "The chart shows the core temp from the Core Body Temperature sensor and visualise it with thresholds. Remember to set the thresholds according to yours.",
      "image": null,
      "content": {
        "id": null,
        "name": "Core Temp with Thresholds",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "Core Temp",
            "color": "#666666FF",
            "extras": [
              {
                "id": 1,
                "y1": 0,
                "y2": 36.5,
                "fill": "#34ACE466",
                "text": "Cool zone",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.2
              },
              {
                "id": 2,
                "y1": 36.5,
                "y2": 37.4,
                "fill": "#FF00FFFF",
                "text": "Low activity",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00FF",
                "opacity": 0.3
              },
              {
                "id": 3,
                "y1": 37.4,
                "y2": 38,
                "fill": "#009E0080",
                "text": "Moderate activity",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.3
              },
              {
                "id": 4,
                "y1": 38,
                "y2": 38.4,
                "fill": "#504861FF",
                "text": "Workout zone",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.3
              },
              {
                "id": 5,
                "y1": 38.4,
                "y2": 38.6,
                "fill": "#FFCB0EFF",
                "text": "Heat training",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.3
              },
              {
                "id": 6,
                "y1": 38.6,
                "y2": 42,
                "fill": "#D62728FF",
                "text": "Red zone",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#009E00",
                "opacity": 0.3
              }
            ],
            "legend": true,
            "stream": "core_temperature",
            "transform": "none",
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 120
            }
          }
        ],
        "title": null,
        "height": 120,
        "yAxisMax": 39.3,
        "yAxisMin": 36.0,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 22,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-26T14:54:15.946+00:00",
      "from_athlete": {
        "id": "169405",
        "name": "Benjamin Hendler",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/21d0156e-c630-4dec-8427-a2cc37af7bff",
        "city": "Stockholm",
        "state": "",
        "country": "Sverige",
        "timezone": "Europe/Stockholm",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 111428
    },
    {
      "id": 692559,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "5' efforts bar",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "250px",
        "script": "// Bar chart for best 5 efforts (5 minutes)\nconst DURATION_5mbar = 300;\nconst TOP_N_5mbar = 5;\nconst LABEL_5mbar = \"5'\";\nconst activity_5mbar = icu.activity;\nconst weight_5mbar = activity_5mbar.icu_weight;\n\nfunction getStreamData_5mbar(streamName) {\n    const stream = icu.streams.get(streamName);\n    return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\nconst power_5mbar = getStreamData_5mbar(\"fixed_watts\");\n\nfunction getTopNBestAveragesOverNSeconds_5mbar(data, n, topN = 5, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let results = [];\n    let sum = 0;\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    results.push({ avg: sum / windowSize, start: 0 });\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        results.push({ avg, start: i });\n    }\n    results.sort((a, b) => b.avg - a.avg);\n    let nonOverlapping = [];\n    for (let i = 0; i < results.length && nonOverlapping.length < topN; i++) {\n        if (nonOverlapping.every(r => Math.abs(r.start - results[i].start) >= windowSize)) {\n            nonOverlapping.push(results[i]);\n        }\n    }\n    return nonOverlapping;\n}\n\nlet x_5mbar = [];\nlet y_5mbar = [];\nlet hover_5mbar = [];\nlet effortData_5mbar = [];\nconst heartrate_5mbar = getStreamData_5mbar(\"fixed_heartrate\");\nconst time_5mbar = getStreamData_5mbar(\"time\");\nconst distance_5mbar = getStreamData_5mbar(\"distance\");\nconst altitude_5mbar = getStreamData_5mbar(\"fixed_altitude\");\nconst grade_5mbar = getStreamData_5mbar(\"grade_smooth\");\nfunction secondsToHms_5mbar(seconds) {\n    seconds = Math.floor(seconds);\n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = seconds % 60;\n    let str = '';\n    if (h > 0) str += String(h).padStart(2, '0') + ':';\n    str += (h > 0 ? String(m).padStart(2, '0') : m) + ':' + String(s).padStart(2, '0');\n    return str;\n}\nfor (const [idx, best] of getTopNBestAveragesOverNSeconds_5mbar(power_5mbar, DURATION_5mbar, TOP_N_5mbar, 1).entries()) {\n    const bestStart = best.start;\n    const bestEnd = bestStart + DURATION_5mbar;\n    const sectionHR = heartrate_5mbar.slice(bestStart, bestEnd);\n    const sectionDistance = distance_5mbar.slice(bestStart, bestEnd);\n    const sectionAltitude = altitude_5mbar.slice(bestStart, bestEnd);\n    const sectionGrade = grade_5mbar.slice(bestStart, bestEnd);\n    const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n    const maxHR = Math.max(...sectionHR);\n    const startTime = secondsToHms_5mbar(time_5mbar[bestStart]);\n    const avgPower = best.avg;\n    const avgPowerPerKg = avgPower / weight_5mbar;\n    const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n    const distKm = dist / 1000;\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const avgGrade = elevationGain / dist * 100;\n    const maxGrade = Math.max(...sectionGrade);\n    // Ratio: prima met, seconda met, ratio\n    const firstHalf = power_5mbar.slice(bestStart, bestStart + DURATION_5mbar/2);\n    const secondHalf = power_5mbar.slice(bestStart + DURATION_5mbar/2, bestEnd);\n    const rat_1 = firstHalf.reduce((a,b)=>a+b,0)/firstHalf.length;\n    const rat_2 = secondHalf.reduce((a,b)=>a+b,0)/secondHalf.length;\n    const ratio = rat_2 / rat_1;\n    // VAM\n    const climbTimeH = DURATION_5mbar / 3600;\n    const ascentSpeed = elevationGain / climbTimeH;\n    const avgHorizontalSpeed = distKm / (DURATION_5mbar / 3600);\n    // Best 5s\n    let best5sWatts = 0;\n    for (let i = 0; i <= power_5mbar.slice(bestStart, bestEnd).length - 5; i++) {\n        const avg5 = power_5mbar.slice(bestStart + i, bestStart + i + 5).reduce((a,b)=>a+b,0)/5;\n        if (avg5 > best5sWatts) best5sWatts = avg5;\n    }\n    const best5sPerKg = best5sWatts / weight_5mbar;\n    // Teorici (come in PIAN HC)\n    const gradientFactor = (2 + avgGrade / 10) * 100;\n    const TEORICWKG = ascentSpeed / gradientFactor;\n    const TEORICVAM = avgPowerPerKg * gradientFactor;\n    effortData_5mbar.push({\n        idx,\n        avgPower,\n        avgPowerPerKg,\n        avgHR,\n        maxHR,\n        startTime,\n        bestStart,\n        dist,\n        distKm,\n        elevationGain,\n        avgGrade,\n        maxGrade,\n        rat_1,\n        rat_2,\n        ratio,\n        ascentSpeed,\n        avgHorizontalSpeed,\n        best5sWatts,\n        best5sPerKg,\n        TEORICWKG,\n        TEORICVAM\n    });\n}\n// Ordina per tempo di inizio (bestStart)\neffortData_5mbar.sort((a, b) => a.bestStart - b.bestStart);\nfor (const [i, effort] of effortData_5mbar.entries()) {\n    x_5mbar.push(`${i+1}`); // Solo Effort 1, Effort 2, ...\n    y_5mbar.push(effort.avgPower);\n    hover_5mbar.push(\n        ` ${(effort.dist / 1000).toFixed(2)} km (${effort.elevationGain.toFixed(0)} m)<br>`+\n        `  ${effort.avgGrade.toFixed(1)}% | max. ${effort.maxGrade.toFixed(1)}%<br>`+\n        ` ${effort.avgPower.toFixed(0)} W | 5 ${effort.best5sWatts.toFixed(0)} W<br>`+\n        ` ${effort.avgPowerPerKg.toFixed(2)} W/kg | 5 ${effort.best5sPerKg.toFixed(2)} W/kg<br>`+\n        ` ${effort.rat_1.toFixed(0)} W | ${effort.rat_2.toFixed(0)} W | ${(effort.ratio).toFixed(2)}<br>`+\n        `  ${effort.avgHR.toFixed(0)} bpm | max. ${effort.maxHR} bpm<br>`+\n        ` ${effort.avgHorizontalSpeed.toFixed(1)} km/h |  ${effort.ascentSpeed.toFixed(0)} m/h<br>`+\n        ` ${effort.TEORICWKG.toFixed(2)} W/kg | ${effort.TEORICVAM.toFixed(0)} VAM`+\n        `<br> ${effort.startTime}`\n    );\n}\n\nconst FTP_5mbar = activity_5mbar.icu_ftp;\nfunction getZoneColor_5mbar(avgPower, ftp) {\n    const percentage = (avgPower / ftp) * 100;\n\n    if (percentage < 76) return \"4c72b0\";        // Z2\n    if (percentage < 91) return \"55a868\";         // Z3\n    if (percentage < 106) return \"dd8452\";        // Z4 (ex gold, ora come Z3)\n    if (percentage < 121) return \"c44e52\";           // Z5\n    if (percentage < 151) return \"a64d79\";        // Z6\n    return \"8172b3\";                                // Z7+;\n}\n\nconst barColors_5mbar = y_5mbar.map((v) => getZoneColor_5mbar(v, FTP_5mbar));\n\n\nconst data_5mbar = [\n  {\n    x: x_5mbar,\n    y: y_5mbar,\n    type: 'bar',\n    marker: {\n      color: barColors_5mbar\n    },\n    text: x_5mbar.map((label, i) =>\n      `${y_5mbar[i].toFixed(0)} W | ${effortData_5mbar[i].avgPowerPerKg.toFixed(2)} W/kg<br>`\n      + `${effortData_5mbar[i].rat_1.toFixed(0)} W | ${effortData_5mbar[i].rat_2.toFixed(0)} W | ${effortData_5mbar[i].ratio.toFixed(2)}<br>`\n      + ` ${effortData_5mbar[i].avgHR.toFixed(0)} bpm | max. ${effortData_5mbar[i].maxHR} bpm<br>`\n      + `${effortData_5mbar[i].ascentSpeed.toFixed(0)} m/h |  ${effortData_5mbar[i].avgGrade.toFixed(1)}%<br>`\n      + `${effortData_5mbar[i].startTime}`\n    ),\n    textposition: 'inside',\n    insidetextanchor: 'start',\n    textfont: {\n      color: '#000',\n      size: 13,\n      family: 'Arial Black'\n    },\n    hoverinfo: 'text',\n    hovertext: hover_5mbar,\n    hoverlabel: { font: { color: '#000', family: 'Arial', size: 13 }, align: 'left' },\n    name: 'Avg Power',\n    visible: true\n  }\n];\n\nconst layout_5mbar = {\n  title: \"5' efforts\",\n  barmode: 'group',\n  showlegend: false,\n  height: 250,\n  margin: {l: 40, r: 20, t: 40, b: 40},\n  xaxis: {title: 'Effort'},\n  yaxis: {\n    title: 'Avg Power (W)',\n    dtick: 50, // Griglia ogni 50 watt\n    gridcolor: '#ccc',\n    gridwidth: 1\n  },\n};\n\nchart = { data: data_5mbar, layout: layout_5mbar };\nchart;",
        "name": "5' efforts bar"
      },
      "usage_count": 0,
      "index": 22,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-03T18:07:57.123+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504085,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Fatigue CHR",
      "description": "Fatigue trend on 42days and 7days",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/1cce3ac6-eae3-422d-aa57-f129160350d8",
      "content": {
        "id": "4tf4ax8s",
        "name": "Fatigue CHR",
        "plots": [
          {
            "id": 2,
            "agg": "none",
            "min": 1,
            "band": 0,
            "fill": "#8D824700",
            "text": "Subj Fatigue",
            "type": "bars",
            "field": "wellness_fatigue",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Subjective fatigue",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#34ACE4FF",
                "text": "LOW",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#16BB16FF",
                "text": "AVERAGE",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#FFB000FF",
                "text": "HOGH",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#FF520EFF",
                "text": "EXTREME",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(102,51,204)",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Subj Fatigue",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Subjective fatigue",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": 1,
            "band": 0,
            "fill": "rgba(102,51,204,0.3)",
            "text": "Fatigue 7d",
            "type": "line",
            "field": "wellness_fatigue",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Subjective fatigue",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Subj Fatigue",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Subjective fatigue",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "moving_avg",
            "min": 1,
            "band": 0.6,
            "fill": "#50486180",
            "text": "Fatigue 42d",
            "type": "line",
            "field": "wellness_fatigue",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Subjective fatigue",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Subj Fatigue",
            "markerValue": "right",
            "strokeWidth": 1.8,
            "i18nTitleKey": "Subjective fatigue",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Chronic Fatigue",
        "height": 165,
        "yAxisMax": 4.5,
        "yAxisMin": 0.5,
        "y2AxisMax": 4.5,
        "y2AxisMin": 0.5,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Fatigue",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 3,
      "index": 23,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:20:19.730+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 603913,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Peak 3m",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Peak3m",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nicu.powerCurve.getWatts(180)\n}",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Peak 3m"
      },
      "usage_count": 1,
      "index": 23,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-26T10:36:03.054+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 679327,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "INT POWER",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "INT POWER",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "Power",
            "color": "#ff00ffff",
            "extras": [],
            "legend": false,
            "stream": "watts",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 5,
            "strokeWidth": 1.2,
            "transformArgs": null
          },
          {
            "id": 2,
            "axis": null,
            "text": "30s Power",
            "color": "#6633cc",
            "extras": [],
            "legend": true,
            "stream": "watts_30s",
            "transform": "none",
            "areaOpacity": 0.25,
            "lineOpacity": 0.5,
            "transformArgs": null
          },
          {
            "id": 3,
            "axis": null,
            "text": "avg",
            "color": "#648fffff",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "work_interval_avg",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "strokeWidth": 1.75,
            "transformArgs": null
          },
          {
            "id": 4,
            "axis": null,
            "text": "trnd",
            "color": "#666666ff",
            "extras": [],
            "legend": true,
            "stream": "watts",
            "transform": "work_interval_linear_trend",
            "areaOpacity": 0,
            "lineOpacity": 15,
            "strokeWidth": 1.75,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 120,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 23,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-06-15T11:11:38.832+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 692560,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "8' efforts bar",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "250px",
        "script": "// Bar chart for best 5 efforts (8 minutes)\nconst DURATION_8mbar = 480;\nconst TOP_N_8mbar = 5;\nconst LABEL_8mbar = \"8'\";\nconst activity_8mbar = icu.activity;\nconst weight_8mbar = activity_8mbar.icu_weight;\n\nfunction getStreamData_8mbar(streamName) {\n    const stream = icu.streams.get(streamName);\n    return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\nconst power_8mbar = getStreamData_8mbar(\"fixed_watts\");\n\nfunction getTopNBestAveragesOverNSeconds_8mbar(data, n, topN = 5, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let results = [];\n    let sum = 0;\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    results.push({ avg: sum / windowSize, start: 0 });\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        results.push({ avg, start: i });\n    }\n    results.sort((a, b) => b.avg - a.avg);\n    let nonOverlapping = [];\n    for (let i = 0; i < results.length && nonOverlapping.length < topN; i++) {\n        if (nonOverlapping.every(r => Math.abs(r.start - results[i].start) >= windowSize)) {\n            nonOverlapping.push(results[i]);\n        }\n    }\n    return nonOverlapping;\n}\n\nlet x_8mbar = [];\nlet y_8mbar = [];\nlet hover_8mbar = [];\nlet effortData_8mbar = [];\nconst heartrate_8mbar = getStreamData_8mbar(\"fixed_heartrate\");\nconst time_8mbar = getStreamData_8mbar(\"time\");\nconst distance_8mbar = getStreamData_8mbar(\"distance\");\nconst altitude_8mbar = getStreamData_8mbar(\"fixed_altitude\");\nconst grade_8mbar = getStreamData_8mbar(\"grade_smooth\");\nfunction secondsToHms_8mbar(seconds) {\n    seconds = Math.floor(seconds);\n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = seconds % 60;\n    let str = '';\n    if (h > 0) str += String(h).padStart(2, '0') + ':';\n    str += (h > 0 ? String(m).padStart(2, '0') : m) + ':' + String(s).padStart(2, '0');\n    return str;\n}\nfor (const [idx, best] of getTopNBestAveragesOverNSeconds_8mbar(power_8mbar, DURATION_8mbar, TOP_N_8mbar, 1).entries()) {\n    const bestStart = best.start;\n    const bestEnd = bestStart + DURATION_8mbar;\n    const sectionHR = heartrate_8mbar.slice(bestStart, bestEnd);\n    const sectionDistance = distance_8mbar.slice(bestStart, bestEnd);\n    const sectionAltitude = altitude_8mbar.slice(bestStart, bestEnd);\n    const sectionGrade = grade_8mbar.slice(bestStart, bestEnd);\n    const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n    const maxHR = Math.max(...sectionHR);\n    const startTime = secondsToHms_8mbar(time_8mbar[bestStart]);\n    const avgPower = best.avg;\n    const avgPowerPerKg = avgPower / weight_8mbar;\n    const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n    const distKm = dist / 1000;\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const avgGrade = elevationGain / dist * 100;\n    const maxGrade = Math.max(...sectionGrade);\n    // Ratio: prima met, seconda met, ratio\n    const firstHalf = power_8mbar.slice(bestStart, bestStart + DURATION_8mbar/2);\n    const secondHalf = power_8mbar.slice(bestStart + DURATION_8mbar/2, bestEnd);\n    const rat_1 = firstHalf.reduce((a,b)=>a+b,0)/firstHalf.length;\n    const rat_2 = secondHalf.reduce((a,b)=>a+b,0)/secondHalf.length;\n    const ratio = rat_2 / rat_1;\n    // VAM\n    const climbTimeH = DURATION_8mbar / 3600;\n    const ascentSpeed = elevationGain / climbTimeH;\n    const avgHorizontalSpeed = distKm / (DURATION_8mbar / 3600);\n    // Best 5s\n    let best5sWatts = 0;\n    for (let i = 0; i <= power_8mbar.slice(bestStart, bestEnd).length - 5; i++) {\n        const avg5 = power_8mbar.slice(bestStart + i, bestStart + i + 5).reduce((a,b)=>a+b,0)/5;\n        if (avg5 > best5sWatts) best5sWatts = avg5;\n    }\n    const best5sPerKg = best5sWatts / weight_8mbar;\n    // Teorici (come in PIAN HC)\n    const gradientFactor = (2 + avgGrade / 10) * 100;\n    const TEORICWKG = ascentSpeed / gradientFactor;\n    const TEORICVAM = avgPowerPerKg * gradientFactor;\n    effortData_8mbar.push({\n        idx,\n        avgPower,\n        avgPowerPerKg,\n        avgHR,\n        maxHR,\n        startTime,\n        bestStart,\n        dist,\n        distKm,\n        elevationGain,\n        avgGrade,\n        maxGrade,\n        rat_1,\n        rat_2,\n        ratio,\n        ascentSpeed,\n        avgHorizontalSpeed,\n        best5sWatts,\n        best5sPerKg,\n        TEORICWKG,\n        TEORICVAM\n    });\n}\n// Ordina per tempo di inizio (bestStart)\neffortData_8mbar.sort((a, b) => a.bestStart - b.bestStart);\nfor (const [i, effort] of effortData_8mbar.entries()) {\n    x_8mbar.push(`${i+1}`); // Solo Effort 1, Effort 2, ...\n    y_8mbar.push(effort.avgPower);\n    hover_8mbar.push(\n        ` ${(effort.dist / 1000).toFixed(2)} km (${effort.elevationGain.toFixed(0)} m)<br>`+\n        `  ${effort.avgGrade.toFixed(1)}% | max. ${effort.maxGrade.toFixed(1)}%<br>`+\n        ` ${effort.avgPower.toFixed(0)} W | 5 ${effort.best5sWatts.toFixed(0)} W<br>`+\n        ` ${effort.avgPowerPerKg.toFixed(2)} W/kg | 5 ${effort.best5sPerKg.toFixed(2)} W/kg<br>`+\n        ` ${effort.rat_1.toFixed(0)} W | ${effort.rat_2.toFixed(0)} W | ${(effort.ratio).toFixed(2)}<br>`+\n        `  ${effort.avgHR.toFixed(0)} bpm | max. ${effort.maxHR} bpm<br>`+\n        ` ${effort.avgHorizontalSpeed.toFixed(1)} km/h |  ${effort.ascentSpeed.toFixed(0)} m/h<br>`+\n        ` ${effort.TEORICWKG.toFixed(2)} W/kg | ${effort.TEORICVAM.toFixed(0)} VAM`+\n        `<br> ${effort.startTime}`\n    );\n}\n\nconst FTP_8mbar = activity_8mbar.icu_ftp;\nfunction getZoneColor_8mbar(avgPower, ftp) {\n    const percentage = (avgPower / ftp) * 100;\n\n    if (percentage < 76) return \"4c72b0\";        // Z2\n    if (percentage < 91) return \"55a868\";         // Z3\n    if (percentage < 106) return \"dd8452\";        // Z4 (ex gold, ora come Z3)\n    if (percentage < 121) return \"c44e52\";           // Z5\n    if (percentage < 151) return \"a64d79\";        // Z6\n    return \"8172b3\";                                // Z7+;\n}\n\nconst barColors_8mbar = y_8mbar.map((v) => getZoneColor_8mbar(v, FTP_8mbar));\n\n\nconst data_8mbar = [\n  {\n    x: x_8mbar,\n    y: y_8mbar,\n    type: 'bar',\n    marker: {\n      color: barColors_8mbar\n    },\n    text: x_8mbar.map((label, i) =>\n      `${y_8mbar[i].toFixed(0)} W | ${effortData_8mbar[i].avgPowerPerKg.toFixed(2)} W/kg<br>`\n      + `${effortData_8mbar[i].rat_1.toFixed(0)} W | ${effortData_8mbar[i].rat_2.toFixed(0)} W | ${effortData_8mbar[i].ratio.toFixed(2)}<br>`\n      + ` ${effortData_8mbar[i].avgHR.toFixed(0)} bpm | max. ${effortData_8mbar[i].maxHR} bpm<br>`\n      + `${effortData_8mbar[i].ascentSpeed.toFixed(0)} m/h |  ${effortData_8mbar[i].avgGrade.toFixed(1)}%<br>`\n      + `${effortData_8mbar[i].startTime}`\n    ),\n    textposition: 'inside',\n    insidetextanchor: 'start',\n    textfont: {\n      color: '#000',\n      size: 13,\n      family: 'Arial Black'\n    },\n    hoverinfo: 'text',\n    hovertext: hover_8mbar,\n    hoverlabel: { font: { color: '#000', family: 'Arial', size: 13 }, align: 'left' },\n    name: 'Avg Power',\n    visible: true\n  }\n];\n\nconst layout_8mbar = {\n  title: \"8' efforts\",\n  barmode: 'group',\n  showlegend: false,\n  height: 250,\n  margin: {l: 40, r: 20, t: 40, b: 40},\n  xaxis: {title: 'Effort'},\n  yaxis: {\n    title: 'Avg Power (W)',\n    dtick: 50, // Griglia ogni 50 watt\n    gridcolor: '#ccc',\n    gridwidth: 1\n  },\n};\n\nchart = { data: data_8mbar, layout: layout_8mbar };\nchart;",
        "name": "8' efforts bar"
      },
      "usage_count": 0,
      "index": 23,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-03T18:08:06.424+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504086,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Stress CHR",
      "description": "Stress trend on 42days and 7days",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/e489d6d2-02d1-4157-aee0-41cfa8911420",
      "content": {
        "id": "2u2vs4w5",
        "name": "Stress CHR",
        "plots": [
          {
            "id": 2,
            "agg": "none",
            "min": 1,
            "band": 0,
            "fill": "#8D824700",
            "text": "Stress",
            "type": "bars",
            "field": "stress",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Stress",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#34ACE4FF",
                "text": "LOW",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#16BB16FF",
                "text": "AVERAGE",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#FFB000FF",
                "text": "HOGH",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#FF520EFF",
                "text": "EXTREME",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(140,86,75)",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Stress",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Stress",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": 1,
            "band": 0,
            "fill": "rgba(140,86,75,0.4)",
            "text": "Stress 7d",
            "type": "line",
            "field": "stress",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Stress",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Stress",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Stress",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "moving_avg",
            "min": 1,
            "band": 0.6,
            "fill": "#50486180",
            "text": "Stress 42d",
            "type": "line",
            "field": "stress",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Stress",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Stress",
            "markerValue": "right",
            "strokeWidth": 1.8,
            "i18nTitleKey": "Stress",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Chronic Stress",
        "height": 165,
        "yAxisMax": 4.5,
        "yAxisMin": 0.5,
        "y2AxisMax": 4.5,
        "y2AxisMin": 0.5,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Stress",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 5,
      "index": 24,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:20:30.369+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 603914,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Peak 5m",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Peak5m",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nicu.powerCurve.getWatts(300)\n}",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Peak 5m"
      },
      "usage_count": 1,
      "index": 24,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-26T10:36:20.894+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 679334,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "vam-speed-grad INT",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "vam-speed-grad INT",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "VAM",
            "color": "#1f77b4ff",
            "extras": [],
            "legend": true,
            "stream": "vam",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "transformArgs": null
          },
          {
            "id": 2,
            "axis": null,
            "text": "Gradient",
            "color": "#dd0447ff",
            "extras": [],
            "legend": true,
            "stream": "grade_smooth",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "transformArgs": null
          },
          {
            "id": 3,
            "axis": null,
            "text": "Speed",
            "color": "#000000ff",
            "extras": [],
            "legend": true,
            "stream": "velocity_smooth",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 90,
        "yAxisMax": null,
        "yAxisMin": 0.0,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 24,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-06-15T11:09:28.488+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 692565,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "1' efforts chart",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "function getBestAverageOverNSeconds(data, n, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let bestAvg = 0;\n    let bestStart = 0;\n    let sum = 0;\n    // Initialize sum of the first window\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    bestAvg = sum / windowSize;\n    // Slide the window\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        if (avg > bestAvg) {\n            bestAvg = avg;\n            bestStart = i;\n        }\n    }\n    return { bestAvg, bestStart };\n}\n\nfunction getTopNBestAveragesOverNSeconds(data, n, topN = 2, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let results = [];\n    let sum = 0;\n    // Initialize sum of the first window\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    results.push({ avg: sum / windowSize, start: 0 });\n    // Slide the window\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        results.push({ avg, start: i });\n    }\n    // Sort by avg descending, filter out overlapping windows\n    results.sort((a, b) => b.avg - a.avg);\n    let nonOverlapping = [];\n    for (let i = 0; i < results.length && nonOverlapping.length < topN; i++) {\n        if (nonOverlapping.every(r => Math.abs(r.start - results[i].start) >= windowSize)) {\n            nonOverlapping.push(results[i]);\n        }\n    }\n    return nonOverlapping;\n}\n\nfunction getZoneColor(avgPower, FTP) {\n    if (!FTP || FTP <= 0) return 'grey';\n    const percentage = (avgPower / FTP) * 100;\n\n    if (percentage < 76) return \"4c72b0\";        // Z2\n    if (percentage < 91) return \"55a868\";         // Z3\n    if (percentage < 106) return \"dd8452\";        // Z4 (ex gold, ora come Z3)\n    if (percentage < 126) return \"c44e52\";           // Z5\n    if (percentage < 151) return \"a64d79\";        // Z6\n    return \"8172b3\";                                // Z7+;\n}\n\n{\n    // Configuration\n    const WINDOW_SECONDS = 60; // 1 minute\n    const TOP_N = 10;\n    const FTP = icu.activity.icu_ftp;\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    // Fix initial altitude values\n    const firstNonZeroAltitude = altitude.find(value => value !== 0);\n    if (firstNonZeroAltitude !== undefined) {\n        for (let i = 0; i < altitude.length; i++) {\n            if (altitude[i] === 0) {\n                altitude[i] = firstNonZeroAltitude;\n            } else {\n                break;\n            }\n        }\n    }\n\n    let traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map(alt => `${alt.toFixed(1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Elevation'\n        }\n    ];\n    // Find all non-overlapping 60s efforts above 120% FTP\n    function getAllNonOverlappingEffortsAboveThreshold_1min(data, n, threshold, samplingRate = 1) {\n        const windowSize = n * samplingRate;\n        let results = [];\n        let sum = 0;\n        if (data.length < windowSize) return results;\n        for (let i = 0; i < windowSize; i++) {\n            sum += data[i];\n        }\n        let candidates = [];\n        if (sum / windowSize >= threshold) {\n            candidates.push({ avg: sum / windowSize, start: 0 });\n        }\n        for (let i = 1; i <= data.length - windowSize; i++) {\n            sum = sum - data[i - 1] + data[i + windowSize - 1];\n            const avg = sum / windowSize;\n            if (avg >= threshold) {\n                candidates.push({ avg, start: i });\n            }\n        }\n        // Sort by avg descending\n        candidates.sort((a, b) => b.avg - a.avg);\n        let used = Array(data.length).fill(false);\n        for (const cand of candidates) {\n            let overlap = false;\n            for (let j = cand.start; j < cand.start + windowSize; j++) {\n                if (used[j]) {\n                    overlap = true;\n                    break;\n                }\n            }\n            if (!overlap) {\n                results.push(cand);\n                for (let j = cand.start; j < cand.start + windowSize; j++) {\n                    used[j] = true;\n                }\n            }\n        }\n        // Sort by start time ascending for display\n        results.sort((a, b) => a.start - b.start);\n        return results;\n    }\n\n    const threshold_1min = 1.2 * FTP;\n    const allEfforts_1min = getAllNonOverlappingEffortsAboveThreshold_1min(power, WINDOW_SECONDS, threshold_1min, 1);\n    let idx = 0;\n    let annotations = [];\n    // Sort efforts in descending order of avgPower for legend (highest first)\n    allEfforts_1min.sort((a, b) => b.avg - a.avg);\n    allEfforts_1min.forEach((best) => {\n        const avgPower = best.avg;\n        const bestStart = best.start;\n        const bestEnd = bestStart + WINDOW_SECONDS;\n        const sectionPower = power.slice(bestStart, bestEnd);\n        const sectionHR = heartrate.slice(bestStart, bestEnd);\n        const sectionAltitude = altitude.slice(bestStart, bestEnd);\n        const sectionDistance = distance.slice(bestStart, bestEnd);\n        const sectionDistanceKm = distanceKm.slice(bestStart, bestEnd);\n        const sectionGrade = grade.slice(bestStart, bestEnd);\n        const sectionTime = time.slice(bestStart, bestEnd);\n\n        const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n        const maxHR = Math.max(...sectionHR);\n        const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n        const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n        const avgGrade = elevationGain / dist * 100;\n        const avgPowerPerKg = best.avg / weight;\n        const maxGrade = Math.max(...sectionGrade);\n        const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n        const ascentSpeed = elevationGain / (climbTimeInSeconds / 3600);\n        const avgHorizontalSpeed = (dist / 1000) / (climbTimeInSeconds / 3600);\n        const bgColor = getZoneColor(avgPower, FTP);\n        // 5s best power in this window\n        const best5s = getBestAverageOverNSeconds(sectionPower, 5, 1);\n        const best5sWatts = best5s.bestAvg;\n        const best5sPerKg = best5sWatts / weight;\n        // Theoretical values (as in your climb code)\n        const gradientFactor = (2 + avgGrade / 10) * 100;\n        const TEORICWKG = ascentSpeed / gradientFactor;\n        const TEORICVAM = avgPowerPerKg * gradientFactor;\n\n        // Calculate 3x20s avg watts for the 1' effort\n        let avg20s1 = 0, avg20s2 = 0, avg20s3 = 0;\n        if (sectionPower.length >= 60) {\n            avg20s1 = sectionPower.slice(0, 20).reduce((a, b) => a + b, 0) / 20;\n            avg20s2 = sectionPower.slice(20, 40).reduce((a, b) => a + b, 0) / 20;\n            avg20s3 = sectionPower.slice(40, 60).reduce((a, b) => a + b, 0) / 20;\n        }\n        traces.push({\n            x: sectionDistanceKm,\n            y: sectionAltitude,\n            type: 'scatter',\n            mode: 'lines',\n            line: { color: bgColor, width: 2 },\n            name: `${avgPower.toFixed(0)} W | #${idx + 1}`,\n            hoverinfo: 'text',\n            visible: true,\n            hoverlabel: { align: 'left' },\n            text: [\n                `#${idx + 1}`,\n                ` ${(dist / 1000).toFixed(2)} km (${elevationGain.toFixed(0)} m)`,\n                `  ${avgGrade.toFixed(1)}% | max. ${maxGrade.toFixed(1)}%`,\n                ` ${avgPower.toFixed(0)} W | 5${best5sWatts.toFixed(0)}W`,\n                ` ${avg20s1.toFixed(0)} | ${avg20s2.toFixed(0)} | ${avg20s3.toFixed(0)}`,\n                ` ${avgPowerPerKg.toFixed(2)} W/kg | 5 ${best5sPerKg.toFixed(2)} W/kg`,\n                `  ${avgHR.toFixed(0)} bpm | max. ${maxHR} bpm` ,\n                ` ${avgHorizontalSpeed.toFixed(1)} km/h |  ${ascentSpeed.toFixed(0)} m/h`\n            ].join('<br>')\n        });\n\n        // Offset annotation positions to avoid overlap\n        annotations.push({\n            // Add a small horizontal offset and lower the annotation closer to the profile\n            x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2 + (idx % 2 === 0 ? -1 : 1) * idx * 0.003, // alternate left/right, small step\n            y: Math.max(...sectionAltitude) + 50+ idx * 25, // lowered from 130 to 60\n            text: `#${idx + 1}<br> ${avgPower.toFixed(0)}`,\n            showarrow: false,\n            font: { family: 'Arial', size: 12, color: 'white' },\n            align: 'center',\n            bgcolor: bgColor,\n            opacity: 0.9\n        });\n        idx++;\n        // No limit: show all non-overlapping efforts above 120% FTP\n    });\n\n\n    const layout = {\n        title: `1' Power Efforts >120% FTP` ,\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout };\n    chart;\n}",
        "name": "1' efforts chart"
      },
      "usage_count": 0,
      "index": 24,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-03T19:29:37.310+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 514522,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Motivation CHR",
      "description": "Motivation trend on 42days and 7days",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/44006e00-7a15-4cad-942b-b30f1b73ed00",
      "content": {
        "id": "l5psdzx7",
        "name": "Motivation CHR",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": 1,
            "band": 0,
            "fill": "#0E7BF100",
            "text": "Motivation",
            "type": "bars",
            "field": "motivation",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Motivation",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#34ACE4FF",
                "text": "EXTREME",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#16BB16FF",
                "text": "HIGH",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#FFB000FF",
                "text": "AVERAGE",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#FF520EFF",
                "text": "LOW",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Motivation",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Motivation",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": 1,
            "band": 0,
            "fill": "rgba(23,190,207, 0.3)",
            "text": "Motivation",
            "type": "line",
            "field": "motivation",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Motivation",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Motivation",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Motivation",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": 1,
            "band": 0.6,
            "fill": "#50486180",
            "text": "Motivation 42d",
            "type": "line",
            "field": "motivation",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Motivation",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Motivation",
            "markerValue": "right",
            "strokeWidth": 1.8,
            "i18nTitleKey": "Motivation",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Chronic Motivation",
        "height": 165,
        "yAxisMax": 4.5,
        "yAxisMin": 0.5,
        "y2AxisMax": 4.5,
        "y2AxisMin": 0.5,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Motivation",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 2,
      "index": 25,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-29T18:38:44.457+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 603915,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Peak 10m",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Peak10m",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nicu.powerCurve.getWatts(600)\n}",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Peak 10m"
      },
      "usage_count": 1,
      "index": 25,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-26T10:35:14.135+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 692573,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "1' bar",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "300px",
        "script": "// Bar chart for best 8 efforts (1 minute)\nconst DURATION_1mbar = 60;\nconst TOP_N_1mbar = 20; // Calculate top 20 efforts\nconst LABEL_1mbar = \"1'\";\nconst activity_1mbar = icu.activity;\nconst weight_1mbar = activity_1mbar.icu_weight;\n\nfunction getStreamData_1mbar(streamName) {\n    const stream = icu.streams.get(streamName);\n    return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\nconst power_1mbar = getStreamData_1mbar(\"fixed_watts\");\n\nfunction getTopNBestAveragesOverNSeconds_1mbar(data, n, topN = 8, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let results = [];\n    let sum = 0;\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    results.push({ avg: sum / windowSize, start: 0 });\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        results.push({ avg, start: i });\n    }\n    results.sort((a, b) => b.avg - a.avg);\n    let nonOverlapping = [];\n    for (let i = 0; i < results.length && nonOverlapping.length < topN; i++) {\n        if (nonOverlapping.every(r => Math.abs(r.start - results[i].start) >= windowSize)) {\n            nonOverlapping.push(results[i]);\n        }\n    }\n    return nonOverlapping;\n}\n\nlet x_1mbar = [];\nlet y_1mbar = [];\nlet hover_1mbar = [];\nlet effortData_1mbar = [];\nconst VISIBLE_BARS = 7; // Number of bars visible at once\nconst heartrate_1mbar = getStreamData_1mbar(\"fixed_heartrate\");\nconst time_1mbar = getStreamData_1mbar(\"time\");\nconst distance_1mbar = getStreamData_1mbar(\"distance\");\nconst altitude_1mbar = getStreamData_1mbar(\"fixed_altitude\");\nconst grade_1mbar = getStreamData_1mbar(\"grade_smooth\");\nfunction secondsToHms_1mbar(seconds) {\n    seconds = Math.floor(seconds);\n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = seconds % 60;\n    let str = '';\n    if (h > 0) str += String(h).padStart(2, '0') + ':';\n    str += (h > 0 ? String(m).padStart(2, '0') : m) + ':' + String(s).padStart(2, '0');\n    return str;\n}\nfor (const [idx, best] of getTopNBestAveragesOverNSeconds_1mbar(power_1mbar, DURATION_1mbar, TOP_N_1mbar, 1).entries()) {\n    const bestStart = best.start;\n    const bestEnd = bestStart + DURATION_1mbar;\n    const sectionHR = heartrate_1mbar.slice(bestStart, bestEnd);\n    const sectionDistance = distance_1mbar.slice(bestStart, bestEnd);\n    const sectionAltitude = altitude_1mbar.slice(bestStart, bestEnd);\n    const sectionGrade = grade_1mbar.slice(bestStart, bestEnd);\n    const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n    const maxHR = Math.max(...sectionHR);\n    const startTime = secondsToHms_1mbar(time_1mbar[bestStart]);\n    const avgPower = best.avg;\n    const avgPowerPerKg = avgPower / weight_1mbar;\n    const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n    const distKm = dist / 1000;\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const avgGrade = elevationGain / dist * 100;\n    const maxGrade = Math.max(...sectionGrade);\n    // Ratio: primo 30s, secondo 30s, ratio\n    const firstHalf = power_1mbar.slice(bestStart, bestStart + DURATION_1mbar/2);\n    const secondHalf = power_1mbar.slice(bestStart + DURATION_1mbar/2, bestEnd);\n    const rat_1 = firstHalf.reduce((a,b)=>a+b,0)/firstHalf.length;\n    const rat_2 = secondHalf.reduce((a,b)=>a+b,0)/secondHalf.length;\n    const ratio = rat_2 / rat_1;\n    // VAM\n    const climbTimeH = DURATION_1mbar / 3600;\n    const ascentSpeed = elevationGain / climbTimeH;\n    const avgHorizontalSpeed = distKm / (DURATION_1mbar / 3600);\n    // Best 5s\n    let best5sWatts = 0;\n    for (let i = 0; i <= power_1mbar.slice(bestStart, bestEnd).length - 5; i++) {\n        const avg5 = power_1mbar.slice(bestStart + i, bestStart + i + 5).reduce((a,b)=>a+b,0)/5;\n        if (avg5 > best5sWatts) best5sWatts = avg5;\n    }\n    const best5sPerKg = best5sWatts / weight_1mbar;\n    // Teorici (come in PIAN HC)\n    const gradientFactor = (2 + avgGrade / 10) * 100;\n    const TEORICWKG = ascentSpeed / gradientFactor;\n    const TEORICVAM = avgPowerPerKg * gradientFactor;\n    effortData_1mbar.push({\n        idx,\n        avgPower,\n        avgPowerPerKg,\n        avgHR,\n        maxHR,\n        startTime,\n        bestStart,\n        dist,\n        distKm,\n        elevationGain,\n        avgGrade,\n        maxGrade,\n        rat_1,\n        rat_2,\n        ratio,\n        ascentSpeed,\n        avgHorizontalSpeed,\n        best5sWatts,\n        best5sPerKg,\n        TEORICWKG,\n        TEORICVAM\n    });\n}\n\n// Ordina per watt decrescente\neffortData_1mbar.sort((a, b) => b.avgPower - a.avgPower);\nfor (const [i, effort] of effortData_1mbar.entries()) {\n    x_1mbar.push(`${i+1}`); // Solo Effort 1, Effort 2, ...\n    y_1mbar.push(effort.avgPower);\n    hover_1mbar.push(\n        ` ${(effort.dist / 1000).toFixed(2)} km (${effort.elevationGain.toFixed(0)} m)<br>`+\n        `  ${effort.avgGrade.toFixed(1)}% | max. ${effort.maxGrade.toFixed(1)}%<br>`+\n        ` ${effort.avgPower.toFixed(0)} W | 5 ${effort.best5sWatts.toFixed(0)} W<br>`+\n        ` ${effort.avgPowerPerKg.toFixed(2)} W/kg | 5 ${effort.best5sPerKg.toFixed(2)} W/kg<br>`+\n        ` ${effort.rat_1.toFixed(0)} W | ${effort.rat_2.toFixed(0)} W | ${(effort.ratio).toFixed(2)}<br>`+\n        `  ${effort.avgHR.toFixed(0)} bpm | max. ${effort.maxHR} bpm<br>`+\n        ` ${effort.avgHorizontalSpeed.toFixed(1)} km/h |  ${effort.ascentSpeed.toFixed(0)} m/h<br>`+\n        ` ${effort.startTime}`\n    );\n}\n\nconst FTP_1mbar = activity_1mbar.icu_ftp;\nfunction getZoneColor_1mbar(avgPower, ftp) {\n    const percentage = (avgPower / ftp) * 100;\n\n    if (percentage < 76) return \"4c72b0\";        // Z2\n    if (percentage < 91) return \"55a868\";         // Z3\n    if (percentage < 106) return \"dd8452\";        // Z4 (ex gold, ora come Z3)\n    if (percentage < 126) return \"c44e52\";           // Z5\n    if (percentage < 151) return \"a64d79\";        // Z6\n    return \"8172b3\";                                // Z7+;\n}\n\nconst barColors_1mbar = y_1mbar.map((v) => getZoneColor_1mbar(v, FTP_1mbar));\n\nconst data_1mbar = [\n  {\n    x: x_1mbar,\n    y: y_1mbar,\n    type: 'bar',\n    marker: {\n      color: barColors_1mbar\n    },\n    text: x_1mbar.map((label, i) =>\n      `${y_1mbar[i].toFixed(0)} W | ${effortData_1mbar[i].avgPowerPerKg.toFixed(2)} W/kg<br>`\n      + `${effortData_1mbar[i].rat_1.toFixed(0)} W | ${effortData_1mbar[i].rat_2.toFixed(0)} W | ${effortData_1mbar[i].ratio.toFixed(2)}<br>`\n      + ` ${effortData_1mbar[i].avgHR.toFixed(0)} bpm | ${effortData_1mbar[i].maxHR} bpm<br>`\n      + `${effortData_1mbar[i].ascentSpeed.toFixed(0)} m/h |  ${effortData_1mbar[i].avgGrade.toFixed(1)}%<br>`\n      + `${effortData_1mbar[i].startTime}`\n    ),\n    textposition: 'inside',\n    insidetextanchor: 'start',\n    textfont: {\n      color: '#000',\n      size: 13,\n      family: 'Arial Black'\n    },\n    hoverinfo: 'text',\n    hovertext: hover_1mbar,\n    hoverlabel: { font: { color: '#000', family: 'Arial', size: 13 }, align: 'left' },\n    name: 'Avg Power',\n    visible: true\n  }\n];\n\n\nconst layout_1mbar = {\n  title: \"1' efforts\",\n  barmode: 'group',\n  showlegend: false,\n  height: 250,\n  margin: {l: 40, r: 20, t: 40, b: 40},\n  xaxis: {\n    title: 'Effort',\n    range: [0, VISIBLE_BARS - 0.5], // Show only n bars at a time\n    fixedrange: false,\n    autorange: false,\n    tickmode: 'linear',\n    tick0: 1,\n    dtick: 1,\n    showgrid: true,\n    gridcolor: '#eee',\n    gridwidth: 1,\n    scrollZoom: true    // Show only n bars at a time\n  },\n  yaxis: {\n    title: 'Avg Power (W)',\n    dtick: 50, // Griglia ogni 50 watt\n    gridcolor: '#ccc',\n    gridwidth: 1\n  },\n};\n\nchart = { data: data_1mbar, layout: layout_1mbar };\nchart;",
        "name": "1' bar"
      },
      "usage_count": 0,
      "index": 25,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-03T18:19:49.171+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 724846,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PUBLIC",
      "name": "Energy Systems",
      "description": "Aerobic + Glycolytic + Pcr systems all in 1 chart",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/0fe7b22d-7dc6-43e1-b7ac-a5852e5ff5bc",
      "content": {
        "id": null,
        "name": "Energy Systems",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "Aerobic",
            "color": "#34ace4d4",
            "extras": [],
            "legend": true,
            "stream": "p_cp",
            "transform": "none",
            "areaOpacity": 1,
            "lineOpacity": 0.3,
            "strokeWidth": 1.01,
            "transformArgs": null
          },
          {
            "id": 2,
            "axis": null,
            "text": "Glycolytic",
            "color": "#fc0000ff",
            "extras": [],
            "legend": true,
            "stream": "p_wprime",
            "transform": "none",
            "areaOpacity": 0.03,
            "lineOpacity": 1,
            "strokeWidth": 1.5,
            "transformArgs": null
          },
          {
            "id": 3,
            "axis": null,
            "text": "PCr",
            "color": "#6633ccff",
            "extras": [],
            "legend": true,
            "stream": "p_pmax",
            "transform": "none",
            "areaOpacity": 0.03,
            "lineOpacity": 1,
            "strokeWidth": 1.5,
            "transformArgs": null
          }
        ],
        "title": "",
        "height": 120,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "System",
        "y2AxisLabel": null
      },
      "usage_count": 148,
      "index": 25,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-09T16:41:47.431+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 603916,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Peak 15m",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Peak15m",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nicu.powerCurve.getWatts(900)\n}",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Peak 15m"
      },
      "usage_count": 1,
      "index": 26,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-26T10:35:24.668+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 692587,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "surges 8\"",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "300px",
        "script": "// Table of best 20 efforts for 8 seconds (surge8)\nconst DURATION_surge8 = 8;\nconst TOP_N_surge8 = 20;\nconst activity_surge8 = icu.activity;\nconst weight_surge8 = activity_surge8.icu_weight;\n\nfunction getStreamData_surge8(streamName) {\n    const stream = icu.streams.get(streamName);\n    return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\nconst power_surge8 = getStreamData_surge8(\"fixed_watts\");\nconst heartrate_surge8 = getStreamData_surge8(\"fixed_heartrate\");\nconst time_surge8 = getStreamData_surge8(\"time\");\nconst distance_surge8 = getStreamData_surge8(\"distance\"); // meters\n\nfunction getTopNBestAveragesOverNSeconds_surge8(data, n, topN = 20, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let results = [];\n    let sum = 0;\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    results.push({ avg: sum / windowSize, start: 0 });\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        results.push({ avg, start: i });\n    }\n    results.sort((a, b) => b.avg - a.avg);\n    let nonOverlapping = [];\n    for (let i = 0; i < results.length && nonOverlapping.length < topN; i++) {\n        if (nonOverlapping.every(r => Math.abs(r.start - results[i].start) >= windowSize)) {\n            nonOverlapping.push(results[i]);\n        }\n    }\n    return nonOverlapping;\n}\n\nfunction secondsToHms_surge8(seconds) {\n    seconds = Math.floor(seconds);\n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = seconds % 60;\n    let str = '';\n    if (h > 0) str += String(h).padStart(2, '0') + ':';\n    str += (h > 0 ? String(m).padStart(2, '0') : m) + ':' + String(s).padStart(2, '0');\n    return str;\n}\n\n// Prepare data for table\nlet header_surge8 = ['# (by watts)', 'Power (W)', 'W/kg', 'Drop 2\"', 'Drop 2/2', 'HR', 'Avg Speed (km/h)', 'Start (h:m:s)', '# (chronological)'];\nlet cells_surge8 = [[], [], [], [], [], [], [], [], []];\n\n// Get best 20 by watts\nconst bests_surge8 = getTopNBestAveragesOverNSeconds_surge8(power_surge8, DURATION_surge8, TOP_N_surge8, 1);\n// For chronological order, sort a copy by start\nconst bests_surge8_chrono = [...bests_surge8].sort((a, b) => a.start - b.start);\n\nbests_surge8.forEach((best, idx) => {\n    const bestStart = best.start;\n    const bestEnd = bestStart + DURATION_surge8;\n    const sectionPower = power_surge8.slice(bestStart, bestEnd);\n    const sectionHR = heartrate_surge8.slice(bestStart, bestEnd);\n    const sectionTime = time_surge8.slice(bestStart, bestEnd);\n    const sectionDistance = distance_surge8.slice(bestStart, bestEnd);\n    const avgPower = best.avg;\n    const avgPowerPerKg = avgPower / weight_surge8;\n    // Drop 2/2: ultimi 2\" / primi 2\"\n    const first2 = sectionPower.slice(0, 2).reduce((a, b) => a + b, 0) / 2;\n    const last2 = sectionPower.slice(-2).reduce((a, b) => a + b, 0) / 2;\n    const drop2 = (first2 - last2).toFixed(0); // differenza assoluta primi 2\" - ultimi 2\"\n    const drop2_2 = (last2 / first2) * 100;\n    // HR\n    const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n    // Avg speed\n    const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n    const avgSpeed = (dist / 1000) / (DURATION_surge8 / 3600);\n    // Start time formatted\n    const startTime = secondsToHms_surge8(time_surge8[bestStart]);\n    // Find chronological index (1-based)\n    const chronoIdx = bests_surge8_chrono.findIndex(b => b.start === best.start) + 1;\n    // Fill table\n    cells_surge8[0].push(idx + 1); // # by watts\n    cells_surge8[1].push(avgPower.toFixed(0));\n    cells_surge8[2].push(avgPowerPerKg.toFixed(2));\n    cells_surge8[3].push(drop2); // nuova colonna differenza assoluta\n    cells_surge8[4].push(drop2_2.toFixed(1) + '%');\n    cells_surge8[5].push(avgHR.toFixed(0));\n    cells_surge8[6].push(avgSpeed.toFixed(1));\n    cells_surge8[7].push(startTime);\n    cells_surge8[8].push(chronoIdx); // # chronological\n});\n\nconst data_surge8 = [{\n    type: 'table',\n    header: {\n        values: header_surge8,\n        align: 'center',\n        font: {size: 14, color: 'white'},\n        fill: {color: '#1f77b4'}\n    },\n    cells: {\n        values: cells_surge8,\n        align: 'center',\n        font: {size: 13},\n        fill: {color: ['#f9f9f9', '#f2f2f2']}\n    }\n}];\n\nconst layout_surge8 = {\n    title: \"8s surges\",\n    margin: {l: 20, r: 20, t: 40, b: 20},\n    height: 500\n};\n\nchart = { data: data_surge8, layout: layout_surge8 };\nchart;",
        "name": "surges 8\""
      },
      "usage_count": 0,
      "index": 26,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-01T12:30:03.554+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 724861,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "ENERGY WITH MPA",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "ENERGY WITH MPA",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "MPA",
            "color": "#ff7f0eff",
            "extras": [],
            "legend": false,
            "stream": "mpa",
            "transform": "none",
            "areaOpacity": 0,
            "lineOpacity": 1,
            "transformArgs": null
          },
          {
            "id": 2,
            "axis": null,
            "text": "Aerobic",
            "color": "#34ace4d4",
            "extras": [],
            "legend": true,
            "stream": "p_cp",
            "transform": "none",
            "areaOpacity": 1,
            "lineOpacity": 0.3,
            "transformArgs": null
          },
          {
            "id": 3,
            "axis": null,
            "text": "Glycolytic",
            "color": "#fc0000ff",
            "extras": [],
            "legend": true,
            "stream": "p_wprime",
            "transform": "none",
            "areaOpacity": 0.03,
            "lineOpacity": 1,
            "strokeWidth": 1.4,
            "transformArgs": null
          },
          {
            "id": 4,
            "axis": null,
            "text": "PCr",
            "color": "#6633cc",
            "extras": [],
            "legend": true,
            "stream": "p_pmax",
            "transform": "none",
            "areaOpacity": 0.03,
            "lineOpacity": 1,
            "strokeWidth": 1.4,
            "transformArgs": null
          }
        ],
        "title": null,
        "height": 210,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 26,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-09T16:44:18.779+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 852809,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "FOLLOWERS",
      "name": "tOverCoast Trend",
      "description": "",
      "image": null,
      "content": {
        "id": "7i2b4c70",
        "name": "tOverCoast Trend",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#33333380",
            "text": "day",
            "type": "dot",
            "field": "af_TOverCoastFITNESS",
            "gauge": false,
            "scale": "",
            "stack": "",
            "title": "TOverCoastFITNESS",
            "extras": [],
            "filter": "customInput",
            "future": true,
            "radius": 3,
            "stroke": "#333333ff",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "tickFormat": "customInput",
            "customInput": {
              "id": 852816,
              "name": "tOverCoastFITNESS",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 132,
              "content": {
                "max": null,
                "min": null,
                "code": "TOverCoastFITNESS",
                "icon": "",
                "link": "",
                "name": "tOverCoastFITNESS",
                "type": "numeric",
                "color": "#333333",
                "gauge": false,
                "total": null,
                "units": "",
                "inline": true,
                "prefix": "",
                "script": "watts = streams.get(\"fixed_watts\").data\ntime_above = 0\nfor (let i = 0; i < watts.length; i++) {\n   w = watts[i]\n  if (w >= 50) time_above += 1\n}\n\ntime_above",
                "suffix": "",
                "average": null,
                "convert": "duration",
                "example": 42,
                "options": [],
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": "",
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-12-04T21:40:43.918+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": "",
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#33333380",
            "text": "week",
            "type": "bars",
            "field": "af_TOverCoastFITNESS",
            "gauge": false,
            "scale": "",
            "stack": "",
            "title": "TOverCoastFITNESS",
            "extras": [],
            "filter": "customInput",
            "future": true,
            "radius": 3,
            "stroke": "#333333",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "tickFormat": "customInput",
            "customInput": {
              "id": 852816,
              "name": "tOverCoastFITNESS",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 132,
              "content": {
                "max": null,
                "min": null,
                "code": "TOverCoastFITNESS",
                "icon": "",
                "link": "",
                "name": "tOverCoastFITNESS",
                "type": "numeric",
                "color": "#333333",
                "gauge": false,
                "total": null,
                "units": "",
                "inline": true,
                "prefix": "",
                "script": "watts = streams.get(\"fixed_watts\").data\ntime_above = 0\nfor (let i = 0; i < watts.length; i++) {\n   w = watts[i]\n  if (w >= 50) time_above += 1\n}\n\ntime_above",
                "suffix": "",
                "average": null,
                "convert": "duration",
                "example": 42,
                "options": [],
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": "",
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-12-04T21:40:43.918+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": "",
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "month_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(44,160,44, 0.4)",
            "text": "Moving",
            "type": "line",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(44,160,44)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "month_tot",
            "min": 0,
            "band": 0,
            "fill": "#33333380",
            "text": "tOverCoast",
            "type": "line",
            "field": "af_TOverCoastFITNESS",
            "gauge": false,
            "scale": "",
            "stack": "",
            "title": "TOverCoastFITNESS",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#333333",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 852816,
              "name": "tOverCoastFITNESS",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 132,
              "content": {
                "max": null,
                "min": null,
                "code": "TOverCoastFITNESS",
                "icon": "",
                "link": "",
                "name": "tOverCoastFITNESS",
                "type": "numeric",
                "color": "#333333",
                "gauge": false,
                "total": null,
                "units": "",
                "inline": true,
                "prefix": "",
                "script": "watts = streams.get(\"fixed_watts\").data\ntime_above = 0\nfor (let i = 0; i < watts.length; i++) {\n   w = watts[i]\n  if (w >= 50) time_above += 1\n}\n\ntime_above",
                "suffix": "",
                "average": null,
                "convert": "duration",
                "example": 42,
                "options": [],
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": "",
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-12-04T21:40:43.918+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": "",
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 2,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(44,160,44, 0.4)",
            "text": "week",
            "type": "line",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(44,160,44)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Volume Trend",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "h",
        "y2AxisLabel": " ",
        "stackTo100Percent": false
      },
      "usage_count": 0,
      "index": 26,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-07T12:53:50.717+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 405108,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Cycling Daily Work Chart",
      "description": "Daily work chart with kJ/h/kg and kJ over CP (total work) Need Scripts ",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/7c8290ab-74e6-4de5-9a61-9c5b744e5aa2",
      "content": {
        "id": "w51pqc9y",
        "name": "Cycling Daily Work Chart",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#009E0080",
            "text": "kJ",
            "type": "bars",
            "field": "work",
            "gauge": true,
            "scale": "kJ",
            "stack": "",
            "title": "Total work",
            "extras": [],
            "filter": "round0",
            "radius": 3,
            "stroke": "rgb(102,51,204)",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Work",
            "tickFormat": "customInput",
            "customInput": {
              "id": 396125,
              "name": "kJ/h/kg",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 12,
              "content": {
                "max": null,
                "min": null,
                "code": "WorkHourKg",
                "icon": "balance",
                "link": null,
                "name": "kJ/h/kg",
                "type": "numeric",
                "color": "#037E65",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": false,
                "prefix": null,
                "script": "(activity.icu_joules/1000)/(activity. moving_time/3600)/(activity.icu_weight)",
                "suffix": " kJ/h/kg",
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "AVERAGE",
                "pace_units": null,
                "number_format": ".1f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2024-08-21T17:36:46.518+00:00",
              "athlete_id": "i115436",
              "visibility": "PUBLIC",
              "description": "Kj/hour/kg",
              "hide_script": false,
              "usage_count": 4,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Total work",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#037E6580",
            "text": "kJ/h/kg",
            "type": "line",
            "field": "af_WorkHourKg",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "WorkHourKg",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#009E0080",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Work",
            "tickFormat": "customInput",
            "customInput": {
              "id": 396125,
              "name": "kJ/h/kg",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 12,
              "content": {
                "max": null,
                "min": null,
                "code": "WorkHourKg",
                "icon": "balance",
                "link": null,
                "name": "kJ/h/kg",
                "type": "numeric",
                "color": "#037E65",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": false,
                "prefix": null,
                "script": "(activity.icu_joules/1000)/(activity. moving_time/3600)/(activity.icu_weight)",
                "suffix": " kJ/h/kg",
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "AVERAGE",
                "pace_units": null,
                "number_format": ".1f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2024-08-21T17:36:46.518+00:00",
              "athlete_id": "i115436",
              "visibility": "PUBLIC",
              "description": "Kj/hour/kg",
              "hide_script": false,
              "usage_count": 4,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Total work",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#D62728FF",
            "text": "kJ",
            "type": "bars",
            "field": "af_AllWorkFTP",
            "gauge": true,
            "scale": "kJ",
            "stack": "",
            "title": "AllWorkFTP",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#EE2C6D",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide",
                  "GravelRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 396105,
              "name": "Work>CP",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 6,
              "content": {
                "max": null,
                "min": null,
                "code": "AllWorkFTP",
                "icon": "battery_alert",
                "link": null,
                "name": "Work>CP",
                "type": "numeric",
                "color": "#EE2C6D",
                "gauge": true,
                "total": null,
                "units": "kJ",
                "inline": false,
                "prefix": null,
                "script": "watts = streams.get(\"fixed_watts\").data\ntime =  streams.get(\"time\").data\nftp = activity.icu_ftp\njoules = 0\nfor (let i = 0; i < watts.length; i++) {\n  let w = watts[i]\n  if (w >= ftp) { \n    let secs = time[i] - (i > 0 ? time[i - 1] : 0)\n    if (secs < 30) joules += w * secs\n  }\n}\njoules/1000",
                "suffix": " kJ",
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "pace_units": null,
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": 83222,
              "updated": "2024-08-21T17:34:23.501+00:00",
              "athlete_id": "i115436",
              "visibility": "FOLLOWERS",
              "description": "The built in Work>FTP metric only counts the part of the work that is over FTP i.e. the area of the power curve above the FTP line. This measure includes the below the line portion when operating at or above FTP.",
              "hide_script": false,
              "usage_count": 4,
              "from_athlete": {
                "id": "2049151",
                "bio": "Software Engineer and keen cyclist!",
                "sex": "M",
                "city": "Cape Town",
                "name": "David (intervals.icu)",
                "email": null,
                "state": "Western Cape",
                "country": "South Africa",
                "website": "https://intervals.icu",
                "timezone": "Africa/Johannesburg",
                "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/37e18c85-cac7-4c45-8dc8-2e716f4b66d2"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#EE2C6D80",
            "text": "kJ/h/kg",
            "type": "line",
            "field": "af_WorkHourKgoverCP",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "WorkHourKgoverCP",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#D62728FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 396252,
              "name": "kJ/h/kg>CP",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 14,
              "content": {
                "max": null,
                "min": null,
                "code": "WorkHourKgoverCP",
                "icon": "balance",
                "link": null,
                "name": "kJ/h/kg>CP",
                "type": "numeric",
                "color": "#EE2C6D",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": false,
                "prefix": null,
                "script": "watts = streams.get(\"fixed_watts\").data\ntime =  streams.get(\"time\").data\nftp = activity.icu_ftp\njoules = 0\nfor (let i = 0; i < watts.length; i++) {\n  let w = watts[i]\n  if (w >= ftp) { \n    let secs = time[i] - (i > 0 ? time[i - 1] : 0)\n    if (secs < 30) joules += w * secs\n  }\n}\njoules/1000\n/(activity. moving_time/3600)/(activity.icu_weight)",
                "suffix": " kJ/h/kg",
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "AVERAGE",
                "pace_units": null,
                "number_format": ".1f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2024-08-21T17:36:56.459+00:00",
              "athlete_id": "i115436",
              "visibility": "PUBLIC",
              "description": "kJ per hour per kilo over CP considering total work above and belove power curve",
              "hide_script": false,
              "usage_count": 4,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 2,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "rgba(44,160,44, 0.4)",
            "text": "time",
            "type": "line",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide",
                  "GravelRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 1.2,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Daily Work",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 44,
      "index": 27,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-09T16:11:48.484+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 603917,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Peak 20m",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Peak20m",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nicu.powerCurve.getWatts(1200)\n}",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Peak 20m"
      },
      "usage_count": 1,
      "index": 27,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-26T10:35:53.933+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 694414,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "30s efforts chart",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "function getBestAverageOverNSeconds(data, n, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let bestAvg = 0;\n    let bestStart = 0;\n    let sum = 0;\n    // Initialize sum of the first window\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    bestAvg = sum / windowSize;\n    // Slide the window\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        if (avg > bestAvg) {\n            bestAvg = avg;\n            bestStart = i;\n        }\n    }\n    return { bestAvg, bestStart };\n}\n\nfunction getTopNBestAveragesOverNSeconds(data, n, topN = 2, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let results = [];\n    let sum = 0;\n    // Initialize sum of the first window\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    results.push({ avg: sum / windowSize, start: 0 });\n    // Slide the window\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        results.push({ avg, start: i });\n    }\n    // Sort by avg descending, filter out overlapping windows\n    results.sort((a, b) => b.avg - a.avg);\n    let nonOverlapping = [];\n    for (let i = 0; i < results.length && nonOverlapping.length < topN; i++) {\n        if (nonOverlapping.every(r => Math.abs(r.start - results[i].start) >= windowSize)) {\n            nonOverlapping.push(results[i]);\n        }\n    }\n    return nonOverlapping;\n}\n\n{\n    // Configuration\n    const WINDOW_SECONDS_30schart = 30; // 30 seconds\n    const TOP_N_30schart = 25;\n    const FTP_30schart = icu.activity.icu_ftp;\n\n    function getStreamData_30schart(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude_30schart = getStreamData_30schart(\"fixed_altitude\");\n    const distance_30schart = getStreamData_30schart(\"distance\");\n    const distanceKm_30schart = distance_30schart.map(d => d / 1000);\n    const power_30schart = getStreamData_30schart(\"fixed_watts\");\n    const heartrate_30schart = getStreamData_30schart(\"fixed_heartrate\");\n    const grade_30schart = getStreamData_30schart(\"grade_smooth\");\n    const time_30schart = getStreamData_30schart(\"time\");\n    const weight_30schart = icu.activity.icu_weight;\n\n    // Fix initial altitude values\n    const firstNonZeroAltitude_30schart = altitude_30schart.find(value => value !== 0);\n    if (firstNonZeroAltitude_30schart !== undefined) {\n        for (let i = 0; i < altitude_30schart.length; i++) {\n            if (altitude_30schart[i] === 0) {\n                altitude_30schart[i] = firstNonZeroAltitude_30schart;\n            } else {\n                break;\n            }\n        }\n    }\n\n    let traces_30schart = [\n        {\n            x: distanceKm_30schart,\n            y: altitude_30schart,\n            text: altitude_30schart.map(alt => `${alt.toFixed(1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Elevation'\n        }\n    ];\n    let annotations_30schart = [];\n    const bests_30schart = getTopNBestAveragesOverNSeconds(power_30schart, WINDOW_SECONDS_30schart, TOP_N_30schart, 1);\n    let idx = 0;\n    bests_30schart.forEach((best) => {\n        const avgPower = best.avg;\n        // Filter: only show efforts >= 130% FTP\n        if (avgPower < 1.3 * FTP_30schart) {\n            return;\n        }\n\n        const bestStart = best.start;\n        const bestEnd = bestStart + WINDOW_SECONDS_30schart;\n        const sectionPower = power_30schart.slice(bestStart, bestEnd);\n        const sectionHR = heartrate_30schart.slice(bestStart, bestEnd);\n        const sectionAltitude = altitude_30schart.slice(bestStart, bestEnd);\n        const sectionDistance = distance_30schart.slice(bestStart, bestEnd);\n        const sectionDistanceKm = distanceKm_30schart.slice(bestStart, bestEnd);\n        const sectionGrade = grade_30schart.slice(bestStart, bestEnd);\n        const sectionTime = time_30schart.slice(bestStart, bestEnd);\n\n        const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n        const maxHR = Math.max(...sectionHR);\n        const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n        const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n        const avgGrade = elevationGain / dist * 100;\n        const avgPowerPerKg = avgPower / weight_30schart;\n        const maxGrade = Math.max(...sectionGrade);\n        const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n        const ascentSpeed = elevationGain / (climbTimeInSeconds / 3600);\n        const avgHorizontalSpeed = (dist / 1000) / (climbTimeInSeconds / 3600);\n        const bgColor = getZoneColor(avgPower, FTP_30schart);\n        // 5s best power in this window\n        const best5s = getBestAverageOverNSeconds(sectionPower, 5, 1);\n        const best5sWatts = best5s.bestAvg;\n        const best5sPerKg = best5sWatts / weight_30schart;\n        // Theoretical values (as in your climb code)\n        const gradientFactor = (2 + avgGrade / 10) * 100;\n        const TEORICWKG = ascentSpeed / gradientFactor;\n        const TEORICVAM = avgPowerPerKg * gradientFactor;\n\n        // Calculate 3x10s avg watts for the 30\" effort\n        let avg10s1 = 0, avg10s2 = 0, avg10s3 = 0;\n        if (sectionPower.length >= 30) {\n            avg10s1 = sectionPower.slice(0, 10).reduce((a, b) => a + b, 0) / 10;\n            avg10s2 = sectionPower.slice(10, 20).reduce((a, b) => a + b, 0) / 10;\n            avg10s3 = sectionPower.slice(20, 30).reduce((a, b) => a + b, 0) / 10;\n        }\n        traces_30schart.push({\n            x: sectionDistanceKm,\n            y: sectionAltitude,\n            type: 'scatter',\n            mode: 'lines',\n            line: { color: bgColor, width: 2 },\n            name: `${avgPower.toFixed(0)} W | #${idx + 1}`,\n            hoverinfo: 'text',\n            visible: true,\n            hoverlabel: { align: 'left' },\n            text: [\n                `#${idx + 1}`,\n                ` ${(dist / 1000).toFixed(2)} km (${elevationGain.toFixed(0)} m)`,\n                `  ${avgGrade.toFixed(1)}% | max. ${maxGrade.toFixed(1)}%`,\n                ` ${avgPower.toFixed(0)} W | 5${best5sWatts.toFixed(0)}W`,\n                ` ${avg10s1.toFixed(0)} | ${avg10s2.toFixed(0)} | ${avg10s3.toFixed(0)}`,\n                ` ${avgPowerPerKg.toFixed(2)} W/kg | 5 ${best5sPerKg.toFixed(2)} W/kg`,\n                `  ${avgHR.toFixed(0)} bpm | max. ${maxHR} bpm`,\n                ` ${avgHorizontalSpeed.toFixed(1)} km/h |  ${ascentSpeed.toFixed(0)} m/h`\n            ].join('<br>')\n        });\n\n        // Offset annotation positions to avoid overlap\n        annotations_30schart.push({\n            // Add a small horizontal offset and lower the annotation closer to the profile\n            x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2 + (idx % 2 === 0 ? -1 : 1) * idx * 0.003, // alternate left/right, small step\n            y: Math.max(...sectionAltitude) + 50+ idx * 25, // lowered from 130 to 60\n            text: `#${idx + 1}<br> ${avgPower.toFixed(0)}`,\n            showarrow: false,\n            font: { family: 'Arial', size: 12, color: 'white' },\n            align: 'center',\n            bgcolor: bgColor,\n            opacity: 0.9\n        });\n        idx++;\n    });\n\n    const layout_30schart = {\n        title: `30\" efforts (>130% FTP)` ,\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations_30schart,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart_30schart = { data: traces_30schart, layout: layout_30schart };\n    chart_30schart;\n}\n\nfunction getZoneColor(avgPower, FTP) {\n    if (!FTP || FTP <= 0) return 'grey';\n    const percentage = (avgPower / FTP) * 100;\n\n    if (percentage < 141) return \"4c72b0\";        // Z2\n    if (percentage < 161) return \"55a868\";         // Z3\n    if (percentage < 201) return \"dd8452\";        // Z4 (ex gold, ora come Z3)\n    if (percentage < 251) return \"c44e52\";           // Z5\n    if (percentage < 301) return \"a64d79\";        // Z6\n    return \"8172b3\";                                // Z7+;\n}",
        "name": "30s efforts chart"
      },
      "usage_count": 0,
      "index": 27,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-03T19:28:34.824+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 744008,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "Custom Chart 1",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "Custom Chart 1",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "VAM",
            "color": "#1F77B4",
            "extras": [],
            "legend": false,
            "stream": "vam",
            "transform": "moving_avg",
            "areaOpacity": 0.05,
            "lineOpacity": 0.7,
            "transformArgs": {
              "secs": 120
            }
          }
        ],
        "title": null,
        "height": 60,
        "yAxisMax": null,
        "yAxisMin": 0.0,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 27,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-30T17:30:00.823+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 405145,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Cycling Weekly AvgWork (with0) Chart",
      "description": "Average weekly (WITH 0s) work with kJ/h/kg over and under CP (total work) Need Scripts ",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/cd251d42-102d-4c4b-977b-e7ce8719d1bb",
      "content": {
        "id": "0ihzyk4s",
        "name": "Cycling Weekly AvgWork (with0) Chart",
        "plots": [
          {
            "id": 1,
            "agg": "week_avg_per_day",
            "min": 0,
            "band": 0,
            "fill": "#009E0080",
            "text": "kJ",
            "type": "bars",
            "field": "work",
            "scale": "kJ",
            "stack": "",
            "title": "Total work",
            "extras": [],
            "filter": "round0",
            "radius": 3,
            "stroke": "rgb(102,51,204)",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Work",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Total work",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_avg_per_day",
            "min": 0,
            "band": 0,
            "fill": "#037E6580",
            "text": "kJ/h/kg",
            "type": "line",
            "field": "af_WorkHourKg",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "WorkHourKg",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#009E0080",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 396125,
              "name": "kJ/h/kg",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 12,
              "content": {
                "max": null,
                "min": null,
                "code": "WorkHourKg",
                "icon": "balance",
                "link": null,
                "name": "kJ/h/kg",
                "type": "numeric",
                "color": "#037E65",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": false,
                "prefix": null,
                "script": "(activity.icu_joules/1000)/(activity. moving_time/3600)/(activity.icu_weight)",
                "suffix": " kJ/h/kg",
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "AVERAGE",
                "pace_units": null,
                "number_format": ".1f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2024-08-21T17:36:46.518+00:00",
              "athlete_id": "i115436",
              "visibility": "PUBLIC",
              "description": "Kj/hour/kg",
              "hide_script": false,
              "usage_count": 4,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 2,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "week_avg_per_day",
            "min": 0,
            "band": 0,
            "fill": "#D62728FF",
            "text": "kJ",
            "type": "bars",
            "field": "af_AllWorkFTP",
            "gauge": true,
            "scale": "kJ",
            "stack": "",
            "title": "AllWorkFTP",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#EE2C6D",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide",
                  "GravelRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 396105,
              "name": "Work>CP",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 6,
              "content": {
                "max": null,
                "min": null,
                "code": "AllWorkFTP",
                "icon": "battery_alert",
                "link": null,
                "name": "Work>CP",
                "type": "numeric",
                "color": "#EE2C6D",
                "gauge": true,
                "total": null,
                "units": "kJ",
                "inline": false,
                "prefix": null,
                "script": "watts = streams.get(\"fixed_watts\").data\ntime =  streams.get(\"time\").data\nftp = activity.icu_ftp\njoules = 0\nfor (let i = 0; i < watts.length; i++) {\n  let w = watts[i]\n  if (w >= ftp) { \n    let secs = time[i] - (i > 0 ? time[i - 1] : 0)\n    if (secs < 30) joules += w * secs\n  }\n}\njoules/1000",
                "suffix": " kJ",
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "pace_units": null,
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": 83222,
              "updated": "2024-08-21T17:34:23.501+00:00",
              "athlete_id": "i115436",
              "visibility": "FOLLOWERS",
              "description": "The built in Work>FTP metric only counts the part of the work that is over FTP i.e. the area of the power curve above the FTP line. This measure includes the below the line portion when operating at or above FTP.",
              "hide_script": false,
              "usage_count": 4,
              "from_athlete": {
                "id": "2049151",
                "bio": "Software Engineer and keen cyclist!",
                "sex": "M",
                "city": "Cape Town",
                "name": "David (intervals.icu)",
                "email": null,
                "state": "Western Cape",
                "country": "South Africa",
                "website": "https://intervals.icu",
                "timezone": "Africa/Johannesburg",
                "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/37e18c85-cac7-4c45-8dc8-2e716f4b66d2"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "week_avg_per_day",
            "min": 0,
            "band": 0,
            "fill": "#EE2C6D80",
            "text": "kJ/h/kg",
            "type": "line",
            "field": "af_WorkHourKgoverCP",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "WorkHourKgoverCP",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#D62728FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 396252,
              "name": "kJ/h/kg>CP",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 14,
              "content": {
                "max": null,
                "min": null,
                "code": "WorkHourKgoverCP",
                "icon": "balance",
                "link": null,
                "name": "kJ/h/kg>CP",
                "type": "numeric",
                "color": "#EE2C6D",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": false,
                "prefix": null,
                "script": "watts = streams.get(\"fixed_watts\").data\ntime =  streams.get(\"time\").data\nftp = activity.icu_ftp\njoules = 0\nfor (let i = 0; i < watts.length; i++) {\n  let w = watts[i]\n  if (w >= ftp) { \n    let secs = time[i] - (i > 0 ? time[i - 1] : 0)\n    if (secs < 30) joules += w * secs\n  }\n}\njoules/1000\n/(activity. moving_time/3600)/(activity.icu_weight)",
                "suffix": " kJ/h/kg",
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "AVERAGE",
                "pace_units": null,
                "number_format": ".1f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2024-08-21T17:36:56.459+00:00",
              "athlete_id": "i115436",
              "visibility": "PUBLIC",
              "description": "kJ per hour per kilo over CP considering total work above and belove power curve",
              "hide_script": false,
              "usage_count": 4,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 2,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "week_avg_per_day",
            "min": 0,
            "band": 0,
            "fill": "rgba(44,160,44, 0.4)",
            "text": "time",
            "type": "line",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "VirtualRide",
                  "GravelRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 0.8,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Weekly Work",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 25,
      "index": 28,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-09T16:12:02.811+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 603918,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Peak 60m",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Peak60m",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nicu.powerCurve.getWatts(3600)\n}",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Peak 60m"
      },
      "usage_count": 1,
      "index": 28,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-03-26T10:36:40.133+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 694421,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "best 30\" bar",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "300px",
        "script": "// Bar chart for all 30s efforts above 105% FTP\nconst DURATION_30sbar = 30;\nconst activity_30sbar = icu.activity;\nconst weight_30sbar = activity_30sbar.icu_weight;\nconst FTP_30sbar = activity_30sbar.icu_ftp;\n\nfunction getStreamData_30sbar(streamName) {\n    const stream = icu.streams.get(streamName);\n    return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\nconst power_30sbar = getStreamData_30sbar(\"fixed_watts\");\n\n// Get all non-overlapping 30s efforts above 105% FTP (exclude overlapping windows)\nfunction getNonOverlappingEffortsAboveThreshold_30sbar(data, n, threshold, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let results = [];\n    let sum = 0;\n    if (data.length < windowSize) return results;\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    let candidates = [];\n    if (sum / windowSize >= threshold) {\n        candidates.push({ avg: sum / windowSize, start: 0 });\n    }\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        if (avg >= threshold) {\n            candidates.push({ avg, start: i });\n        }\n    }\n    // Sort by avg descending\n    candidates.sort((a, b) => b.avg - a.avg);\n    let used = Array(data.length).fill(false);\n    for (const cand of candidates) {\n        let overlap = false;\n        for (let j = cand.start; j < cand.start + windowSize; j++) {\n            if (used[j]) {\n                overlap = true;\n                break;\n            }\n        }\n        if (!overlap) {\n            results.push(cand);\n            for (let j = cand.start; j < cand.start + windowSize; j++) {\n                used[j] = true;\n            }\n        }\n    }\n    // Sort by start time ascending for display\n    results.sort((a, b) => a.start - b.start);\n    return results;\n}\n\n\nlet x_30sbar = [];\nlet y_30sbar = [];\nlet hover_30sbar = [];\nlet effortData_30sbar = [];\nconst VISIBLE_BARS_30sbar = 7; // Number of bars visible at once\nconst heartrate_30sbar = getStreamData_30sbar(\"fixed_heartrate\");\nconst time_30sbar = getStreamData_30sbar(\"time\");\nconst distance_30sbar = getStreamData_30sbar(\"distance\");\nconst altitude_30sbar = getStreamData_30sbar(\"fixed_altitude\");\nconst grade_30sbar = getStreamData_30sbar(\"grade_smooth\");\nfunction secondsToHms_30sbar(seconds) {\n    seconds = Math.floor(seconds);\n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = seconds % 60;\n    let str = '';\n    if (h > 0) str += String(h).padStart(2, '0') + ':';\n    str += (h > 0 ? String(m).padStart(2, '0') : m) + ':' + String(s).padStart(2, '0');\n    return str;\n}\nconst threshold_30sbar = 1.3 * FTP_30sbar; // EFFORT THRESHOLD\n\nconst allEfforts_30sbar = getNonOverlappingEffortsAboveThreshold_30sbar(power_30sbar, DURATION_30sbar, threshold_30sbar, 1);\nfor (const [idx, best] of allEfforts_30sbar.entries()) {\n    const bestStart = best.start;\n    const bestEnd = bestStart + DURATION_30sbar;\n    const sectionHR = heartrate_30sbar.slice(bestStart, bestEnd);\n    const sectionDistance = distance_30sbar.slice(bestStart, bestEnd);\n    const sectionAltitude = altitude_30sbar.slice(bestStart, bestEnd);\n    const sectionGrade = grade_30sbar.slice(bestStart, bestEnd);\n    const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n    const maxHR = Math.max(...sectionHR);\n    const startTime = secondsToHms_30sbar(time_30sbar[bestStart]);\n    const avgPower = best.avg;\n    const avgPowerPerKg = avgPower / weight_30sbar;\n    const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n    const distKm = dist / 1000;\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const avgGrade = elevationGain / dist * 100;\n    const maxGrade = Math.max(...sectionGrade);\n    // Ratio: primo 15s, secondo 15s, ratio\n    const firstHalf = power_30sbar.slice(bestStart, bestStart + DURATION_30sbar/2);\n    const secondHalf = power_30sbar.slice(bestStart + DURATION_30sbar/2, bestEnd);\n    const rat_1 = firstHalf.reduce((a,b)=>a+b,0)/firstHalf.length;\n    const rat_2 = secondHalf.reduce((a,b)=>a+b,0)/secondHalf.length;\n    const ratio = rat_2 / rat_1;\n    // VAM\n    const climbTimeH = DURATION_30sbar / 3600;\n    const ascentSpeed = elevationGain / climbTimeH;\n    const avgHorizontalSpeed = distKm / (DURATION_30sbar / 3600);\n    // Best 5s\n    let best5sWatts = 0;\n    for (let i = 0; i <= power_30sbar.slice(bestStart, bestEnd).length - 5; i++) {\n        const avg5 = power_30sbar.slice(bestStart + i, bestStart + i + 5).reduce((a,b)=>a+b,0)/5;\n        if (avg5 > best5sWatts) best5sWatts = avg5;\n    }\n    const best5sPerKg = best5sWatts / weight_30sbar;\n    // Teorici (come in PIAN HC)\n    const gradientFactor = (2 + avgGrade / 10) * 100;\n    const TEORICWKG = ascentSpeed / gradientFactor;\n    const TEORICVAM = avgPowerPerKg * gradientFactor;\n    effortData_30sbar.push({\n        idx,\n        avgPower,\n        avgPowerPerKg,\n        avgHR,\n        maxHR,\n        startTime,\n        bestStart,\n        dist,\n        distKm,\n        elevationGain,\n        avgGrade,\n        maxGrade,\n        rat_1,\n        rat_2,\n        ratio,\n        ascentSpeed,\n        avgHorizontalSpeed,\n        best5sWatts,\n        best5sPerKg,\n        TEORICWKG,\n        TEORICVAM\n    });\n}\n\n// Ordina per watt decrescente\neffortData_30sbar.sort((a, b) => b.avgPower - a.avgPower);\nfor (const [i, effort] of effortData_30sbar.entries()) {\n    x_30sbar.push(`${i+1}`);\n    y_30sbar.push(effort.avgPower);\n    hover_30sbar.push(\n        ` ${(effort.dist / 1000).toFixed(2)} km (${effort.elevationGain.toFixed(0)} m)<br>`+\n        `  ${effort.avgGrade.toFixed(1)}% | max. ${effort.maxGrade.toFixed(1)}%<br>`+\n        ` ${effort.avgPower.toFixed(0)} W | 5 ${effort.best5sWatts.toFixed(0)} W<br>`+\n        ` ${effort.avgPowerPerKg.toFixed(2)} W/kg | 5 ${effort.best5sPerKg.toFixed(2)} W/kg<br>`+\n        ` ${effort.rat_1.toFixed(0)} W | ${effort.rat_2.toFixed(0)} W | ${(effort.ratio).toFixed(2)}<br>`+\n        `  ${effort.avgHR.toFixed(0)} bpm | max. ${effort.maxHR} bpm<br>`+\n        ` ${effort.avgHorizontalSpeed.toFixed(1)} km/h |  ${effort.ascentSpeed.toFixed(0)} m/h<br>`+\n        ` ${effort.startTime}`\n    );\n}\n\n\nfunction getZoneColor_30sbar(avgPower, ftp) {\n    const percentage = (avgPower / ftp) * 100;\n    if (percentage < 141) return \"4c72b0\";        // Z2\n    if (percentage < 161) return \"55a868\";         // Z3\n    if (percentage < 201) return \"dd8452\";        // Z4 (ex gold, ora come Z3)\n    if (percentage < 251) return \"c44e52\";           // Z5\n    if (percentage < 301) return \"a64d79\";        // Z6\n    return \"8172b3\";                                // Z7+;\n}\n\nconst barColors_30sbar = y_30sbar.map((v) => getZoneColor_30sbar(v, FTP_30sbar));\n\nconst data_30sbar = [\n  {\n    x: x_30sbar,\n    y: y_30sbar,\n    type: 'bar',\n    marker: {\n      color: barColors_30sbar\n    },\n    text: x_30sbar.map((label, i) =>\n      `${y_30sbar[i].toFixed(0)} W | ${effortData_30sbar[i].avgPowerPerKg.toFixed(2)} W/kg<br>`\n      + `${effortData_30sbar[i].rat_1.toFixed(0)} W | ${effortData_30sbar[i].rat_2.toFixed(0)} W | ${effortData_30sbar[i].ratio.toFixed(2)}<br>`\n      + ` ${effortData_30sbar[i].avgHR.toFixed(0)} bpm | ${effortData_30sbar[i].maxHR} bpm<br>`\n      + `${effortData_30sbar[i].ascentSpeed.toFixed(0)} m/h |  ${effortData_30sbar[i].avgGrade.toFixed(1)}%<br>`\n      + `${effortData_30sbar[i].startTime}`\n    ),\n    textposition: 'inside',\n    insidetextanchor: 'start',\n    textfont: {\n      color: '#000',\n      size: 13,\n      family: 'Arial Black'\n    },\n    hoverinfo: 'text',\n    hovertext: hover_30sbar,\n    hoverlabel: { font: { color: '#000', family: 'Arial', size: 13 }, align: 'left' },\n    name: 'Avg Power',\n    visible: true\n  }\n];\n\n\nconst layout_30sbar = {\n  title: '30\" efforts (>130% FTP)',\n  barmode: 'group',\n  showlegend: false,\n  height: 250,\n  margin: {l: 40, r: 20, t: 40, b: 40},\n  xaxis: {\n    title: 'Effort',\n    range: [0, VISIBLE_BARS_30sbar - 0.5], // Show only n bars at a time\n    fixedrange: false,\n    autorange: false,\n    tickmode: 'linear',\n    tick0: 1,\n    dtick: 1,\n    showgrid: true,\n    gridcolor: '#eee',\n    gridwidth: 1,\n    scrollZoom: true    // Show only n bars at a time\n  },\n  yaxis: {\n    title: 'Avg Power (W)',\n    dtick: 50, // Griglia ogni 50 watt\n    gridcolor: '#ccc',\n    gridwidth: 1\n  },\n};\n\nchart = { data: data_30sbar, layout: layout_30sbar };\nchart;",
        "name": "best 30\" bar"
      },
      "usage_count": 0,
      "index": 28,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-03T18:47:10.831+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 819548,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "DFA a1",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "DFA a1",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "DFA a1 90s",
            "color": "#1f77b4ff",
            "extras": [
              {
                "id": 1,
                "y1": 0.75,
                "y2": null,
                "fill": "#009e0000",
                "text": "HRVT1",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333ff",
                "opacity": 1
              },
              {
                "id": 2,
                "y1": 0.5,
                "y2": null,
                "fill": "#009e0000",
                "text": "HRVT2",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "top",
                "stroke": "#333333ff",
                "opacity": 1
              }
            ],
            "legend": true,
            "stream": "dfa_a1",
            "transform": "moving_avg",
            "areaOpacity": 0.3,
            "lineOpacity": 1,
            "strokeWidth": 1.2,
            "transformArgs": {
              "secs": 90
            }
          },
          {
            "id": 2,
            "axis": null,
            "text": "HR",
            "color": "#dd0447ff",
            "extras": [],
            "legend": true,
            "stream": "heartrate_exp",
            "transform": "moving_avg",
            "areaOpacity": 0.5,
            "lineOpacity": 1,
            "transformArgs": {
              "secs": 10
            }
          }
        ],
        "title": null,
        "height": 90,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 28,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-11-06T19:55:21.858+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 446785,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Cycling time + HRV",
      "description": "Time in zones using 3 zone model + hours total and 14 days trend. ONLY CYCLING",
      "image": null,
      "content": {
        "id": "vedkbyft",
        "name": "Cycling time + HRV",
        "plots": [
          {
            "id": "time_in_s3",
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(221,4,71,0.5)",
            "text": "Z5+",
            "type": "bars",
            "field": "time_in_s3",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z5, Z6 and Z7",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z5+",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z5, Z6 and Z7",
            "showOnCalendar": false,
            "calendarOptions": {
              "day1": true,
              "day2": true,
              "day3": true,
              "day4": true,
              "day5": true,
              "day6": true,
              "day7": true,
              "label": "Z5+ ",
              "units": " hours",
              "weekPopupDay": 7,
              "weekSummaryDay": 7
            },
            "invertSubWellness": false
          },
          {
            "id": "time_in_s2",
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(255,127,14, 0.5)",
            "text": "Z3+4",
            "type": "bars",
            "field": "time_in_s2",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z3 and Z4",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(255,127,14)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z3+4",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z3 and Z4",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": "time_in_s1",
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(0,158,0, 0.4)",
            "text": "Z1+2",
            "type": "bars",
            "field": "time_in_s1",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z1 and Z2",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(0,158,0)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z1+2",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z1 and Z2",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 1,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#000000ff",
            "text": "Day",
            "type": "dot",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 0.2,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#8d824700",
            "text": "Weekly",
            "type": "bars",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(44,160,44)",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#334cccff",
            "text": "HRV",
            "type": "dot",
            "field": "hrv",
            "gauge": true,
            "scale": "ms",
            "stack": "",
            "title": "Heartrate variability",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#334CCCFF",
            "filters": [],
            "i18nKey": "HRV rMSSD",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Heartrate variability",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "moving_avg",
            "min": null,
            "band": 0,
            "fill": "#d627284d",
            "text": "HRV 7d",
            "type": "line",
            "field": "hrv",
            "gauge": true,
            "scale": "ms",
            "stack": "",
            "title": "Heartrate variability",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#334cccff",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "HRV rMSSD",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Heartrate variability",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#6633cc4d",
            "text": "kJ",
            "type": "line",
            "field": "work",
            "scale": "kJ",
            "stack": "",
            "title": "Total work",
            "extras": [],
            "filter": "round0",
            "radius": 3,
            "stroke": "#dd04a7ff",
            "filters": [],
            "i18nKey": "Work",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Total work",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "moving_avg",
            "min": null,
            "band": 0.4,
            "fill": "#1F77B438",
            "text": "HRV Normal",
            "type": "line",
            "field": "hrv",
            "gauge": true,
            "scale": "ms",
            "stack": "",
            "title": "Heartrate variability",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#334CCCFF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "HRV rMSSD",
            "markerValue": "right",
            "strokeWidth": 0.75,
            "i18nTitleKey": "Heartrate variability",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Time + HRV",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Power zones (h)",
        "y2AxisLabel": " ",
        "stackTo100Percent": false
      },
      "usage_count": 5,
      "index": 29,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-09T16:12:23.195+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 694442,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "5s chart surges",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(function() {\nconst CONFIG_5smap = {\n// =====================\n// CONFIGURAZIONE PRINCIPALE\n// =====================\n  WINDOW_SECONDS: 5,                // Durata finestra sforzo (secondi)\n  MIN_EFFORT_INTENSITY_FTP: 220,    // Soglia minima effort (% FTP)\n// ============================================================================\n  ZONES: [\n    { name: 'Z2', max: 251, color: '#4c72b0' },\n    { name: 'Z3', max: 301, color: '#55a868' },\n    { name: 'Z4', max: 351, color: '#dd8452' },\n    { name: 'Z5', max: 401, color: '#c44e52' },\n    { name: 'Z6', max: 451, color: '#a64d79' },\n    { name: 'Z7', max: Infinity, color: '#8172b3' }\n  ],\n  BAR_TEXT_COLOR: '#000000',\n  BAR_TEXT_FONT: { family: 'Arial Black', size: 13 },\n  GRID_X_COLOR: '#EEEEEE',\n  GRID_X_WIDTH: 1,\n  GRID_Y_COLOR: '#CCCCCC',\n  GRID_Y_WIDTH: 1,\n};\n// =====================\n// FINE CONFIGURAZIONE\nfunction getBestAverageOverNSeconds(data, n, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let bestAvg = 0;\n    let bestStart = 0;\n    let sum = 0;\n    // Initialize sum of the first window\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    bestAvg = sum / windowSize;\n    // Slide the window\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        if (avg > bestAvg) {\n            bestAvg = avg;\n            bestStart = i;\n        }\n    }\n    return { bestAvg, bestStart };\n}\n\nfunction getTopNBestAveragesOverNSeconds(data, n, topN = 2, samplingRate = 1) {\n    const windowSize = n * samplingRate;\n    let results = [];\n    let sum = 0;\n    // Initialize sum of the first window\n    for (let i = 0; i < windowSize; i++) {\n        sum += data[i];\n    }\n    results.push({ avg: sum / windowSize, start: 0 });\n    // Slide the window\n    for (let i = 1; i <= data.length - windowSize; i++) {\n        sum = sum - data[i - 1] + data[i + windowSize - 1];\n        const avg = sum / windowSize;\n        results.push({ avg, start: i });\n    }\n    // Sort by avg descending, filter out overlapping windows\n    results.sort((a, b) => b.avg - a.avg);\n    let nonOverlapping = [];\n    for (let i = 0; i < results.length && nonOverlapping.length < topN; i++) {\n        if (nonOverlapping.every(r => Math.abs(r.start - results[i].start) >= windowSize)) {\n            nonOverlapping.push(results[i]);\n        }\n    }\n    return nonOverlapping;\n}\n\n{\n    // Configurazione\n    const WINDOW_SECONDS = CONFIG_5smap.WINDOW_SECONDS;\n    const FTP = icu.activity.icu_ftp;\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    // Fix initial altitude values\n    const firstNonZeroAltitude = altitude.find(value => value !== 0);\n    if (firstNonZeroAltitude !== undefined) {\n        for (let i = 0; i < altitude.length; i++) {\n            if (altitude[i] === 0) {\n                altitude[i] = firstNonZeroAltitude;\n            } else {\n                break;\n            }\n        }\n    }\n\n    let traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map(alt => `${alt.toFixed(1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Elevation'\n        }\n    ];\n    let annotations = [];\n    // Trova tutti gli sforzi non sovrapposti sopra la soglia configurata\n    function getAllNonOverlappingEffortsAboveThreshold(data, n, threshold, samplingRate = 1) {\n        const windowSize = n * samplingRate;\n        let results = [];\n        let sum = 0;\n        if (data.length < windowSize) return results;\n        for (let i = 0; i < windowSize; i++) {\n            sum += data[i];\n        }\n        let candidates = [];\n        if (sum / windowSize >= threshold) {\n            candidates.push({ avg: sum / windowSize, start: 0 });\n        }\n        for (let i = 1; i <= data.length - windowSize; i++) {\n            sum = sum - data[i - 1] + data[i + windowSize - 1];\n            const avg = sum / windowSize;\n            if (avg >= threshold) {\n                candidates.push({ avg, start: i });\n            }\n        }\n        // Sort by avg descending\n        candidates.sort((a, b) => b.avg - a.avg);\n        let used = Array(data.length).fill(false);\n        for (const cand of candidates) {\n            let overlap = false;\n            for (let j = cand.start; j < cand.start + windowSize; j++) {\n                if (used[j]) {\n                    overlap = true;\n                    break;\n                }\n            }\n            if (!overlap) {\n                results.push(cand);\n                for (let j = cand.start; j < cand.start + windowSize; j++) {\n                    used[j] = true;\n                }\n            }\n        }\n        // Sort by start time ascending for display\n        results.sort((a, b) => a.start - b.start);\n        return results;\n    }\n\n    const threshold = (CONFIG_5smap.MIN_EFFORT_INTENSITY_FTP / 100) * FTP;\n    const allEfforts = getAllNonOverlappingEffortsAboveThreshold(power, WINDOW_SECONDS, threshold, 1);\n    // Sort allEfforts by avgPower descending for legend order\n    const sortedEfforts = allEfforts.slice().sort((a, b) => b.avg - a.avg);\n    sortedEfforts.forEach((best, idx) => {\n        const avgPower = best.avg;\n        const bestStart = best.start;\n        const bestEnd = bestStart + WINDOW_SECONDS;\n        const sectionPower = power.slice(bestStart, bestEnd);\n        const sectionHR = heartrate.slice(bestStart, bestEnd);\n        const sectionAltitude = altitude.slice(bestStart, bestEnd);\n        const sectionDistance = distance.slice(bestStart, bestEnd);\n        const sectionDistanceKm = distanceKm.slice(bestStart, bestEnd);\n        const sectionGrade = grade.slice(bestStart, bestEnd);\n        const sectionTime = time.slice(bestStart, bestEnd);\n\n        // --- Metrics block ---\n        const minHR = Math.min(...sectionHR);\n        const maxHR = Math.max(...sectionHR);\n        const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n        const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n        const avgGrade = elevationGain / dist * 100;\n        const avgPowerPerKg = avgPower / weight;\n        const maxGrade = Math.max(...sectionGrade);\n        const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n        const ascentSpeed = elevationGain / (climbTimeInSeconds / 3600);\n        // --- Speed details ---\n        let v1 = '', v2 = '';\n        if (sectionDistanceKm.length >= 2) {\n            v1 = ((sectionDistanceKm[1] - sectionDistanceKm[0]) * 3600).toFixed(1); // km/h primo secondo\n            v2 = ((sectionDistanceKm[sectionDistanceKm.length-1] - sectionDistanceKm[sectionDistanceKm.length-2]) * 3600).toFixed(1); // km/h ultimo secondo\n        }\n        // --- Start time ---\n        let startTime = '';\n        if (sectionTime && sectionTime.length > 0) {\n            startTime = sectionTime[0].toFixed(1);\n        }\n        // --- Power min/max ---\n        let minWatt = null, maxWatt = null;\n        if (sectionPower.length > 0) {\n            minWatt = Math.min(...sectionPower);\n            maxWatt = Math.max(...sectionPower);\n        }\n        // --- kJ and kJ/h/kg up to effort start ---\n        let bgColor = getZoneColor(avgPower, FTP);\n        if (bgColor && !bgColor.startsWith('#')) bgColor = '#' + bgColor;\n        let joules = 0, joulesOverCP = 0;\n        if (power && time && bestStart !== undefined && bestStart < power.length && FTP) {\n            for (let i = 0; i < bestStart; i++) {\n                let w = power[i];\n                let secs = time[i] - (i > 0 ? time[i - 1] : 0);\n                if (secs < 30) {\n                    joules += w * secs;\n                    if (w >= FTP) joulesOverCP += w * secs;\n                }\n            }\n        }\n        const hours = (time && bestStart !== undefined && time[bestStart]) ? (time[bestStart] / 3600) : 0;\n        let kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n        let kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n        // --- Trace text layout (organized) ---\n        function formatSecondsToHHMMSS(seconds) {\n            const sec = Math.floor(seconds % 60);\n            const min = Math.floor((seconds / 60) % 60);\n            const hr = Math.floor(seconds / 3600);\n            return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n        }\n        const traceText = [\n            `#${idx + 1}`,\n            ` ${avgPower.toFixed(0)} W   ${avgPowerPerKg.toFixed(2)} W/kg`,\n            ` ${maxWatt !== null ? maxWatt : ''} W |${minWatt !== null ? minWatt : ''} W`,\n            ` ${minHR.toFixed(0)} bpm |${maxHR} bpm`,\n            v1 && v2 ? ` ${v1} km/h | ${v2} km/h` : '',\n            `  ${avgGrade.toFixed(1)}% max. ${maxGrade.toFixed(1)}%`,\n            startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '',\n            ` ${Math.round(joules/1000)} kJ | ${Math.round(joulesOverCP/1000)} kJ > CP`,\n            ` ${kJ_h_kg.toFixed(1)} kJ/h/kg | ${kJ_h_kg_overCP.toFixed(1)} kJ/h/kg > CP`\n        ].filter(Boolean).join('<br>');\n        traces.push({\n            x: sectionDistanceKm,\n            y: sectionAltitude,\n            type: 'scatter',\n            mode: 'lines',\n            line: { color: bgColor, width: 2 },\n            name: `${avgPower.toFixed(0)} W | #${idx + 1}`,\n            hoverinfo: 'text',\n            visible: true,\n            hoverlabel: { align: 'left' },\n            text: traceText\n        });\n\n        // Offset annotation positions to avoid overlap\n        annotations.push({\n            x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2 + (idx % 2 === 0 ? -1 : 1) * idx * 0.003,\n            y: Math.max(...sectionAltitude) + 50 + idx * 25,\n            text: `#${idx + 1}<br> ${avgPower.toFixed(0)}`,\n            showarrow: false,\n            font: { family: 'Arial', size: 12, color: 'white' },\n            align: 'center',\n            bgcolor: bgColor,\n            opacity: 0.9\n        });\n    });\n\n    const layout = {\n        title: `All ${CONFIG_5smap.WINDOW_SECONDS}\" Power Efforts >${CONFIG_5smap.MIN_EFFORT_INTENSITY_FTP}% FTP` ,\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    globalThis.chart = chart;\n    return chart;\n}\n\nfunction getZoneColor(avgPower, FTP) {\n    if (!FTP || FTP <= 0) return 'grey';\n    const percentage = (avgPower / FTP) * 100;\n    for (const zone of CONFIG_5smap.ZONES) {\n        if (percentage < zone.max) return zone.color;\n    }\n    return '#000'; // fallback\n}\n})();",
        "name": "5s chart surges"
      },
      "usage_count": 0,
      "index": 29,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-19T09:07:21.917+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 914817,
      "athlete_id": "i115436",
      "type": "TRACE_CHART",
      "visibility": "PRIVATE",
      "name": "w/kg COMPARE",
      "description": null,
      "image": null,
      "content": {
        "id": null,
        "name": "w/kg COMPARE",
        "plots": [
          {
            "id": 1,
            "axis": null,
            "text": "W/Kg",
            "color": "#1F77B4",
            "extras": [],
            "legend": false,
            "stream": "WKg",
            "transform": "moving_avg",
            "areaOpacity": 0.15,
            "lineOpacity": 2,
            "transformArgs": {
              "secs": 360
            }
          }
        ],
        "title": null,
        "height": 270,
        "yAxisMax": null,
        "yAxisMin": null,
        "legendPos": "topLeft",
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null
      },
      "usage_count": 0,
      "index": 29,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2026-01-21T13:07:55.276+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504087,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PUBLIC",
      "name": "Mood CHR",
      "description": "Mood trend on 42days and 7days",
      "image": "https://storage.googleapis.com/intervals-icu-images/custom_items/e5512480-2e53-49bb-b002-ed109c08c284",
      "content": {
        "id": "rhuqwvqc",
        "name": "Mood CHR",
        "plots": [
          {
            "id": 2,
            "agg": "none",
            "min": 1,
            "band": 0,
            "fill": "#8D824700",
            "text": "Mood",
            "type": "bars",
            "field": "mood",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Mood",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#34ACE4FF",
                "text": "GREAT",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#16BB16FF",
                "text": "GOOD",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#FFB000FF",
                "text": "OK",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#FF520EFF",
                "text": "GRUMPY",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.85
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(255,0,255)",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Mood",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Mood",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": 1,
            "band": 0,
            "fill": "rgba(255,0,255, 0.4)",
            "text": "Mood 7d",
            "type": "line",
            "field": "mood",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Mood",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Mood",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Mood",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "moving_avg",
            "min": 1,
            "band": 0.6,
            "fill": "#50486180",
            "text": "Mood 42d",
            "type": "line",
            "field": "mood",
            "gauge": true,
            "scale": "1-4",
            "stack": "",
            "title": "Mood",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000FF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Mood",
            "markerValue": "right",
            "strokeWidth": 1.6,
            "i18nTitleKey": "Mood",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Chronic Mood",
        "height": 165,
        "yAxisMax": 4.5,
        "yAxisMin": 0.5,
        "y2AxisMax": 4.5,
        "y2AxisMin": 0.5,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Mood",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 3,
      "index": 30,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:20:47.128+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504117,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "FOLLOWERS",
      "name": "RPE CHR",
      "description": null,
      "image": null,
      "content": {
        "id": "snyfyzz7",
        "name": "RPE CHR",
        "plots": [
          {
            "id": 1,
            "agg": "moving_avg",
            "min": null,
            "band": 0.4,
            "fill": "#33333380",
            "text": "RPE END",
            "type": "line",
            "field": "rpe",
            "gauge": true,
            "scale": "rpe",
            "stack": "",
            "title": "Rate of Perceived Exertion",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#009E80FF",
                "text": "1 - Nothing at all",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#009E80FF",
                "text": "2 - Very easy",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#009E00FF",
                "text": "3 - Easy",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#DBAC00FF",
                "text": "4 - Confortable",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 5,
                "y1": 4.5,
                "y2": 5.5,
                "fill": "#FF7F0EFF",
                "text": "5 - Slightly challenging",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 6,
                "y1": 5.5,
                "y2": 6.5,
                "fill": "#FF7F0EFF",
                "text": "6 - Difficoult",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 7,
                "y1": 6.5,
                "y2": 7.5,
                "fill": "#DD0447FF",
                "text": "7 - Hard",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 8,
                "y1": 7.5,
                "y2": 8.5,
                "fill": "#DD0447FF",
                "text": "8 - Very hard",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 9,
                "y1": 8.5,
                "y2": 9.5,
                "fill": "#6633CCFF",
                "text": "9 - Extremely hard",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 10,
                "y1": 9.5,
                "y2": 10.5,
                "fill": "#504861FF",
                "text": "10 - Max effort",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              }
            ],
            "radius": 3,
            "stroke": "#0E7BF1FF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "RPE",
            "markerValue": "none",
            "strokeWidth": 1.5,
            "i18nTitleKey": "Rate of Perceived Exertion",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": null,
            "band": 0.4,
            "fill": "#50486180",
            "text": "RPE STR",
            "type": "line",
            "field": "rpe",
            "gauge": true,
            "scale": "rpe",
            "stack": "",
            "title": "Rate of Perceived Exertion",
            "extras": [],
            "radius": 3,
            "stroke": "#EE2C6DFF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "WeightTraining",
                  "Workout"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "RPE",
            "markerValue": "none",
            "strokeWidth": 1.5,
            "i18nTitleKey": "Rate of Perceived Exertion",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#8D824700",
            "text": "RPE",
            "type": "bars",
            "field": "rpe",
            "gauge": true,
            "scale": "rpe",
            "stack": "",
            "title": "Rate of Perceived Exertion",
            "extras": [],
            "radius": 3,
            "stroke": "rgb(102,51,204)",
            "filters": [],
            "i18nKey": "RPE",
            "markerValue": "top",
            "strokeWidth": 1,
            "i18nTitleKey": "Rate of Perceived Exertion",
            "invertSubWellness": false
          }
        ],
        "title": "RPE 42d",
        "height": 220,
        "yAxisMax": 10.5,
        "yAxisMin": 0.5,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "RPE",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 1,
      "index": 31,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:21:30.172+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 698414,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "Pedaling Technique Analysis",
      "description": "## Anlisis de Tcnica de Pedaleo (ES)\n\nEste grfico de barras muestra un anlisis completo de la tcnica de pedaleo comparando las mtricas entre pierna izquierda (rojo) y derecha (turquesa). \n\n**Mtricas analizadas:**\n- Balance I/D: Distribucin de la potencia entre ambas piernas\n- Efectividad de Torque: Eficiencia en la aplicacin de fuerza en el pedal\n- Suavidad: Fluidez del pedaleo durante toda la rotacin\n- GPR (Potencia Liberada): Potencia efectiva que contribuye al movimiento\n- GPA (Potencia Absorbida): Potencia perdida durante el pedaleo\n\nEl grfico incluye una seccin de totales (naranja) que muestra el GPR y GPA combinados. Los valores en porcentaje se muestran en el eje izquierdo y los valores de potencia en el eje derecho.\n\n---\n\n## Pedaling Technique Analysis Chart (EN)\n\nThis bar chart displays a comprehensive pedaling technique analysis comparing metrics between left (red) and right (turquoise) legs.\n\n**Analyzed metrics:**\n- L/R Balance: Power distribution between both legs\n- Torque Effectiveness: Efficiency in force application on the pedal\n- Smoothness: Pedaling fluidity throughout the rotation\n- GPR (Gross Power Released): Effective power contributing to movement\n- GPA (Gross Power Absorbed): Power lost during pedaling\n\nThe chart includes a totals section (orange) showing combined GPR and GPA. Percentage values are shown on the left axis and power values on the right axis.",
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "600px",
        "script": "(function() {\n    try {\n        // Get required streams\n        const streams = icu.streams;\n        const pwr = streams.get('watts').data;\n        const lte = streams.get('left_torque_effectiveness').data;\n        const rte = streams.get('right_torque_effectiveness').data;\n        const balance = streams.get('left_right_balance').data;  // Este es el balance DERECHO!\n        const lps = streams.get('left_pedal_smoothness').data;\n        const rps = streams.get('right_pedal_smoothness').data;\n        const cadence = streams.get('cadence').data;\n\n        // Validate data availability and quality\n        const validateData = (data) => {\n            if (!data) return false;\n            const validPoints = data.filter(val => val != null && val > 0).length;\n            return validPoints > (data.length * 0.1); // At least 10% valid data\n        };\n\n        if (!validateData(pwr) || !validateData(lte) || !validateData(rte) || \n            !validateData(balance) || !validateData(lps) || !validateData(rps)) {\n            console.error('Insufficient valid data for analysis');\n            return null;\n        }\n\n        // Calculate average excluding zeros and nulls\n        function calculateAverage(data) {\n            const validData = data.filter(val => val != null && val > 0);\n            return validData.length > 0 ? \n                validData.reduce((a, b) => a + b, 0) / validData.length : 0;\n        }\n\n        // Calculate GPR and GPA with validation\n        function calculatePowerMetrics(power, balance, torqueEff) {\n            if (!power || !balance || !torqueEff || power <= 0 || balance <= 0 || torqueEff <= 0) {\n                return { gpr: 0, gpa: 0 };\n            }\n            \n            const powerContribution = power * (balance/100);\n            const gpr = powerContribution * (torqueEff/100);\n            const gpa = powerContribution - gpr;\n            \n            return { gpr, gpa };\n        }\n\n        // Calculate ranges functions\n        const calculatePowerRange = (leftGPR, rightGPR, leftGPA, rightGPA, totalGPR, totalGPA) => {\n            const powerValues = [leftGPR, rightGPR, leftGPA, rightGPA, totalGPR, totalGPA]\n                .filter(val => val != null && val > 0);\n            \n            if (powerValues.length === 0) return [0, 100];\n            \n            const minPower = Math.min(...powerValues);\n            const maxPower = Math.max(...powerValues);\n            \n            const range = maxPower - minPower;\n            const padding = range * 0.1;\n            \n            return [\n                Math.max(0, Math.floor((minPower - padding) / 10) * 10),\n                Math.ceil((maxPower + padding) / 10) * 10\n            ];\n        };\n\n        const calculatePercentageRange = (leftBalance, rightBalance, lte, rte, lps, rps) => {\n            const percentValues = [leftBalance, rightBalance, lte, rte, lps, rps]\n                .filter(val => val != null && val > 0);\n            \n            if (percentValues.length === 0) return [0, 100];\n            \n            const maxPercent = Math.max(...percentValues);\n            const padding = maxPercent * 0.1;\n            \n            return [0, Math.min(110, Math.ceil((maxPercent + padding) / 10) * 10)];\n        };\n\n        // Calculate metrics\n        const avgPower = calculateAverage(pwr);\n        const avgLTE = calculateAverage(lte);\n        const avgRTE = calculateAverage(rte);\n        const avgRightBalance = calculateAverage(balance);      // Balance derecho directo\n        const avgLeftBalance = 100 - avgRightBalance;          // Balance izquierdo calculado\n        const avgLPS = calculateAverage(lps);\n        const avgRPS = calculateAverage(rps);\n        const avgCadence = calculateAverage(cadence);\n\n        // Calculate power metrics\n        const leftMetrics = calculatePowerMetrics(avgPower, avgLeftBalance, avgLTE);\n        const rightMetrics = calculatePowerMetrics(avgPower, avgRightBalance, avgRTE);\n\n        const leftGPR = leftMetrics.gpr;\n        const leftGPA = leftMetrics.gpa;\n        const rightGPR = rightMetrics.gpr;\n        const rightGPA = rightMetrics.gpa;\n        const totalGPR = leftGPR + rightGPR;\n        const totalGPA = leftGPA + rightGPA;\n\n        // Calculate ranges\n        const powerRange = calculatePowerRange(leftGPR, rightGPR, leftGPA, rightGPA, totalGPR, totalGPA);\n        const percentageRange = calculatePercentageRange(avgLeftBalance, avgRightBalance, avgLTE, avgRTE, avgLPS, avgRPS);\n\n        // Chart data\n        const data = [\n            {\n                type: 'bar',\n                name: 'Left',\n                x: ['Balance', 'Torque Eff.', 'Smoothness', 'GPR', 'GPA'],\n                y: [avgLeftBalance, avgLTE, avgLPS, leftGPR, leftGPA],\n                marker: { color: '#FF6B6B' },\n                text: [\n                    avgLeftBalance.toFixed(1) + '%',\n                    avgLTE.toFixed(1) + '%',\n                    avgLPS.toFixed(1) + '%',\n                    leftGPR.toFixed(1) + 'W',\n                    leftGPA.toFixed(1) + 'W'\n                ],\n                textposition: 'auto',\n                textfont: { size: 11 }\n            },\n            {\n                type: 'bar',\n                name: 'Right',\n                x: ['Balance', 'Torque Eff.', 'Smoothness', 'GPR', 'GPA'],\n                y: [avgRightBalance, avgRTE, avgRPS, rightGPR, rightGPA],\n                marker: { color: '#4ECDC4' },\n                text: [\n                    avgRightBalance.toFixed(1) + '%',\n                    avgRTE.toFixed(1) + '%',\n                    avgRPS.toFixed(1) + '%',\n                    rightGPR.toFixed(1) + 'W',\n                    rightGPA.toFixed(1) + 'W'\n                ],\n                textposition: 'auto',\n                textfont: { size: 11 }\n            },\n            {\n                type: 'bar',\n                name: 'Total',\n                x: ['Total GPR', 'Total GPA'],\n                y: [totalGPR, totalGPA],\n                marker: { color: '#FFB347' },\n                text: [\n                    totalGPR.toFixed(1) + 'W',\n                    totalGPA.toFixed(1) + 'W'\n                ],\n                textposition: 'auto',\n                textfont: { size: 11 },\n                yaxis: 'y2'\n            }\n        ];\n\n        const layout = {\n            title: {\n                text: 'Pedaling Technique Analysis',\n                font: { size: 20 }\n            },\n            yaxis: {\n                title: {\n                    text: 'Percentage (%)',\n                    font: { size: 12 }\n                },\n                range: percentageRange,\n                gridcolor: '#E2E2E2',\n                zerolinecolor: '#969696',\n                tickfont: { size: 11 },\n                autorange: false,\n                fixedrange: false\n            },\n            yaxis2: {\n                title: {\n                    text: 'Power (W)',\n                    font: { size: 12 },\n                    standoff: 10\n                },\n                overlaying: 'y',\n                side: 'right',\n                range: powerRange,\n                tickfont: { size: 11 },\n                autorange: false,\n                fixedrange: false\n            },\n            xaxis: {\n                tickfont: { size: 11 }\n            },\n            showlegend: true,\n            legend: {\n                orientation: 'h',\n                y: -0.15,\n                x: 0.3,\n                xanchor: 'center',\n                bgcolor: '#F8F9FA',\n                bordercolor: '#E9ECEF',\n                borderwidth: 1,\n                font: { size: 11 }\n            },\n            annotations: [{\n                x: 1.22,\n                y: 1,\n                xref: 'paper',\n                yref: 'paper',\n                text: '<b>Detailed Values:</b><br><br>' +\n                      `L/R Balance: ${avgLeftBalance.toFixed(1)}% / ${avgRightBalance.toFixed(1)}%<br>` +\n                      `L/R Torque Eff.: ${avgLTE.toFixed(1)}% / ${avgRTE.toFixed(1)}%<br>` +\n                      `L/R Smoothness: ${avgLPS.toFixed(1)}% / ${avgRPS.toFixed(1)}%<br>` +\n                      `L/R GPR: ${leftGPR.toFixed(1)}W / ${rightGPR.toFixed(1)}W<br>` +\n                      `L/R GPA: ${leftGPA.toFixed(1)}W / ${rightGPA.toFixed(1)}W<br>` +\n                      `Total GPR: ${totalGPR.toFixed(1)}W<br>` +\n                      `Total GPA: ${totalGPA.toFixed(1)}W<br><br>` +\n                      `<b>General Metrics:</b><br>` +\n                      `Average Power: ${avgPower.toFixed(0)}W<br>` +\n                      `Cadence: ${avgCadence.toFixed(0)}rpm`,\n                showarrow: false,\n                align: 'left',\n                bgcolor: '#F8F9FA',\n                bordercolor: '#E9ECEF',\n                borderwidth: 1,\n                font: { size: 11 },\n                width: 300\n            }],\n            barmode: 'group',\n            height: 700,\n            width: 1300,\n            margin: {\n                l: 80,\n                r: 250,\n                t: 50,\n                b: 100\n            },\n            plot_bgcolor: '#FFFFFF',\n            paper_bgcolor: '#FFFFFF'\n        };\n\n        return {\n            data: data,\n            layout: layout,\n            config: {\n                responsive: true,\n                displayModeBar: true,\n                displaylogo: false,\n                modeBarButtonsToRemove: ['lasso2d', 'select2d'],\n                toImageButtonOptions: {\n                    format: 'png',\n                    filename: 'pedaling_analysis',\n                    height: 700,\n                    width: 1300,\n                    scale: 2\n                }\n            }\n        };\n\n    } catch (error) {\n        console.error('Error in analysis:', error);\n        return null;\n    }\n})();",
        "name": "Pedaling Technique Analysis"
      },
      "usage_count": 0,
      "index": 31,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-09T09:49:39.638+00:00",
      "from_athlete": {
        "id": "10385309",
        "name": "Luisma Gallego",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c7e97937-d358-425a-8acc-2c726c4b5cff",
        "city": "Cubelles",
        "state": "Barcelona",
        "country": "Spain",
        "timezone": "Europe/Madrid",
        "sex": "M",
        "bio": "Physiology Technician\n\nPersonal Trainer EREPS accreditation number 107429\n\nInstructor at Sportcoach.es\n\nPublications: https://dialnet.unirioja.es/servlet/articulo?codigo=8443236\n\nParticipant in several podcasts about training and cycling\n\nwww.controlmetrics.es\n",
        "website": "https://www.controlmetrics.es",
        "email": null
      },
      "from_id": 474613
    },
    {
      "id": 611740,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Medium",
      "description": null,
      "image": null,
      "content": {
        "id": "t8hibfe5",
        "name": "Medium",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "rgba(44,160,44, 0.4)",
            "text": "Avg Temp",
            "type": "dot",
            "field": "average_temp",
            "gauge": true,
            "scale": "temp",
            "stack": "",
            "title": "Average temperature",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(44,160,44)",
            "filters": [],
            "i18nKey": "Avg Temp",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Average temperature",
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#DD04A74D",
            "text": "Avg Forecast Temp",
            "type": "dot",
            "field": "average_weather_temp",
            "gauge": true,
            "scale": "temp",
            "stack": "",
            "title": "Average forecast temperature",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#DD04A7FF",
            "filters": [],
            "i18nKey": "Avg Forecast Temp",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Average forecast temperature",
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#1F77B438",
            "text": "Avg Feels Like",
            "type": "dot",
            "field": "average_feels_like",
            "gauge": true,
            "scale": "temp",
            "stack": "",
            "title": "Average forecast feels like temp",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#00C9FFFF",
            "filters": [],
            "i18nKey": "Avg Feels Like",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Average forecast feels like temp",
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 220,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 32,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-03T11:03:55.534+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 700863,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PUBLIC",
      "name": "Vam Chart TOTAL",
      "description": "every 30s starting from 1m\n",
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "600px",
        "script": "{\n  // --- CONFIGURAZIONE INIZIALE ---\n  const CONFIG = {\n\n    // --- COLORI ---\n    COLOR_LINE: '#365A98',         // Colore della linea principale\n\n    // --- TITOLI E FONT ---\n    TITLE: 'VAM Peak Chart',               // Titolo del grafico\n    XAXIS_TITLE: 'Duration (min)',         // Titolo asse X\n    YAXIS_TITLE: 'VAM (m/h)',              // Titolo asse Y\n    FONT_SIZE: 12,                         // Dimensione font tick e label\n    TICKANGLE_X: -90,                      // Angolo etichette asse X\n    TICKANGLE_Y: 0,                        // Angolo etichette asse Y\n\n    // --- MARGINI E SHAPE ---\n    MARGIN: { t: 50, l: 60, r: 20, b: 100 }, // Margini del grafico\n    SHAPE_WIDTH_X: 1,                      // Spessore linea shape orizzontale (X)\n    SHAPE_WIDTH_Y: 1                       // Spessore linea shape verticale (Y)\n  };\n  // --- FINE CONFIG ---\n\n  const stream = icu.streams;\n  const maxTime = icu.activity.moving_time;\n  console.log(`Total moving time: ${maxTime}s`);\n\n  // Intervalli ogni 30 secondi da 60s a maxTime\n  let intervals = Array.from({length: Math.floor((maxTime-60)/30)+1}, (_, i) => 60 + i*30).filter(s => s <= maxTime);\n\n  let vamPeaks = [];\n\n  // Guadagno altimetrico cumulativo (solo salite, monotono)\n  let cumulativeGain = [];\n  let gain = 0;\n  let altitude = stream.altitude;\n\n  cumulativeGain[0] = 0;\n  for (let i = 1; i < altitude.length; i++) {\n    let delta = altitude[i] - altitude[i - 1];\n    // Ignora salti anomali di altitudine (>10m/s)\n    if (Math.abs(delta) > 10) {\n      cumulativeGain[i] = gain;\n      continue;\n    }\n    if (delta > 0) gain += delta;\n    cumulativeGain[i] = gain;\n  }\n\n  // Calcolo dei picchi di VAM\n  intervals.forEach(interval => {\n    let best = 0;\n    for (let i = 0; i < cumulativeGain.length - interval; i++) {\n      let j = i + interval;\n      if (j >= cumulativeGain.length) break;\n      let deltaGain = cumulativeGain[j] - cumulativeGain[i];\n      if (deltaGain > best) best = deltaGain;\n    }\n    let vam = (best / interval) * 3600;\n    vamPeaks.push(vam);\n  });\n\n  // ASSE X VALUES\n  let xValues = intervals.map(sec => sec / 60);\n  // Tick ogni 10 minuti\n  let tickvals = Array.from({length: Math.floor(Math.floor(maxTime/60)/10)}, (_, i) => (i+1)*10);\n  let ticktext = tickvals.map(m => `${m} m`);\n\n  // Plot\n  let traces = [{\n    x: xValues,\n    y: vamPeaks,\n    type: 'scatter',\n    mode: 'lines', // solo linea smooth\n    line: { shape: 'spline', color: CONFIG.COLOR_LINE },\n    name: 'VAM Peaks',\n    hovertemplate:\n      'VAM: %{y:.0f} m/h<extra></extra>'\n  }];\n\n  let layout = {\n    title: CONFIG.TITLE,\n    xaxis: {\n      title: CONFIG.XAXIS_TITLE,\n      type: 'linear',\n      tickvals: tickvals,\n      ticktext: ticktext,\n      tickfont: { size: CONFIG.FONT_SIZE },\n      tickangle: CONFIG.TICKANGLE_X,\n      range: [Math.max(0, Math.min(...xValues) - 0), Math.max(...xValues) + 0],\n      showgrid: true\n    },\n    yaxis: {\n      title: CONFIG.YAXIS_TITLE,\n      tickformat: ',d',\n      tickfont: { size: CONFIG.FONT_SIZE },\n      tickangle: CONFIG.TICKANGLE_Y,\n      range: [\n        Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        null\n      ]\n    },\n    margin: CONFIG.MARGIN,\n    shapes: [\n      // Linea orizzontale sottile sull'asse y al minimo arrotondato\n      {\n        type: 'line',\n        xref: 'paper',\n        x0: 0,\n        x1: 1,\n        yref: 'y',\n        y0: Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        y1: Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        line: {\n          color: 'rgba(0,0,0,0.7)',\n          width: CONFIG.SHAPE_WIDTH_X\n        }\n      },\n      // Linea verticale sull'asse x a 0\n      {\n        type: 'line',\n        xref: 'x',\n        x0: 0,\n        x1: 0,\n        yref: 'paper',\n        y0: 0,\n        y1: 1,\n        line: {\n          color: 'rgba(0,0,0,0.7)',\n          width: CONFIG.SHAPE_WIDTH_Y\n        }\n      }\n    ]\n  };\n\n  const chart = { data: traces, layout };\n  chart;\n}",
        "name": "Vam Chart TOTAL"
      },
      "usage_count": 1,
      "index": 32,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-26T08:25:57.281+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 611747,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Max",
      "description": null,
      "image": null,
      "content": {
        "id": "9s1a9s7m",
        "name": "Max",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#009E0066",
            "text": "Max Temp",
            "type": "dot",
            "field": "max_temp",
            "gauge": true,
            "scale": "temp",
            "stack": "",
            "title": "Maximum temperature",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009E00FF",
            "filters": [],
            "i18nKey": "Max Temp",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Maximum temperature",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#DD04A74D",
            "text": "Max Forecast Temp",
            "type": "dot",
            "field": "max_weather_temp",
            "gauge": true,
            "scale": "temp",
            "stack": "",
            "title": "Max forecast temperature",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#DD04A7FF",
            "filters": [],
            "i18nKey": "Max Forecast Temp",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Max forecast temperature",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#0E7BF157",
            "text": "Max Feels Like",
            "type": "dot",
            "field": "max_feels_like",
            "gauge": true,
            "scale": "temp",
            "stack": "",
            "title": "Max forecast feels like temp",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#00C9FFFF",
            "filters": [],
            "i18nKey": "Max Feels Like",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Max forecast feels like temp",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 220,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 33,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-03T11:04:08.587+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 700869,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "VAM CHART AGA SHORT",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "600px",
        "script": "{\n  // --- CONFIGURAZIONE INIZIALE ---\n  const CONFIG = {\n\n    // Colori\n    COLOR_LINE: '#365A98',         // Colore della linea principale (spline)\n    COLOR_MARKER: '#c90076',       // Colore dei marker (stelle)\n\n    // Marker\n    MARKER_SYMBOL: 'star-diamond', // Simbolo marker per i picchi (Plotly symbol)\n    MARKER_SIZE: 10,               // Dimensione marker\n\n    // Titoli e font\n    TITLE: 'VAM Peak Chart',       // Titolo del grafico\n    XAXIS_TITLE: 'Duration (s)',   // Titolo asse X\n    YAXIS_TITLE: 'VAM (m/h)',      // Titolo asse Y\n    FONT_SIZE: 12,                 // Dimensione font tick e label\n    TICKANGLE_X: 20,               // Angolo dei tick dell'asse X\n    TICKANGLE_Y: 0,                // Angolo dei tick dell'asse Y\n\n    // Margini e shape\n    MARGIN: { t: 50, l: 60, r: 20, b: 100 }, // Margini del grafico\n    SHAPE_WIDTH_X: 1,              // Spessore linea shape orizzontale (X)\n    SHAPE_WIDTH_Y: 2,              // Spessore linea shape verticale (Y)\n\n    // Intervalli\n    INTERVAL_START: 20,            // Inizio intervallo (secondi)\n    INTERVAL_END: 480,             // Fine intervallo (secondi)\n    INTERVAL_STEP: 20              // Step intervallo (secondi)\n  };\n  // --- FINE CONFIG ---\n\n  const stream = icu.streams;\n  const maxTime = icu.activity.moving_time;\n  console.log(`Total moving time: ${maxTime}s`);\n\n  // Intervalli ogni 20s da INTERVAL_START a INTERVAL_END (o maxTime)\n  const intervals = Array.from(\n    { length: Math.floor((Math.min(CONFIG.INTERVAL_END, maxTime) - CONFIG.INTERVAL_START) / CONFIG.INTERVAL_STEP) + 1 },\n    (_, i) => CONFIG.INTERVAL_START + i * CONFIG.INTERVAL_STEP\n  );\n\n  // Guadagno altimetrico cumulativo (solo salite)\n  let altitude = stream.altitude;\n  let startIdx = altitude.findIndex(a => a > 1);\n  if (startIdx > 0) altitude = altitude.slice(startIdx);\n  const cumulativeGain = altitude.reduce((arr, alt, i, src) => {\n    if (i === 0) { arr.push(0); return arr; }\n    const delta = alt - src[i - 1];\n    // Ignora salti anomali di altitudine (>10m/s)\n    if (Math.abs(delta) > 10) {\n      arr.push(arr[arr.length - 1]);\n      return arr;\n    }\n    arr.push(arr[arr.length - 1] + (delta > 0 ? delta : 0));\n    return arr;\n  }, []);\n\n  // Calcolo dei picchi di VAM\n  const vamPeaks = intervals.map(interval => {\n    let best = 0;\n    for (let i = 0; i < cumulativeGain.length - interval; i++) {\n      let j = i + interval;\n      if (j >= cumulativeGain.length) break;\n      let deltaGain = cumulativeGain[j] - cumulativeGain[i];\n      if (deltaGain > best) best = deltaGain;\n    }\n    return (best / interval) * 3600;\n  });\n\n  // Valori asse X\n  const xLabels = intervals.map(sec => `${sec} s`);\n\n  // Tracce del grafico\n  const traces = [\n    {\n      x: intervals,\n      y: vamPeaks,\n      type: 'scatter',\n      mode: 'lines',\n      line: { shape: 'spline', color: CONFIG.COLOR_LINE },\n      hoverinfo: 'skip',\n      showlegend: false\n    },\n    {\n      x: intervals,\n      y: vamPeaks,\n      type: 'scatter',\n      mode: 'markers',\n      marker: {\n        color: CONFIG.COLOR_MARKER,\n        symbol: CONFIG.MARKER_SYMBOL,\n        size: CONFIG.MARKER_SIZE\n      },\n      hovertemplate:\n        '%{text}<br>VAM: %{y:.0f} m/h<extra></extra>',\n      text: xLabels,\n      showlegend: false\n    }\n  ];\n\n  // Layout\n  const layout = {\n    title: CONFIG.TITLE,\n    xaxis: {\n      title: CONFIG.XAXIS_TITLE,\n      type: 'linear',\n      tickvals: intervals,\n      ticktext: xLabels,\n      tickfont: { size: CONFIG.FONT_SIZE },\n      tickangle: CONFIG.TICKANGLE_X,\n      range: [Math.max(0, Math.min(...intervals) - 20), Math.max(...intervals) + 10]\n    },\n    yaxis: {\n      title: CONFIG.YAXIS_TITLE,\n      tickformat: ',d',\n      tickfont: { size: CONFIG.FONT_SIZE },\n      tickangle: CONFIG.TICKANGLE_Y,\n      range: [\n        Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        null\n      ]\n    },\n    margin: CONFIG.MARGIN,\n    showlegend: false,  // Disattiva legenda\n    shapes: [\n      {\n        type: 'line',\n        xref: 'paper',\n        x0: 0,\n        x1: 1,\n        yref: 'y',\n        y0: Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        y1: Math.floor(Math.min(...vamPeaks) / 200) * 200,\n        line: {\n          color: 'rgba(0,0,0,0.7)',\n          width: CONFIG.SHAPE_WIDTH_X\n        }\n      },\n      {\n        type: 'line',\n        xref: 'x',\n        x0: 0,\n        x1: 0,\n        yref: 'paper',\n        y0: 0,\n        y1: 1,\n        line: {\n          color: 'rgba(0,0,0,0.7)',\n          width: CONFIG.SHAPE_WIDTH_Y\n        }\n      }\n    ]\n  };\n\n  const chart = { data: traces, layout };\n  chart;\n}",
        "name": "VAM CHART AGA SHORT"
      },
      "usage_count": 0,
      "index": 33,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-26T08:27:20.824+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 611748,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Min",
      "description": null,
      "image": null,
      "content": {
        "id": "f3z36s08",
        "name": "Min",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#009E0066",
            "text": "Min Temp",
            "type": "dot",
            "field": "min_temp",
            "gauge": true,
            "scale": "temp",
            "stack": "",
            "title": "Minimum temperature",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009E00FF",
            "filters": [
              {
                "id": 1,
                "value": null,
                "field_id": "indoor"
              }
            ],
            "i18nKey": "Min Temp",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Minimum temperature",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#DD04A74D",
            "text": "Min Forecast Temp",
            "type": "dot",
            "field": "min_weather_temp",
            "gauge": true,
            "scale": "temp",
            "stack": "",
            "title": "Min forecast temperature",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#DD04A7FF",
            "filters": [
              {
                "id": 1,
                "value": null,
                "field_id": "indoor"
              }
            ],
            "i18nKey": "Min Forecast Temp",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Min forecast temperature",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#0E7BF157",
            "text": "Min Feels Like",
            "type": "dot",
            "field": "min_feels_like",
            "gauge": true,
            "scale": "temp",
            "stack": "",
            "title": "Min forecast feels like temp",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#00C9FFFF",
            "filters": [],
            "i18nKey": "Min Feels Like",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Min forecast feels like temp",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 220,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 34,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-04-03T11:05:19.204+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 701227,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "3m MAP",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n    // --- CONFIGURAZIONE INIZIALE ---\n    // Durata della finestra di sforzo in secondi (es: 180 per 3 minuti)\n    const EFFORT_WINDOW_SECONDS = 180;\n    // Intensit minima come percentuale di FTP (es: 100 per 100% FTP)\n    const MIN_EFFORT_INTENSITY_FTP = 100;\n    // Valore FTP dall'attivit\n    const FTP = icu.activity.icu_ftp;\n    // Soglia minima di pendenza media per mostrare valori teorici\n    const MIN_AVG_GRADE_FOR_THEORETICAL = 4.5;\n    // Configurazione colori delle zone: array di { threshold, color, label }\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n    // Helper per formattare numeri\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // --- FINE CONFIGURAZIONE INIZIALE ---\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    // Function to get zone color based on avgPower and FTP, using configuration above\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n    // Fix initial altitude values (replace leading zeros with first non-zero value)\n    const firstNonZeroAltitude = altitude.find(value => value !== 0);\n    if (firstNonZeroAltitude !== undefined) {\n        for (let i = 0; i < altitude.length; i++) {\n            if (altitude[i] === 0) altitude[i] = firstNonZeroAltitude;\n            else break;\n        }\n    }\n\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map(alt => `${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Elevation'\n        }\n    ];\n    const annotations = [];\n    // Find all non-overlapping efforts above threshold\n    function getAllNonOverlappingEffortsAboveThreshold(data, n, threshold, samplingRate = 1) {\n        const windowSize = n * samplingRate;\n        const results = [];\n        if (data.length < windowSize) return results;\n        let sum = 0;\n        for (let i = 0; i < windowSize; i++) sum += data[i];\n        const candidates = [];\n        if (sum / windowSize >= threshold) candidates.push({ avg: sum / windowSize, start: 0 });\n        for (let i = 1; i <= data.length - windowSize; i++) {\n            sum = sum - data[i - 1] + data[i + windowSize - 1];\n            const avg = sum / windowSize;\n            if (avg >= threshold) candidates.push({ avg, start: i });\n        }\n        candidates.sort((a, b) => b.avg - a.avg);\n        const used = Array(data.length).fill(false);\n        for (const cand of candidates) {\n            let overlap = false;\n            for (let j = cand.start; j < cand.start + windowSize; j++) {\n                if (used[j]) { overlap = true; break; }\n            }\n            if (!overlap) {\n                results.push(cand);\n                for (let j = cand.start; j < cand.start + windowSize; j++) used[j] = true;\n            }\n        }\n        results.sort((a, b) => a.start - b.start);\n        return results;\n    }\n\n    // Trova tutti gli sforzi non sovrapposti sopra la soglia configurata\n    // MIN_EFFORT_INTENSITY_FTP ora  percentuale, quindi dividi per 100\n    const allEfforts = getAllNonOverlappingEffortsAboveThreshold(power, EFFORT_WINDOW_SECONDS, (MIN_EFFORT_INTENSITY_FTP / 100) * FTP, 1);\n    // Sort allEfforts by avgPower descending for legend order\n    const sortedEfforts = allEfforts.slice().sort((a, b) => b.avg - a.avg);\n    sortedEfforts.forEach((best, idx) => {\n        const avgPower = best.avg;\n        const bestStart = best.start;\n        const bestEnd = bestStart + EFFORT_WINDOW_SECONDS;\n        const sectionPower = power.slice(bestStart, bestEnd);\n        const sectionHR = heartrate.slice(bestStart, bestEnd);\n        const sectionAltitude = altitude.slice(bestStart, bestEnd);\n        const sectionDistance = distance.slice(bestStart, bestEnd);\n        const sectionDistanceKm = distanceKm.slice(bestStart, bestEnd);\n        const sectionGrade = grade.slice(bestStart, bestEnd);\n        const sectionTime = time.slice(bestStart, bestEnd);\n\n        // Metrics calculation\n        const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n        const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n        const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n        const avgSpeed = dist / (climbTimeInSeconds / 3600) / 1000;\n        const vam = elevationGain / (climbTimeInSeconds / 3600);\n        const avgGrade = elevationGain / dist * 100;\n        const gradientFactor = 2 + (avgGrade / 10);\n        const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n        let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n        if (sectionPower.length) {\n            const half = Math.floor(sectionPower.length / 2);\n            avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n            avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n            wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n        }\n        const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n        const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n        const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n        const startTime = sectionTime.length ? sectionTime[0] : '';\n        let best5sWatt = '', best5sWattKg = '';\n        let avgPowerPerKg = 0;\n        if (sectionPower.length >= 5 && weight > 0) {\n            const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n            best5sWatt = Math.round(maxW);\n            best5sWattKg = fmt(maxW / weight, 2);\n            avgPowerPerKg = avgPower / weight;\n        }\n        const bgColor = getZoneColor(avgPower, FTP);\n        let joules = 0, joulesOverCP = 0;\n        if (power && time && bestStart !== undefined && bestStart < power.length && FTP) {\n            for (let i = 0; i < bestStart; i++) {\n                const w = power[i];\n                const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n                if (secs < 30) {\n                    joules += w * secs;\n                    if (w >= FTP) joulesOverCP += w * secs;\n                }\n            }\n        }\n        const hours = (time && bestStart !== undefined && time[bestStart]) ? (time[bestStart] / 3600) : 0;\n        const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n        const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n        function formatSecondsToHHMMSS(seconds) {\n            const sec = Math.floor(seconds % 60);\n            const min = Math.floor((seconds / 60) % 60);\n            const hr = Math.floor(seconds / 3600);\n            return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n        }\n        const traceText = [\n            (() => {\n                const sectionCadence = getStreamData(\"cadence\").slice(bestStart, bestEnd);\n                const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n                return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n            })(),\n            ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n            ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n            ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n            ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n            (() => {\n                if (avgGrade >= MIN_AVG_GRADE_FOR_THEORETICAL) {\n                    const diffVAM = Math.abs(vamTeorico - vam);\n                    let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                    const wkgteoric = vam / (gradientFactor * 100);\n                    const diffWkg = avgPowerPerKg - wkgteoric;\n                    return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n                } else {\n                    return ` ${fmt(vam,0)} m/h`;\n                }\n            })(),\n            (() => {\n                if (avgGrade >= MIN_AVG_GRADE_FOR_THEORETICAL) {\n                    const wkgteoric = vam / (gradientFactor * 100);\n                    const diffWkg = avgPowerPerKg - wkgteoric;\n                    const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                    const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                    return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n                } else {\n                    return '';\n                }\n            })(),\n            startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '',\n            ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n            ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n        ].filter(Boolean).join('<br>');\n        traces.push({\n            x: sectionDistanceKm,\n            y: sectionAltitude,\n            type: 'scatter',\n            mode: 'lines',\n            line: { color: bgColor, width: 2 },\n            name: `${fmt(avgPower)} W | #${idx + 1}`,\n            hoverinfo: 'text',\n            visible: true,\n            hoverlabel: { align: 'left' },\n            text: traceText\n        });\n\n        // Offset annotation positions to avoid overlap\n        annotations.push({\n            x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2 + (idx % 2 === 0 ? -1 : 1) * idx * 0.003,\n            y: Math.max(...sectionAltitude) + 50 + idx * 25,\n            text: `#${idx + 1}<br> ${fmt(avgPower)}`,\n            showarrow: false,\n            font: { family: 'Arial', size: 12, color: 'white' },\n            align: 'center',\n            bgcolor: bgColor,\n            opacity: 0.9\n        });\n    });\n\n    // Dynamic chart title based on configuration\n    const effortMin = Math.floor(EFFORT_WINDOW_SECONDS / 60);\n    const effortSec = EFFORT_WINDOW_SECONDS % 60;\n    const effortLabel = effortSec > 0 ? `${effortMin}m ${effortSec}s` : `${effortMin}m`;\n    const layout = {\n        title: `All ${effortLabel} Power Efforts >${fmt(MIN_EFFORT_INTENSITY_FTP,0)}% CP`,\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "3m MAP"
      },
      "usage_count": 0,
      "index": 34,
      "hide_script": true,
      "hidden_by_id": "i115436",
      "updated": "2025-08-09T11:51:03.172+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 676288,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "JR POWER",
      "description": null,
      "image": null,
      "content": {
        "id": "vyqwxoao",
        "name": "JR POWER",
        "plots": [
          {
            "id": 1,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 120
            },
            "band": 0,
            "fill": "#FFCB0EBF",
            "text": "2m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#FFCB0EBF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 360
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "3m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#FF520EFF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 480
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "4m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009E00FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 720
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "5m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#DD04A7FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 1200
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "20m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#DD044747",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 1500
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "25m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#00C9FFFF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 7,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 300
            },
            "band": 0,
            "fill": "#FFCB0EBF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 8,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 360
            },
            "band": 0,
            "fill": "#FF520EFF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 9,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 480
            },
            "band": 0,
            "fill": "#009E00FF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 10,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 720
            },
            "band": 0,
            "fill": "#DD04A7FF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 11,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 1200
            },
            "band": 0,
            "fill": "#DD044747",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 12,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 1500
            },
            "band": 0,
            "fill": "#00C9FFFF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 330,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "POWER",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 35,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-06-11T08:34:21.831+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 701595,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "kj*kg sections",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "// --- CONFIGURAZIONE, COLORI, FUNZIONI E LAYOUT ---\n\nconst CONFIG = {\n    KJ_KG_PER_SEZIONE: 3, // <--- Modifica qui per cambiare la dimensione delle sezioni kJ*kg\n    pesoKg: icu.activity.icu_weight,\n};\nCONFIG.KJ_PER_SEZIONE = CONFIG.KJ_KG_PER_SEZIONE * CONFIG.pesoKg;\n\n// --- CONFIGURAZIONE COLORI TRACCE ---\nconst COLORI = {\n    LINEA_ALTITUDINE: '#e2dedeff',\n    RIEMPIMENTO_ALTITUDINE: '#e2dedeff',\n    BARRA_CP: '#c44e52',\n    BARRA_CP_OPACITY: 0.4, \n    SOPRA_CP: '#fa0710ff',\n    TRA_80_100: '#ffe600',\n    SOTTO_80: '#24e04d',\n    COASTING: '#1100ffff'\n};\n\nconst fmt = (num, digits = 0) => Number(num).toFixed(digits);\nfunction getStreamData(streamName) {\n    const stream = icu.streams.get(streamName);\n    return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\n\n// Layout base (verr usato pi sotto)\nconst BASE_LAYOUT = {\n    height: 400,\n    margin: { t: 60, l: 40, r: 20, b: 40 },\n};\n\n// Stream principali\nconst altitude = getStreamData(\"fixed_altitude\");\nconst distance = getStreamData(\"distance\");\nconst time = getStreamData(\"time\");\nconst power = getStreamData(\"fixed_watts\");\nconst distanceKm = distance.map(d => d / 1000);\n\n// Calcola tempo trascorso in movimento (asse X)\n\n\n// Calcola il moving time escludendo pause e micro-movimenti (velocit istantanea > 1 km/h)\nlet movingTime = [0];\nfor (let i = 1; i < time.length; i++) {\n    const dt = time[i] - time[i - 1];\n    const dd = distanceKm[i] - distanceKm[i-1];\n    // Calcola velocit istantanea in km/h\n    const v = dt > 0 ? (dd * 3600) / dt : 0;\n    // Somma solo i dt dove la velocit  > 1 km/h (in movimento reale)\n    if (v > 1) {\n        movingTime.push(movingTime[movingTime.length - 1] + dt);\n    } else {\n        // Se  pausa o micro-movimento, non aggiungere nulla\n        movingTime.push(movingTime[movingTime.length - 1]);\n    }\n}\n\n// Calcola le posizioni delle sezioni da KJ_PER_SEZIONE (kJ assoluti) e kJ sopra CP per ciascuna\nlet sezioniIdx = [];\nlet kJAcc = 0, kJAccOverCP = 0;\nlet kJOverCPPerSezione = [];\nfor (let i = 1; i < power.length; i++) {\n    const w = power[i];\n    const dt = time[i] - time[i - 1];\n    if (dt < 30) {\n        kJAcc += w * dt / 1000;\n        if (w >= icu.activity.icu_ftp) kJAccOverCP += w * dt / 1000;\n    }\n    if (kJAcc >= CONFIG.KJ_PER_SEZIONE) {\n        sezioniIdx.push(i);\n        kJOverCPPerSezione.push(kJAccOverCP);\n        kJAcc = 0;\n        kJAccOverCP = 0;\n    }\n}\n// Se rimane una sezione finale non vuota, aggiungila\nif (kJAcc > 0) {\n    sezioniIdx.push(power.length - 1);\n    kJOverCPPerSezione.push(kJAccOverCP);\n}\n\n// Correggi i valori iniziali di altitudine (sostituisci gli zeri iniziali con il primo valore non zero)\n// Calcola kJ cumulativi per ogni punto\n// Calcola kJ sopra CP cumulativi per ogni punto\nconst kJ_sopraCP_cumulativi = [];\nlet kJ_overCP_sum = 0;\nfor (let i = 1; i < power.length; i++) {\n    const dt = time[i] - time[i-1];\n    if (dt < 30 && power[i] >= icu.activity.icu_ftp) kJ_overCP_sum += power[i] * dt / 1000;\n    kJ_sopraCP_cumulativi.push(kJ_overCP_sum);\n}\nconst kJ_cumulativi = [];\nlet kJ_sum = 0;\nfor (let i = 1; i < power.length; i++) {\n    const dt = time[i] - time[i-1];\n    if (dt < 30) kJ_sum += power[i] * dt / 1000;\n    kJ_cumulativi.push(kJ_sum);\n}\nconst firstNonZeroAltitude = altitude.find(value => value !== 0);\nif (firstNonZeroAltitude !== undefined) {\n    for (let i = 0; i < altitude.length; i++) {\n        if (altitude[i] === 0) altitude[i] = firstNonZeroAltitude;\n        else break;\n    }\n}\n\n// Traccia altitudine\n// --- DEFINIZIONE DEI TRACES DEL GRAFICO ---\n// Traccia altimetrica principale (altitudine vs tempo in movimento)\nconst data = [\n    {\n        x: movingTime,\n        y: altitude,\n        text: altitude.map((alt, i) => {\n            // Costruisce il testo di hover con tutti i dati principali\n            const timeSec = time[i] || 0;\n            const sec = Math.floor(timeSec % 60);\n            const min = Math.floor((timeSec / 60) % 60);\n            const hr = Math.floor(timeSec / 3600);\n            const tempo = `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n            // Moving time\n            const movingSec = movingTime[i] || 0;\n            const mSec = Math.floor(movingSec % 60);\n            const mMin = Math.floor((movingSec / 60) % 60);\n            const mHr = Math.floor(movingSec / 3600);\n            const movingTempo = `${mHr.toString().padStart(2, '0')}:${mMin.toString().padStart(2, '0')}:${mSec.toString().padStart(2, '0')}`;\n            const dist = fmt(distanceKm[i], 2);\n            // Watt medi sui 10 secondi precedenti\n            let watt10s = 0;\n            let nWatt = 0;\n            for (let j = Math.max(0, i-9); j <= i; j++) {\n                watt10s += power[j];\n                nWatt++;\n            }\n            watt10s = nWatt > 0 ? watt10s / nWatt : 0;\n            // Velocit media cumulativa fino a quel punto (distanza totale / tempo totale in movimento)\n            let velMedia = 0;\n            if (movingTime[i] > 0) velMedia = distanceKm[i] / (movingTime[i] / 3600);\n\n            const kJ_cum = i > 0 ? kJ_cumulativi[i-1] : 0;\n            const kJ_cum_overCP = i > 0 ? kJ_sopraCP_cumulativi[i-1] : 0;\n            let kJ_h_kg = 0, kJ_h_kg_overCP = 0;\n            if (CONFIG.pesoKg > 0 && time[i] > 0) {\n                const hours = time[i] / 3600;\n                kJ_h_kg = kJ_cum / hours / CONFIG.pesoKg;\n                kJ_h_kg_overCP = kJ_cum_overCP / hours / CONFIG.pesoKg;\n            }\n            return (\n                ` ${tempo} | ${movingTempo}` +\n                `<br>` +\n                ` ${dist} km |  ${fmt(watt10s,0)}W 10 ` +\n                `<br>` +\n                ` ${fmt(alt,0)} m |  ${fmt(velMedia,1)} km/h` +\n                `<br>` +\n                ` ${fmt(kJ_cum,0)} kJ | ${fmt(kJ_cum_overCP,0)} kJ > CP` +\n                `<br>` +\n                ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`\n            );\n        }),\n        hoverinfo: 'text',\n        fill: 'tozeroy',\n        type: 'scatter',\n        fillcolor: COLORI.RIEMPIMENTO_ALTITUDINE,\n        line: { color: COLORI.LINEA_ALTITUDINE, width: 2 },\n        mode: 'lines',\n        name: 'Altitudine',\n        yaxis: 'y1',\n        showlegend: false\n    },\n    // --- Barre kJ sopra CP per ogni sezione ---\n    // Ogni barra rappresenta il lavoro sopra CP in una sezione (configurabile)\n    {\n        x: kJOverCPPerSezione.map((_, i) => {\n            const prev = movingTime[sezioniIdx[i-1]||0];\n            return prev + (movingTime[sezioniIdx[i]] - prev) / 2;\n        }),\n        y: kJOverCPPerSezione,\n        type: 'bar',\n        name: 'kJ',\n        marker: { color: COLORI.BARRA_CP, opacity: COLORI.BARRA_CP_OPACITY },\n        yaxis: 'y2',\n        width: kJOverCPPerSezione.map((_, i) => {\n            // Larghezza della barra = durata della sezione in secondi\n            const prev = movingTime[sezioniIdx[i-1]||0];\n            return (movingTime[sezioniIdx[i]] - prev);\n        }),\n        opacity: COLORI.BARRA_CP_OPACITY,\n        showlegend: false,\n        // Testo di hover: mostra kJ totali e watt medi della sezione\n        hovertemplate: kJOverCPPerSezione.map((v, i) => {\n            const startIdx = sezioniIdx[i-1]||0;\n            const endIdx = sezioniIdx[i];\n            let sommaW = 0, n = 0;\n            let kJTot = 0, kJTotOverCP = 0;\n            let durataSec = movingTime[endIdx] - movingTime[startIdx];\n            for (let j = startIdx; j < endIdx; j++) {\n                sommaW += power[j];\n                n++;\n                const dt = time[j] - time[j-1];\n                if (dt < 30) {\n                    kJTot += power[j] * dt / 1000;\n                    if (power[j] >= icu.activity.icu_ftp) kJTotOverCP += power[j] * dt / 1000;\n                }\n            }\n            const wMed = n > 0 ? Math.round(sommaW/n) : 0;\n            let kJ_h_kg = 0, kJ_h_kg_overCP = 0;\n            if (CONFIG.pesoKg > 0 && durataSec > 0) {\n                const hours = durataSec / 3600;\n                kJ_h_kg = kJTot / hours / CONFIG.pesoKg;\n                kJ_h_kg_overCP = kJTotOverCP / hours / CONFIG.pesoKg;\n            }\n            return (\n                ` ${Math.round(v)} kJ<br> ${wMed}W` +\n                `<br> ${kJ_h_kg.toFixed(1)} kJ/h/kg | ${kJ_h_kg_overCP.toFixed(1)} kJ/h/kg > CP<extra></extra>`\n            );\n        }),\n    }\n];\n\n// Evidenziature stile 3m MAP: aggiungi trace per ogni intervallo continuo sopra CP\nlet sopraCPTraces = [];\nlet inInterval = false;\nlet startIdx = 0;\nfor (let i = 0; i < power.length; i++) {\n    if (power[i] >= icu.activity.icu_ftp) {\n        if (!inInterval) {\n            inInterval = true;\n            startIdx = i;\n        }\n    } else {\n        if (inInterval) {\n            // Fine intervallo sopra CP\n            const x = movingTime.slice(startIdx, i);\n            const y = altitude.slice(startIdx, i);\n            sopraCPTraces.push({\n                x: x,\n                y: y,\n                type: 'scatter',\n                mode: 'lines',\n                line: { color: '#fa0710ff', width: 4 },\n                name: 'Sopra CP',\n                yaxis: 'y1',\n                showlegend: false,\n                hoverinfo: 'skip'\n            });\n            inInterval = false;\n        }\n    }\n}\n// Se termina sopra CP\nif (inInterval) {\n    const x = movingTime.slice(startIdx);\n    const y = altitude.slice(startIdx);\n    sopraCPTraces.push({\n        x: x,\n        y: y,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: '#fa0710ff', width: 4 },\n        name: 'Sopra CP',\n        yaxis: 'y1',\n        showlegend: false,\n        hoverinfo: 'skip'\n    });\n}\n// Inserisci i trace sopra CP dopo la traccia altimetrica\ndata.splice(1, 0, ...sopraCPTraces);\n// --- Nuove evidenziature per intervalli di potenza ---\n// Sforzi tra 80%-100% CP (giallo)\nlet tra80e100Traces = [];\nlet in80e100 = false;\nlet start80e100 = 0;\nconst min80 = icu.activity.icu_ftp * 0.8;\nfor (let i = 0; i < power.length; i++) {\n    if (power[i] >= min80 && power[i] < icu.activity.icu_ftp) {\n        if (!in80e100) {\n            in80e100 = true;\n            start80e100 = i;\n        }\n    } else {\n        if (in80e100) {\n            const x = movingTime.slice(start80e100, i);\n            const y = altitude.slice(start80e100, i);\n            tra80e100Traces.push({\n                x: x,\n                y: y,\n                type: 'scatter',\n                mode: 'lines',\n                line: { color: '#ffe600', width: 4 },\n                name: '80-100% CP',\n                yaxis: 'y1',\n                showlegend: false,\n                hoverinfo: 'skip'\n            });\n            in80e100 = false;\n        }\n    }\n}\nif (in80e100) {\n    const x = movingTime.slice(start80e100);\n    const y = altitude.slice(start80e100);\n    tra80e100Traces.push({\n        x: x,\n        y: y,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: '#ffe600', width: 4 },\n        name: '80-100% CP',\n        yaxis: 'y1',\n        showlegend: false,\n        hoverinfo: 'skip'\n    });\n}\n\n// Sforzi sotto 80% CP (verde)\nlet sotto80Traces = [];\nlet inSotto80 = false;\nlet startSotto80 = 0;\nfor (let i = 0; i < power.length; i++) {\n    if (power[i] >= 10 && power[i] < min80) {\n        if (!inSotto80) {\n            inSotto80 = true;\n            startSotto80 = i;\n        }\n    } else {\n        if (inSotto80) {\n            const x = movingTime.slice(startSotto80, i);\n            const y = altitude.slice(startSotto80, i);\n            sotto80Traces.push({\n                x: x,\n                y: y,\n                type: 'scatter',\n                mode: 'lines',\n                line: { color: '#24e04d', width: 4 },\n                name: '<80% CP',\n                yaxis: 'y1',\n                showlegend: false,\n                hoverinfo: 'skip'\n            });\n            inSotto80 = false;\n        }\n    }\n}\nif (inSotto80) {\n    const x = movingTime.slice(startSotto80);\n    const y = altitude.slice(startSotto80);\n    sotto80Traces.push({\n        x: x,\n        y: y,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: '#24e04d', width: 4 },\n        name: '<80% CP',\n        yaxis: 'y1',\n        showlegend: false,\n        hoverinfo: 'skip'\n    });\n}\n\n// Coasting (<10W, blu)\nlet coastingTraces = [];\nlet inCoasting = false;\nlet startCoasting = 0;\nfor (let i = 0; i < power.length; i++) {\n    if (power[i] < 10) {\n        if (!inCoasting) {\n            inCoasting = true;\n            startCoasting = i;\n        }\n    } else {\n        if (inCoasting) {\n            const x = movingTime.slice(startCoasting, i);\n            const y = altitude.slice(startCoasting, i);\n            coastingTraces.push({\n                x: x,\n                y: y,\n                type: 'scatter',\n                mode: 'lines',\n                line: { color: '#1100ffff', width: 4 },\n                name: 'Coasting',\n                yaxis: 'y1',\n                showlegend: false,\n                hoverinfo: 'skip'\n            });\n            inCoasting = false;\n        }\n    }\n}\nif (inCoasting) {\n    const x = movingTime.slice(startCoasting);\n    const y = altitude.slice(startCoasting);\n    coastingTraces.push({\n        x: x,\n        y: y,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: '#1100ffff', width: 4 },\n        name: 'Coasting',\n        yaxis: 'y1',\n        showlegend: false,\n        hoverinfo: 'skip'\n    });\n}\n\n// Inserisci tutte le trace evidenziate dopo la traccia altimetrica\ndata.splice(1 + sopraCPTraces.length, 0, ...tra80e100Traces, ...sotto80Traces, ...coastingTraces);\n\n// Costruisci i segmenti evidenziati sopra CP\n\n// Annotazioni sopra l'asse X con il valore kJ di ogni sezione\n// Calcola i kJ totali per ogni sezione\nconst kJTotaliPerSezione = sezioniIdx.map((idx, i) => {\n    const startIdx = sezioniIdx[i-1]||0;\n    let kJTot = 0;\n    for (let j = startIdx+1; j <= idx; j++) {\n        const dt = time[j] - time[j-1];\n        if (dt < 30) {\n            kJTot += power[j] * dt / 1000;\n        }\n    }\n    return kJTot;\n});\n\n// Solo annotazione kJ per l'ultima sezione, posizionata in alto\n// Annotazione verde in alto con i kJ totali dell'ultima sezione\nlet sectionAnnotations = [];\n// Annotazione kJ totali ultima sezione in alto\nif (kJTotaliPerSezione.length > 0) {\n    const lastIdx = kJTotaliPerSezione.length - 1;\n    const prev = movingTime[sezioniIdx[lastIdx-1]||0];\n    const x = prev + (movingTime[sezioniIdx[lastIdx]] - prev) / 2;\n    sectionAnnotations.push({\n        x: x,\n        y: 0.98,\n        xref: 'x',\n        yref: 'paper',\n        text: `${fmt(kJTotaliPerSezione[lastIdx],0)} kJ`,\n        showarrow: false,\n        yanchor: 'top',\n        font: { color: '#24e04dff', size: 16, family: 'Arial', weight: 'bold' },\n        align: 'center',\n        yshift: 0\n    });\n}\n// Etichette delle barre ai piedi (base, sopra asse x)\nfor (let i = 0; i < kJOverCPPerSezione.length; i++) {\n    const prev = movingTime[sezioniIdx[i-1]||0];\n    const x = prev + (movingTime[sezioniIdx[i]] - prev) / 2;\n    const start = movingTime[sezioniIdx[i-1]||0];\n    const end = movingTime[sezioniIdx[i]];\n    const durataSec = end - start;\n    const min = Math.floor(durataSec / 60);\n    const sec = Math.round(durataSec % 60);\n    const percent = Math.round(kJOverCPPerSezione[i] / CONFIG.KJ_PER_SEZIONE * 100);\n    sectionAnnotations.push({\n        x: x,\n        y: 0,\n        xref: 'x',\n        yref: 'y2',\n        text: `${min}:${sec.toString().padStart(2,'0')}\\n${percent}%`,\n        showarrow: false,\n        yanchor: 'bottom',\n        font: { color: '#000', size: 13, family: 'Arial Black', weight: 'bold' },\n        align: 'center',\n        yshift: 2\n    });\n}\n\n// Crea le shapes verticali per le sezioni (linee verdi continue, poco spesse)\nconst shapesVerticali = sezioniIdx.map(idx => ({\n    type: 'line',\n    xref: 'x',\n    yref: 'paper',\n    x0: movingTime[idx],\n    x1: movingTime[idx],\n    y0: 0,\n    y1: 1,\n    line: {\n        color: '#24e04dff', // verde\n        width: 1,\n        dash: 'solid'\n    }\n}));\n\n// Segnalini pause superiori a 5 minuti (dt >= 300): emoji  posizionata appena sotto la traccia altimetrica\nconst pauseAnnotations = [];\nfor (let i = 1; i < time.length; i++) {\n    const dt = time[i] - time[i - 1];\n    if (dt >= 300 && dt < 900) { // tra 5 e 15 minuti\n        pauseAnnotations.push({\n            x: movingTime[i],\n            y: altitude[i] + 70,\n            xref: 'x',\n            yref: 'y',\n            text: '',\n            showarrow: false,\n            font: { color: '#d80000', size: 15, family: 'Arial' },\n            yanchor: 'middle',\n            align: 'center',\n            yshift: 0\n        });\n    } else if (dt >= 900) { // sopra 15 minuti\n        pauseAnnotations.push({\n            x: movingTime[i],\n            y: altitude[i] + 70,\n            xref: 'x',\n            yref: 'y',\n            text: '',\n            showarrow: false,\n            font: { color: '#d80000', size: 15, family: 'Arial' },\n            yanchor: 'middle',\n            align: 'center',\n            yshift: 0\n        });\n    }\n}\n\n// ...\n\nconst layout = {\n    ...BASE_LAYOUT,\n    title: `${CONFIG.KJ_KG_PER_SEZIONE} kJ*kg sections (${fmt(CONFIG.KJ_PER_SEZIONE,0)} kJ)`,\n    xaxis: {\n        title: 'Tempo in movimento (s)',\n        // Mostra tick ogni 10 km\n        tickvals: (() => {\n            const vals = [];\n            for (let i = 0; i < distanceKm.length; i++) {\n                if (i === 0 || Math.floor(distanceKm[i] / 10) > Math.floor(distanceKm[i - 1] / 10)) {\n                    vals.push(movingTime[i]);\n                }\n            }\n            return vals;\n        })(),\n        ticktext: (() => {\n            const texts = [];\n            for (let i = 0; i < distanceKm.length; i++) {\n                if (i === 0 || Math.floor(distanceKm[i] / 10) > Math.floor(distanceKm[i - 1] / 10)) {\n                    texts.push(Math.round(distanceKm[i]) + ' km');\n                }\n            }\n            return texts;\n        })(),\n        hoverformat: '',\n    },\n    yaxis: {\n        title: 'Altitudine (m)',\n        range: [0, Math.max(...altitude, 1) * 1.05 + 50] // aggiungi margine sopra\n    },\n    yaxis2: {\n        overlaying: 'y',\n        side: 'right',\n        showgrid: false,\n        zeroline: false,\n        visible: true,\n        title: 'kJ',\n        color: COLORI.BARRA_CP,\n        tickfont: { color: COLORI.BARRA_CP },\n        titlefont: { color: COLORI.BARRA_CP },\n        rangemode: 'tozero',\n        range: [0, CONFIG.KJ_PER_SEZIONE]\n    },\n    shapes: [...shapesVerticali],\n    annotations: [...sectionAnnotations, ...pauseAnnotations]\n};\n\nconst chart = { data, layout };\nchart;",
        "name": "kj*kg sections"
      },
      "usage_count": 0,
      "index": 35,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-14T17:14:01.280+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 676292,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "JR Power",
      "description": null,
      "image": null,
      "content": {
        "id": "ifneplw7",
        "name": "JR Power",
        "plots": [
          {
            "id": 1,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 120
            },
            "band": 0,
            "fill": "#FFCB0EBF",
            "text": "2m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#FFCB0EBF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 180
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "3m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#FF520EFF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 300
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "5m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009E00FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 360
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "6m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#DD04A7FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 600
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "10m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#DD044747",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 900
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "15m",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#00C9FFFF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 7,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 120
            },
            "band": 0,
            "fill": "#FFCB0EBF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 8,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 180
            },
            "band": 0,
            "fill": "#FF520EFF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 9,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 300
            },
            "band": 0,
            "fill": "#009E00FF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 10,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 360
            },
            "band": 0,
            "fill": "#DD04A7FF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 11,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 600
            },
            "band": 0,
            "fill": "#DD044747",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 12,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 900
            },
            "band": 0,
            "fill": "#00C9FFFF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 330,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "POWER",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 36,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-06-11T08:41:04.211+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 704583,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "8' efforts",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "400px",
        "script": "// =====================\n// CONFIGURAZIONE INIZIALE\nconst CONFIG = {\n    EFFORT_WINDOW_SECONDS: 480,              // durata della finestra di sforzo in secondi (es. 180 per 3 minuti)\n    MIN_EFFORT_INTENSITY_FTP: 90,           // intensit minima come percentuale del FTP (es. 100 per 100% FTP)\n    MIN_AVG_GRADE_FOR_THEORETICAL: 4.5,      // pendenza media minima (%) per mostrare valori teorici\n    ZONE_COLORS: [                           // array di oggetti { threshold, color, label } per la colorazione delle zone di potenza\n        { threshold: 106, color: \"#1f77b4\", label: \"CP-just above\" },\n        { threshold: 116, color: \"#3eb33e\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbd\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315ca\", label: \"Supra-MAP\" },\n    ],\n    ZONE_COLOR_DEFAULT: { color: \"#000000\", label: \"Anaerobico\" }, // colore e label di default per zone sopra la soglia massima\n    COLORE_LINEA_ALTITUDINE: '#e2dede',      // colore linea altitudine\n    COLORE_RIEMPIMENTO_ALTITUDINE: '#e2dede' // colore riempimento altitudine\n};\n// =====================\n\nconst fmt = (num, digits = 0) => Number(num).toFixed(digits);\nconst formatSecondsToHHMMSS = seconds => {\n    const sec = Math.floor(seconds % 60);\n    const min = Math.floor((seconds / 60) % 60);\n    const hr = Math.floor(seconds / 3600);\n    return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n};\nconst getStreamData = streamName => {\n    const stream = icu.streams.get(streamName);\n    return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n};\n\n\n\nconst altitude = getStreamData(\"fixed_altitude\");\nconst distance = getStreamData(\"distance\");\nconst distanceKm = distance.map(d => d / 1000);\nconst power = getStreamData(\"fixed_watts\");\nconst heartrate = getStreamData(\"fixed_heartrate\");\nconst grade = getStreamData(\"grade_smooth\");\nconst time = getStreamData(\"time\");\nconst weight = icu.activity.icu_weight;\nconst FTP = icu.activity.icu_ftp;\n\nconst getZoneColor = (avgPower, FTP) => {\n    if (!FTP || FTP <= 0) return 'grey';\n    const percentage = (avgPower / FTP) * 100;\n    for (const zone of CONFIG.ZONE_COLORS) {\n        if (percentage < zone.threshold) return zone.color;\n    }\n    return CONFIG.ZONE_COLOR_DEFAULT.color;\n};\n\n// Correggi i valori iniziali di altitudine (sostituisci gli zeri iniziali con il primo valore non zero)\n\nconst firstNonZeroAltitude = altitude.find(value => value !== 0);\nif (firstNonZeroAltitude !== undefined) {\n    for (let i = 0; i < altitude.length; i++) {\n        if (altitude[i] === 0) altitude[i] = firstNonZeroAltitude;\n        else break;\n    }\n}\n\n\nconst kJ_cumulativi = [];\nconst kJ_sopraCP_cumulativi = [];\nlet joules = 0, joulesOverCP = 0;\nfor (let i = 0; i < power.length; i++) {\n    const w = power[i];\n    const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n    if (secs < 30) {\n        joules += w * secs;\n        if (w >= FTP) joulesOverCP += w * secs;\n    }\n    kJ_cumulativi.push(joules / 1000);\n    kJ_sopraCP_cumulativi.push(joulesOverCP / 1000);\n}\n\nconst traces = [\n    {\n        x: distanceKm,\n        y: altitude,\n        text: altitude.map((alt, i) => {\n            const dist = fmt(distanceKm[i], 2);\n            const tempo = formatSecondsToHHMMSS(time[i] || 0);\n            let kJ_h_kg = 0, kJ_h_kg_overCP = 0;\n            if (weight > 0 && time[i] > 0) {\n                const hours = time[i] / 3600;\n                kJ_h_kg = kJ_cumulativi[i] / hours / weight;\n                kJ_h_kg_overCP = kJ_sopraCP_cumulativi[i] / hours / weight;\n            }\n            return (\n                ` ${tempo}` +\n                `<br>` +\n                ` ${dist} km` +\n                `<br>` +\n                ` ${fmt(alt,0)} m` +\n                `<br>` +\n                ` ${fmt(kJ_cumulativi[i],0)} kJ | ${fmt(kJ_sopraCP_cumulativi[i],0)} kJ > CP` +\n                `<br>` +\n                ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`\n            );\n        }),\n        hoverinfo: 'text',\n        fill: 'tozeroy',\n        type: 'scatter',\n        fillcolor: CONFIG.COLORE_RIEMPIMENTO_ALTITUDINE,\n        line: { color: CONFIG.COLORE_LINEA_ALTITUDINE, width: 2 },\n        mode: 'lines',\n        name: 'Altitudine'\n    }\n];\n    const annotations = [];\n    // Trova tutti gli sforzi non sovrapposti sopra la soglia\n    function getAllNonOverlappingEffortsAboveThreshold(data, n, threshold, samplingRate = 1) {\n        const windowSize = n * samplingRate;\n        const results = [];\n        if (data.length < windowSize) return results;\n        let sum = 0;\n        for (let i = 0; i < windowSize; i++) sum += data[i];\n        const candidates = [];\n        if (sum / windowSize >= threshold) candidates.push({ avg: sum / windowSize, start: 0 });\n        for (let i = 1; i <= data.length - windowSize; i++) {\n            sum = sum - data[i - 1] + data[i + windowSize - 1];\n            const avg = sum / windowSize;\n            if (avg >= threshold) candidates.push({ avg, start: i });\n        }\n        candidates.sort((a, b) => b.avg - a.avg);\n        const used = Array(data.length).fill(false);\n        for (const cand of candidates) {\n            let overlap = false;\n            for (let j = cand.start; j < cand.start + windowSize; j++) {\n                if (used[j]) { overlap = true; break; }\n            }\n            if (!overlap) {\n                results.push(cand);\n                for (let j = cand.start; j < cand.start + windowSize; j++) used[j] = true;\n            }\n        }\n        results.sort((a, b) => a.start - b.start);\n        return results;\n    }\n\n// Trova tutti gli sforzi non sovrapposti sopra la soglia configurata\nconst allEfforts = getAllNonOverlappingEffortsAboveThreshold(\n    power,\n    CONFIG.EFFORT_WINDOW_SECONDS,\n    (CONFIG.MIN_EFFORT_INTENSITY_FTP / 100) * FTP,\n    1\n);\nconst sortedEfforts = allEfforts.slice().sort((a, b) => b.avg - a.avg);\nsortedEfforts.forEach((best, idx) => {\n        const avgPower = best.avg;\n        const bestStart = best.start;\n        const bestEnd = bestStart + CONFIG.EFFORT_WINDOW_SECONDS;\n        const sectionPower = power.slice(bestStart, bestEnd);\n        const sectionHR = heartrate.slice(bestStart, bestEnd);\n        const sectionAltitude = altitude.slice(bestStart, bestEnd);\n        const sectionDistance = distance.slice(bestStart, bestEnd);\n        const sectionDistanceKm = distanceKm.slice(bestStart, bestEnd);\n        const sectionGrade = grade.slice(bestStart, bestEnd);\n        const sectionTime = time.slice(bestStart, bestEnd);\n\n        // Calcolo delle metriche\n        const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n        const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n        const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n        const avgSpeed = dist / (climbTimeInSeconds / 3600) / 1000;\n        const vam = elevationGain / (climbTimeInSeconds / 3600);\n        const avgGrade = elevationGain / dist * 100;\n        const gradientFactor = 2 + (avgGrade / 10);\n        const vamTeorico = weight > 0 ? (avgPower / weight) * (gradientFactor * 100) : 0;\n        let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n        if (sectionPower.length) {\n            const half = Math.floor(sectionPower.length / 2);\n            avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n            avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n            wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n        }\n        const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n        const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n        const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n        const startTime = sectionTime.length ? sectionTime[0] : '';\n        let best5sWatt = '', best5sWattKg = '';\n        let avgPowerPerKg = 0;\n        if (sectionPower.length >= 5 && weight > 0) {\n            let maxW = 0;\n            let sum = 0;\n            for (let i = 0; i < sectionPower.length; i++) {\n                sum += sectionPower[i];\n                if (i >= 5) sum -= sectionPower[i - 5];\n                if (i >= 4) {\n                    const avg5 = sum / 5;\n                    if (avg5 > maxW) maxW = avg5;\n                }\n            }\n            best5sWatt = Math.round(maxW);\n            best5sWattKg = fmt(maxW / weight, 2);\n            avgPowerPerKg = avgPower / weight;\n        }\n        const bgColor = getZoneColor(avgPower, FTP);\n        let joules = 0, joulesOverCP = 0;\n        if (power && time && bestStart !== undefined && bestStart < power.length && FTP) {\n            for (let i = 0; i < bestStart; i++) {\n                const w = power[i];\n                const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n                if (secs < 30) {\n                    joules += w * secs;\n                    if (w >= FTP) joulesOverCP += w * secs;\n                }\n            }\n        }\n        const hours = (time && bestStart !== undefined && time[bestStart]) ? (time[bestStart] / 3600) : 0;\n        const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n        const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n        const traceText = [\n            (() => {\n                const sectionCadence = getStreamData(\"cadence\").slice(bestStart, bestEnd);\n                const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n                return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n            })(),\n            ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n            ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n            ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n            ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n            (() => {\n                if (avgGrade >= CONFIG.MIN_AVG_GRADE_FOR_THEORETICAL) {\n                    const diffVAM = Math.abs(vamTeorico - vam);\n                    let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                    const wkgteoric = vam / (gradientFactor * 100);\n                    const diffWkg = avgPowerPerKg - wkgteoric;\n                    return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n                } else {\n                    return ` ${fmt(vam,0)} m/h`;\n                }\n            })(),\n            (() => {\n                if (avgGrade >= CONFIG.MIN_AVG_GRADE_FOR_THEORETICAL) {\n                    const wkgteoric = vam / (gradientFactor * 100);\n                    const diffWkg = avgPowerPerKg - wkgteoric;\n                    const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                    const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                    return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n                } else {\n                    return '';\n                }\n            })(),\n            startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '',\n            ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n            ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n        ].filter(Boolean).join('<br>');\n        traces.push({\n            x: sectionDistanceKm,\n            y: sectionAltitude,\n            type: 'scatter',\n            mode: 'lines',\n            line: { color: bgColor, width: 2 },\n            name: `${fmt(avgPower)} W | #${idx + 1}`,\n            hoverinfo: 'text',\n            visible: true,\n            hoverlabel: { align: 'left' },\n            text: traceText\n        });\n\n        // Offset delle posizioni delle annotazioni per evitare sovrapposizioni\n        annotations.push({\n            x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2 + (idx % 2 === 0 ? -1 : 1) * idx * 0.003,\n            y: Math.max(...sectionAltitude) + 50 + idx * 25,\n            text: `#${idx + 1}<br> ${fmt(avgPower)}`,\n            showarrow: false,\n            font: { family: 'Arial', size: 12, color: 'white' },\n            align: 'center',\n            bgcolor: bgColor,\n            opacity: 0.9\n        });\n    });\n\n    // Titolo dinamico del grafico basato sulla configurazione\nconst effortMin = Math.floor(CONFIG.EFFORT_WINDOW_SECONDS / 60);\nconst effortSec = CONFIG.EFFORT_WINDOW_SECONDS % 60;\nconst effortLabel = effortSec > 0 ? `${effortMin}m ${effortSec}s` : `${effortMin}m`;\nconst layout = {\n    title: `All ${effortLabel} Power Efforts >${fmt(CONFIG.MIN_EFFORT_INTENSITY_FTP,0)}% CP`,\n    xaxis: { title: 'Distance (km)' },\n    yaxis: { title: 'Altitude (m)' },\n    annotations: annotations,\n    hovermode: 'x unified',\n    showlegend: true,\n    margin: { t: 100, l: 50, r: 50, b: 50 },\n    height: 500\n};\n\nconst chart = { data: traces, layout };\nchart;",
        "name": "8' efforts"
      },
      "usage_count": 0,
      "index": 36,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-19T18:19:00.426+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 273816,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Anaerobic Power",
      "description": null,
      "image": null,
      "content": {
        "id": "8b378fyh",
        "name": "Anaerobic Power",
        "plots": [
          {
            "id": 1,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 2
            },
            "band": 0,
            "fill": "#FFCB0EBF",
            "text": "2s",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#FFCB0EBF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 5
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "5s",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#FF520EFF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 8
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "8s",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009E00FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 15
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "15s",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#DD04A7FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 30
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "30s",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#DD044747",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "week_max",
            "min": null,
            "args": {
              "secs": 60
            },
            "band": 0,
            "fill": "rgba(51,76,204, 0.4)",
            "text": "60s",
            "type": "line",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#00C9FFFF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 7,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 2
            },
            "band": 0,
            "fill": "#FFCB0EBF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 8,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 5
            },
            "band": 0,
            "fill": "#FF520EFF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 9,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 8
            },
            "band": 0,
            "fill": "#009E00FF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 10,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 15
            },
            "band": 0,
            "fill": "#DD04A7FF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 11,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 30
            },
            "band": 0,
            "fill": "#DD044747",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 12,
            "agg": "none",
            "min": null,
            "args": {
              "secs": 60
            },
            "band": 0,
            "fill": "#00C9FFFF",
            "text": "Best Power",
            "type": "dot",
            "field": "best_power",
            "gauge": true,
            "scale": "watts",
            "stack": "",
            "title": "Best power",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [],
            "i18nKey": "Best Power",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Best power",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 330,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "POWER",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 37,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-10-23T18:22:19.831+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 704586,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "8' bar",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "250px",
        "script": "(function() {\n  const CONFIG = {\n    // CONFIGURAZIONE PRINCIPALE\n    // ============================================================================\n    DURATION: 480,                    // Durata finestra sforzo (secondi)\n    MIN_EFFORT_INTENSITY_FTP: 90,    // Soglia minima effort (% FTP)\n    // ============================================================================\n    // Ordinamento barre possibile su (valori stringa):\n    // 'avgPower', 'avgPowerPerKg', 'avgHR', 'maxHR', 'startTime', 'bestStart',\n    // 'dist', 'distKm', 'elevationGain', 'avgGrade', 'maxGrade',\n    // 'rat_1', 'rat_2', 'ratio', 'ascentSpeed', 'avgHorizontalSpeed',\n    // 'best5sWatts', 'best5sPerKg', 'TEORICWKG', 'TEORICVAM'\n    SORT_BY: 'avgPower',\n    BAR_TEXT_COLOR: '#000',                // Colore testo barre\n    BAR_TEXT_FONT: { family: 'Arial Black', size: 13 }, // Font testo barre\n    GRID_X_COLOR: '#eee',                  // Colore griglia X\n    GRID_X_WIDTH: 1,                       // Spessore griglia X\n    GRID_Y_COLOR: '#ccc',                  // Colore griglia Y\n    GRID_Y_WIDTH: 1,                       // Spessore griglia Y\n    VISIBLE_BARS: 7,                 // Numero barre visibili nel grafico\n\n    ZONES: [\n      { name: 'Z2', max: 76, color: '#4c72b0' },\n      { name: 'Z3', max: 91, color: '#55a868' },\n      { name: 'Z4', max: 106, color: '#dd8452' },\n      { name: 'Z5', max: 126, color: '#c44e52' },\n      { name: 'Z6', max: 151, color: '#a64d79' },\n      { name: 'Z7', max: Infinity, color: '#8172b3' }\n    ]\n  };\n// =====================\n// FINE CONFIGURAZIONE\n// =====================\n\n// =====================\n// LAYOUT GRAFICO\n// =====================\nconst LAYOUT = {\n  title: '',\n  barmode: 'group',\n  showlegend: false,\n  height: 250,\n  margin: {l: 40, r: 20, t: 40, b: 40},\n  xaxis: {\n    title: 'Effort',\n    range: [0, CONFIG.VISIBLE_BARS - 0.5],\n    fixedrange: false,\n    autorange: false,\n    tickmode: 'linear',\n    tick0: 1,\n    dtick: 1,\n    showgrid: true,\n    gridcolor: CONFIG.GRID_X_COLOR,\n    gridwidth: CONFIG.GRID_X_WIDTH,\n    scrollZoom: true\n  },\n  yaxis: {\n    title: 'Avg Power (W)',\n    dtick: 50,\n    gridcolor: CONFIG.GRID_Y_COLOR,\n    gridwidth: CONFIG.GRID_Y_WIDTH\n  }\n};\n\n// =====================\n// DATI ATTIVIT\n// =====================\nconst activity = icu.activity;\nconst weight = activity.icu_weight;\nconst FTP = activity.icu_ftp;\n\nfunction getStreamData(streamName) {\n  const stream = icu.streams.get(streamName);\n  return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\nconst power = getStreamData(\"fixed_watts\");\n\n// Trova tutti gli sforzi non sovrapposti sopra una certa soglia\nfunction getNonOverlappingEffortsAboveThreshold(data, n, threshold, samplingRate = 1) {\n  const windowSize = n * samplingRate;\n  let results = [];\n  if (data.length < windowSize) return results;\n  let sum = data.slice(0, windowSize).reduce((a, b) => a + b, 0);\n  let candidates = [];\n  if (sum / windowSize >= threshold) {\n    candidates.push({ avg: sum / windowSize, start: 0 });\n  }\n  for (let i = 1; i <= data.length - windowSize; i++) {\n    sum = sum - data[i - 1] + data[i + windowSize - 1];\n    const avg = sum / windowSize;\n    if (avg >= threshold) {\n      candidates.push({ avg, start: i });\n    }\n  }\n  candidates.sort((a, b) => b.avg - a.avg);\n  let used = Array(data.length).fill(false);\n  for (const cand of candidates) {\n    let overlap = false;\n    for (let j = cand.start; j < cand.start + windowSize; j++) {\n      if (used[j]) {\n        overlap = true;\n        break;\n      }\n    }\n    if (!overlap) {\n      results.push(cand);\n      for (let j = cand.start; j < cand.start + windowSize; j++) {\n        used[j] = true;\n      }\n    }\n  }\n  results.sort((a, b) => a.start - b.start);\n  return results;\n}\n\n\n\nlet x = [];\nlet y = [];\nlet hover = [];\nlet effortData = [];\nconst heartrate = getStreamData(\"fixed_heartrate\");\nconst time = getStreamData(\"time\");\nconst distance = getStreamData(\"distance\");\nconst altitude = getStreamData(\"fixed_altitude\");\nconst grade = getStreamData(\"grade_smooth\");\n\nfunction secondsToHms(seconds) {\n  seconds = Math.floor(seconds);\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds % 3600) / 60);\n  const s = seconds % 60;\n  let str = '';\n  if (h > 0) str += String(h).padStart(2, '0') + ':';\n  str += (h > 0 ? String(m).padStart(2, '0') : m) + ':' + String(s).padStart(2, '0');\n  return str;\n}\n\n// Soglia in watt (da percentuale FTP)\nconst threshold = (CONFIG.MIN_EFFORT_INTENSITY_FTP / 100) * FTP;\n\n\nconst allEfforts = getNonOverlappingEffortsAboveThreshold(\n  power,\n  CONFIG.DURATION,\n  threshold,\n  1\n);\nfor (const [idx, best] of allEfforts.entries()) {\n  const bestStart = best.start;\n  const bestEnd = bestStart + CONFIG.DURATION;\n  const sectionHR = heartrate.slice(bestStart, bestEnd);\n  const sectionDistance = distance.slice(bestStart, bestEnd);\n  const sectionAltitude = altitude.slice(bestStart, bestEnd);\n  const sectionGrade = grade.slice(bestStart, bestEnd);\n  const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n  const maxHR = Math.max(...sectionHR);\n  const startTime = secondsToHms(time[bestStart]);\n  const avgPower = best.avg;\n  const avgPowerPerKg = avgPower / weight;\n  const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n  const distKm = dist / 1000;\n  const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n  const avgGrade = dist > 0 ? (elevationGain / dist * 100) : 0;\n  const maxGrade = Math.max(...sectionGrade);\n  // Ratio: prima met, seconda met, ratio\n  const firstHalf = power.slice(bestStart, bestStart + CONFIG.DURATION/2);\n  const secondHalf = power.slice(bestStart + CONFIG.DURATION/2, bestEnd);\n  const rat_1 = firstHalf.reduce((a,b)=>a+b,0)/firstHalf.length;\n  const rat_2 = secondHalf.reduce((a,b)=>a+b,0)/secondHalf.length;\n  const ratio = rat_2 / rat_1;\n  // VAM\n  const climbTimeH = CONFIG.DURATION / 3600;\n  const ascentSpeed = elevationGain / climbTimeH;\n  const avgHorizontalSpeed = distKm / (CONFIG.DURATION / 3600);\n  // Best 5s\n  let best5sWatts = 0;\n  for (let i = 0; i <= power.slice(bestStart, bestEnd).length - 5; i++) {\n    const avg5 = power.slice(bestStart + i, bestStart + i + 5).reduce((a,b)=>a+b,0)/5;\n    if (avg5 > best5sWatts) best5sWatts = avg5;\n  }\n  const best5sPerKg = best5sWatts / weight;\n  // Teorici (come in PIAN HC)\n  const gradientFactor = (2 + avgGrade / 10) * 100;\n  const TEORICWKG = ascentSpeed / gradientFactor;\n  const TEORICVAM = avgPowerPerKg * gradientFactor;\n  effortData.push({\n    idx,\n    avgPower,\n    avgPowerPerKg,\n    avgHR,\n    maxHR,\n    startTime,\n    bestStart,\n    dist,\n    distKm,\n    elevationGain,\n    avgGrade,\n    maxGrade,\n    rat_1,\n    rat_2,\n    ratio,\n    ascentSpeed,\n    avgHorizontalSpeed,\n    best5sWatts,\n    best5sPerKg,\n    TEORICWKG,\n    TEORICVAM\n  });\n}\n\n// Ordina effort secondo la propriet scelta in config\neffortData.sort((a, b) => b[CONFIG.SORT_BY] - a[CONFIG.SORT_BY]);\nfor (const [i, effort] of effortData.entries()) {\n  x.push(`${i+1}`);\n  y.push(effort.avgPower);\n  hover.push(\n    ` ${(effort.dist / 1000).toFixed(2)} km (${effort.elevationGain.toFixed(0)} m)<br>`+\n    `  ${effort.avgGrade.toFixed(1)}% | max. ${effort.maxGrade.toFixed(1)}%<br>`+\n    ` ${effort.avgPower.toFixed(0)} W | 5 ${effort.best5sWatts.toFixed(0)} W<br>`+\n    ` ${effort.avgPowerPerKg.toFixed(2)} W/kg | 5 ${effort.best5sPerKg.toFixed(2)} W/kg<br>`+\n    ` ${effort.rat_1.toFixed(0)} W | ${effort.rat_2.toFixed(0)} W | ${(effort.ratio).toFixed(2)}<br>`+\n    `  ${effort.avgHR.toFixed(0)} bpm | max. ${effort.maxHR} bpm<br>`+\n    ` ${effort.avgHorizontalSpeed.toFixed(1)} km/h |  ${effort.ascentSpeed.toFixed(0)} m/h<br>`+\n    ` ${effort.startTime}`\n  );\n}\n\n\n\n// Restituisce il colore HEX della zona in base alla % FTP, usando la config\nfunction getZoneColor(avgPower, ftp) {\n  const percentage = (avgPower / ftp) * 100;\n  for (const zone of CONFIG.ZONES) {\n    if (percentage < zone.max) return zone.color;\n  }\n  // fallback (non dovrebbe mai servire)\n  return '#000';\n}\n\nconst barColors = y.map((v) => getZoneColor(v, FTP));\n\n\nconst data = [\n  {\n    x: x,\n    y: y,\n    type: 'bar',\n    marker: {\n      color: barColors\n    },\n    text: x.map((label, i) =>\n      `${y[i].toFixed(0)} W | ${effortData[i].avgPowerPerKg.toFixed(2)} W/kg<br>`\n      + `${effortData[i].rat_1.toFixed(0)} W | ${effortData[i].rat_2.toFixed(0)} W | ${effortData[i].ratio.toFixed(2)}<br>`\n      + ` ${effortData[i].avgHR.toFixed(0)} bpm | ${effortData[i].maxHR} bpm<br>`\n      + `${effortData[i].ascentSpeed.toFixed(0)} m/h |  ${effortData[i].avgGrade.toFixed(1)}%<br>`\n      + `${effortData[i].startTime}`\n    ),\n    textposition: 'inside',\n    insidetextanchor: 'start',\n    textfont: {\n      color: CONFIG.BAR_TEXT_COLOR,\n      size: CONFIG.BAR_TEXT_FONT.size,\n      family: CONFIG.BAR_TEXT_FONT.family\n    },\n    hoverinfo: 'text',\n    hovertext: hover,\n    hoverlabel: { font: { color: CONFIG.BAR_TEXT_COLOR, family: CONFIG.BAR_TEXT_FONT.family, size: CONFIG.BAR_TEXT_FONT.size }, align: 'left' },\n    name: 'Avg Power',\n    visible: true\n  }\n];\n\n\n\n// Aggiorna dinamicamente titolo e range xaxis in base alla config\nconst minEffort = CONFIG.MIN_EFFORT_INTENSITY_FTP;\nconst duration = CONFIG.DURATION;\nconst durationMin = duration % 60 === 0 ? (duration/60) + '' : duration + 's';\nLAYOUT.title = `${durationMin} efforts (>${minEffort}% FTP)`;\nLAYOUT.xaxis.range = [0, CONFIG.VISIBLE_BARS - 0.5];\n\nreturn { data: data, layout: LAYOUT };\n})();",
        "name": "8' bar"
      },
      "usage_count": 0,
      "index": 37,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-19T18:18:33.297+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 273859,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "HR+RPE BONVI",
      "description": "Max HR and Avg HR and RPE",
      "image": null,
      "content": {
        "id": "7vot55bc",
        "name": "HR+RPE BONVI",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "vid": "273765.1",
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "Avg HR",
            "type": "dot",
            "field": "avg_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Avg heartrate",
            "extras": [
              {
                "id": 1,
                "y1": 0,
                "y2": 125,
                "fill": "#D627281A",
                "text": "Recovery",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.2
              },
              {
                "id": 2,
                "y1": 125,
                "y2": 142,
                "fill": "#D6272833",
                "text": "Aerobic",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.2
              },
              {
                "id": 3,
                "y1": 142,
                "y2": 152,
                "fill": "#D627284D",
                "text": "Tempo",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.2
              },
              {
                "id": 4,
                "y1": 152,
                "y2": 166,
                "fill": "#D6272866",
                "text": "Threshold",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.3
              },
              {
                "id": 5,
                "y1": 166,
                "y2": 177,
                "fill": "#D6272880",
                "text": "VO2Max",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.3
              },
              {
                "id": 6,
                "y1": 177,
                "y2": 186,
                "fill": "#D6272899",
                "text": "MAX",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.4
              }
            ],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(214,39,40)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Avg HR",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Avg heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": null,
            "vid": "273765.2",
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "AVG 42d",
            "type": "line",
            "field": "avg_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Avg heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#D6272873",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Avg HR",
            "markerValue": "right",
            "strokeWidth": 4,
            "i18nTitleKey": "Avg heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "vid": "273765.3",
            "band": 0,
            "fill": "#C728299C",
            "text": "Max HR",
            "type": "dot",
            "field": "max_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Max heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Max HR",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Max heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "moving_avg",
            "min": null,
            "vid": "273765.4",
            "band": 0,
            "fill": "#A51A1B4A",
            "text": "MAX 42d",
            "type": "line",
            "field": "max_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Max heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#A31011FF",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Max HR",
            "markerValue": "right",
            "strokeWidth": 4,
            "i18nTitleKey": "Max heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 440,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "HR",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 38,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-07T11:45:39.210+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 658941,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "60s over 500",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Over500",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": "",
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data;\nthreshold = 500;\nwindow_size = 60;\n\noccurrences = 0;\nsum = 0;\n\n// Calcola la somma iniziale dei primi 60 valori\nfor (i = 0; i < window_size; i++) {\n    sum += watts[i];\n}\n\nfor (i = 0; i <= watts.length - window_size; i++) {\n    avg = sum / window_size;\n    if (avg >= threshold) {\n        occurrences += 1;\n        i += window_size - 1;\n        if (i + window_size >= watts.length) break;\n        // ricalcola la somma per la nuova finestra\n        sum = 0;\n        for (j = 0; j < window_size; j++) {\n            sum += watts[i + j];\n        }\n    } else {\n        // aggiorna la somma per la finestra successiva\n        sum = sum - watts[i] + watts[i + window_size];\n    }\n}\n\noccurrences;",
        "suffix": "",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "60s over 500"
      },
      "usage_count": 34,
      "index": 38,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T07:26:09.491+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 704641,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "kj*ks sections LITE",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "250px",
        "script": "(() => {\n// --- CONFIGURAZIONE, COLORI, FUNZIONI E LAYOUT ---\n\nconst CONFIG = {\n    KJ_KG_PER_SEZIONE: 3, // <--- Modifica qui per cambiare la dimensione delle sezioni kJ*kg\n    pesoKg: icu.activity.icu_weight,\n};\nCONFIG.KJ_PER_SEZIONE = CONFIG.KJ_KG_PER_SEZIONE * CONFIG.pesoKg;\n\n// --- CONFIGURAZIONE COLORI TRACCE ---\nconst COLORI = {\n    LINEA_ALTITUDINE: '#e2dedeff',\n    RIEMPIMENTO_ALTITUDINE: '#e2dedeff',\n    BARRA_CP: '#c44e52',\n    BARRA_CP_OPACITY: 0.4, \n    SOPRA_CP: '#fa0710ff',\n    TRA_80_100: '#ffe600',\n    SOTTO_80: '#24e04d',\n    COASTING: '#1100ffff'\n};\n\nconst fmt = (num, digits = 0) => Number(num).toFixed(digits);\nfunction getStreamData(streamName) {\n    const stream = icu.streams.get(streamName);\n    return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\n\n// Layout base (verr usato pi sotto)\nconst BASE_LAYOUT = {\n    height: 400,\n    margin: { t: 60, l: 40, r: 20, b: 40 },\n};\n\n// Stream principali\nconst altitude_raw = getStreamData(\"fixed_altitude\");\nconst distance_raw = getStreamData(\"distance\");\nconst time_raw = getStreamData(\"time\");\nconst power_raw = getStreamData(\"fixed_watts\");\nconst distanceKm_raw = distance_raw.map(d => d / 1000);\n\n// Downsampling ogni 5 secondi\nconst DOWNSAMPLE_STEP = 5; // secondi\nlet altitude = [], distance = [], time = [], power = [], distanceKm = [];\nfor (let i = 0; i < time_raw.length; i++) {\n    if (i === 0 || time_raw[i] - time_raw[0] < 1 || (time_raw[i] - time_raw[0]) % DOWNSAMPLE_STEP === 0) {\n        altitude.push(altitude_raw[i]);\n        distance.push(distance_raw[i]);\n        time.push(time_raw[i]);\n        power.push(power_raw[i]);\n        distanceKm.push(distanceKm_raw[i]);\n    }\n}\n\n// Calcola tempo trascorso in movimento (asse X)\n\n\n// Calcola il moving time escludendo pause e micro-movimenti (velocit istantanea > 1 km/h)\nlet movingTime = [0];\nfor (let i = 1; i < time.length; i++) {\n    const dt = time[i] - time[i - 1];\n    const dd = distanceKm[i] - distanceKm[i-1];\n    const v = dt > 0 ? (dd * 3600) / dt : 0;\n    if (v > 1) {\n        movingTime.push(movingTime[movingTime.length - 1] + dt);\n    } else {\n        movingTime.push(movingTime[movingTime.length - 1]);\n    }\n}\n\n// Calcola le posizioni delle sezioni da KJ_PER_SEZIONE (kJ assoluti) e kJ sopra CP per ciascuna\nlet sezioniIdx = [];\nlet kJAcc = 0, kJAccOverCP = 0;\nlet kJOverCPPerSezione = [];\nfor (let i = 1; i < power.length; i++) {\n    const w = power[i];\n    const dt = time[i] - time[i - 1];\n    if (dt < 30) {\n        kJAcc += w * dt / 1000;\n        if (w >= icu.activity.icu_ftp) kJAccOverCP += w * dt / 1000;\n    }\n    if (kJAcc >= CONFIG.KJ_PER_SEZIONE) {\n        sezioniIdx.push(i);\n        kJOverCPPerSezione.push(kJAccOverCP);\n        kJAcc = 0;\n        kJAccOverCP = 0;\n    }\n}\n// Se rimane una sezione finale non vuota, aggiungila\nif (kJAcc > 0) {\n    sezioniIdx.push(power.length - 1);\n    kJOverCPPerSezione.push(kJAccOverCP);\n}\n\n// Calcola kJ cumulativi per ogni punto\nconst kJ_sopraCP_cumulativi = [];\nlet kJ_overCP_sum = 0;\nfor (let i = 1; i < power.length; i++) {\n    const dt = time[i] - time[i-1];\n    if (dt < 30 && power[i] >= icu.activity.icu_ftp) kJ_overCP_sum += power[i] * dt / 1000;\n    kJ_sopraCP_cumulativi.push(kJ_overCP_sum);\n}\nconst kJ_cumulativi = [];\nlet kJ_sum = 0;\nfor (let i = 1; i < power.length; i++) {\n    const dt = time[i] - time[i-1];\n    if (dt < 30) kJ_sum += power[i] * dt / 1000;\n    kJ_cumulativi.push(kJ_sum);\n}\nconst firstNonZeroAltitude = altitude.find(value => value !== 0);\nif (firstNonZeroAltitude !== undefined) {\n    for (let i = 0; i < altitude.length; i++) {\n        if (altitude[i] === 0) altitude[i] = firstNonZeroAltitude;\n        else break;\n    }\n}\n\n// Traccia altitudine\n// --- DEFINIZIONE DEI TRACES DEL GRAFICO ---\n// Traccia altimetrica principale (altitudine vs tempo in movimento)\nconst data = [\n    {\n        x: movingTime,\n        y: altitude,\n        text: altitude.map((alt, i) => {\n            // Costruisce il testo di hover con tutti i dati principali\n            const timeSec = time[i] || 0;\n            const sec = Math.floor(timeSec % 60);\n            const min = Math.floor((timeSec / 60) % 60);\n            const hr = Math.floor(timeSec / 3600);\n            const tempo = `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n            // Moving time\n            const movingSec = movingTime[i] || 0;\n            const mSec = Math.floor(movingSec % 60);\n            const mMin = Math.floor((movingSec / 60) % 60);\n            const mHr = Math.floor(movingSec / 3600);\n            const movingTempo = `${mHr.toString().padStart(2, '0')}:${mMin.toString().padStart(2, '0')}:${mSec.toString().padStart(2, '0')}`;\n            const dist = fmt(distanceKm[i], 2);\n            // Watt medi sui 10 secondi precedenti\n            let watt10s = 0;\n            let nWatt = 0;\n            for (let j = Math.max(0, i-9); j <= i; j++) {\n                watt10s += power[j];\n                nWatt++;\n            }\n            watt10s = nWatt > 0 ? watt10s / nWatt : 0;\n            // Velocit media cumulativa fino a quel punto (distanza totale / tempo totale in movimento)\n            let velMedia = 0;\n            if (movingTime[i] > 0) velMedia = distanceKm[i] / (movingTime[i] / 3600);\n\n            const kJ_cum = i > 0 ? kJ_cumulativi[i-1] : 0;\n            const kJ_cum_overCP = i > 0 ? kJ_sopraCP_cumulativi[i-1] : 0;\n            let kJ_h_kg = 0, kJ_h_kg_overCP = 0;\n            if (CONFIG.pesoKg > 0 && time[i] > 0) {\n                const hours = time[i] / 3600;\n                kJ_h_kg = kJ_cum / hours / CONFIG.pesoKg;\n                kJ_h_kg_overCP = kJ_cum_overCP / hours / CONFIG.pesoKg;\n            }\n            return (\n                ` ${tempo} | ${movingTempo}` +\n                `<br>` +\n                ` ${dist} km |  ${fmt(watt10s,0)}W 10 ` +\n                `<br>` +\n                ` ${fmt(alt,0)} m |  ${fmt(velMedia,1)} km/h` +\n                `<br>` +\n                ` ${fmt(kJ_cum,0)} kJ | ${fmt(kJ_cum_overCP,0)} kJ > CP` +\n                `<br>` +\n                ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`\n            );\n        }),\n        hoverinfo: 'text',\n        fill: 'tozeroy',\n        type: 'scatter',\n        fillcolor: COLORI.RIEMPIMENTO_ALTITUDINE,\n        line: { color: COLORI.LINEA_ALTITUDINE, width: 2 },\n        mode: 'lines',\n        name: 'Altitudine',\n        yaxis: 'y1',\n        showlegend: false\n    },\n    // --- Barre kJ sopra CP per ogni sezione ---\n    {\n        x: kJOverCPPerSezione.map((_, i) => {\n            const prev = movingTime[sezioniIdx[i-1]||0];\n            return prev + (movingTime[sezioniIdx[i]] - prev) / 2;\n        }),\n        y: kJOverCPPerSezione,\n        type: 'bar',\n        name: 'kJ',\n        marker: { color: COLORI.BARRA_CP, opacity: COLORI.BARRA_CP_OPACITY },\n        yaxis: 'y2',\n        width: kJOverCPPerSezione.map((_, i) => {\n            const prev = movingTime[sezioniIdx[i-1]||0];\n            return (movingTime[sezioniIdx[i]] - prev);\n        }),\n        opacity: COLORI.BARRA_CP_OPACITY,\n        showlegend: false,\n        // Testo di hover: mostra kJ totali e watt medi della sezione\n        hovertemplate: kJOverCPPerSezione.map((v, i) => {\n            const startIdx = sezioniIdx[i-1]||0;\n            const endIdx = sezioniIdx[i];\n            let sommaW = 0, n = 0;\n            let kJTot = 0, kJTotOverCP = 0;\n            let durataSec = movingTime[endIdx] - movingTime[startIdx];\n            for (let j = startIdx; j < endIdx; j++) {\n                sommaW += power[j];\n                n++;\n                const dt = time[j] - time[j-1];\n                if (dt < 30) {\n                    kJTot += power[j] * dt / 1000;\n                    if (power[j] >= icu.activity.icu_ftp) kJTotOverCP += power[j] * dt / 1000;\n                }\n            }\n            const wMed = n > 0 ? Math.round(sommaW/n) : 0;\n            let kJ_h_kg = 0, kJ_h_kg_overCP = 0;\n            if (CONFIG.pesoKg > 0 && durataSec > 0) {\n                const hours = durataSec / 3600;\n                kJ_h_kg = kJTot / hours / CONFIG.pesoKg;\n                kJ_h_kg_overCP = kJTotOverCP / hours / CONFIG.pesoKg;\n            }\n            return (\n                ` ${Math.round(v)} kJ<br> ${wMed}W` +\n                `<br> ${kJ_h_kg.toFixed(1)} kJ/h/kg | ${kJ_h_kg_overCP.toFixed(1)} kJ/h/kg > CP<extra></extra>`\n            );\n        }),\n    }\n];\n\n// Evidenziature stile 3m MAP: aggiungi trace per ogni intervallo continuo sopra CP\nlet sopraCPTraces = [];\nlet inInterval = false;\nlet startIdx = 0;\nfor (let i = 0; i < power.length; i++) {\n    if (power[i] >= icu.activity.icu_ftp) {\n        if (!inInterval) {\n            inInterval = true;\n            startIdx = i;\n        }\n    } else {\n        if (inInterval) {\n            // Fine intervallo sopra CP\n            const x = movingTime.slice(startIdx, i);\n            const y = altitude.slice(startIdx, i);\n            sopraCPTraces.push({\n                x: x,\n                y: y,\n                type: 'scatter',\n                mode: 'lines',\n                line: { color: '#fa0710ff', width: 4 },\n                name: 'Sopra CP',\n                yaxis: 'y1',\n                showlegend: false,\n                hoverinfo: 'skip'\n            });\n            inInterval = false;\n        }\n    }\n}\nif (inInterval) {\n    const x = movingTime.slice(startIdx);\n    const y = altitude.slice(startIdx);\n    sopraCPTraces.push({\n        x: x,\n        y: y,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: '#fa0710ff', width: 4 },\n        name: 'Sopra CP',\n        yaxis: 'y1',\n        showlegend: false,\n        hoverinfo: 'skip'\n    });\n}\ndata.splice(1, 0, ...sopraCPTraces);\n\n// --- Nuove evidenziature per intervalli di potenza ---\n// Sforzi tra 80%-100% CP (giallo)\nlet tra80e100Traces = [];\nlet in80e100 = false;\nlet start80e100 = 0;\nconst min80 = icu.activity.icu_ftp * 0.8;\nfor (let i = 0; i < power.length; i++) {\n    if (power[i] >= min80 && power[i] < icu.activity.icu_ftp) {\n        if (!in80e100) {\n            in80e100 = true;\n            start80e100 = i;\n        }\n    } else {\n        if (in80e100) {\n            const x = movingTime.slice(start80e100, i);\n            const y = altitude.slice(start80e100, i);\n            tra80e100Traces.push({\n                x: x,\n                y: y,\n                type: 'scatter',\n                mode: 'lines',\n                line: { color: '#ffe600', width: 4 },\n                name: '80-100% CP',\n                yaxis: 'y1',\n                showlegend: false,\n                hoverinfo: 'skip'\n            });\n            in80e100 = false;\n        }\n    }\n}\nif (in80e100) {\n    const x = movingTime.slice(start80e100);\n    const y = altitude.slice(start80e100);\n    tra80e100Traces.push({\n        x: x,\n        y: y,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: '#ffe600', width: 4 },\n        name: '80-100% CP',\n        yaxis: 'y1',\n        showlegend: false,\n        hoverinfo: 'skip'\n    });\n}\n\n// Sforzi sotto 80% CP (verde)\nlet sotto80Traces = [];\nlet inSotto80 = false;\nlet startSotto80 = 0;\nfor (let i = 0; i < power.length; i++) {\n    if (power[i] >= 10 && power[i] < min80) {\n        if (!inSotto80) {\n            inSotto80 = true;\n            startSotto80 = i;\n        }\n    } else {\n        if (inSotto80) {\n            const x = movingTime.slice(startSotto80, i);\n            const y = altitude.slice(startSotto80, i);\n            sotto80Traces.push({\n                x: x,\n                y: y,\n                type: 'scatter',\n                mode: 'lines',\n                line: { color: '#24e04d', width: 4 },\n                name: '<80% CP',\n                yaxis: 'y1',\n                showlegend: false,\n                hoverinfo: 'skip'\n            });\n            inSotto80 = false;\n        }\n    }\n}\nif (inSotto80) {\n    const x = movingTime.slice(startSotto80);\n    const y = altitude.slice(startSotto80);\n    sotto80Traces.push({\n        x: x,\n        y: y,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: '#24e04d', width: 4 },\n        name: '<80% CP',\n        yaxis: 'y1',\n        showlegend: false,\n        hoverinfo: 'skip'\n    });\n}\n\n// Coasting (<10W, blu)\nlet coastingTraces = [];\nlet inCoasting = false;\nlet startCoasting = 0;\nfor (let i = 0; i < power.length; i++) {\n    if (power[i] < 10) {\n        if (!inCoasting) {\n            inCoasting = true;\n            startCoasting = i;\n        }\n    } else {\n        if (inCoasting) {\n            const x = movingTime.slice(startCoasting, i);\n            const y = altitude.slice(startCoasting, i);\n            coastingTraces.push({\n                x: x,\n                y: y,\n                type: 'scatter',\n                mode: 'lines',\n                line: { color: '#1100ffff', width: 4 },\n                name: 'Coasting',\n                yaxis: 'y1',\n                showlegend: false,\n                hoverinfo: 'skip'\n            });\n            inCoasting = false;\n        }\n    }\n}\nif (inCoasting) {\n    const x = movingTime.slice(startCoasting);\n    const y = altitude.slice(startCoasting);\n    coastingTraces.push({\n        x: x,\n        y: y,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: '#1100ffff', width: 4 },\n        name: 'Coasting',\n        yaxis: 'y1',\n        showlegend: false,\n        hoverinfo: 'skip'\n    });\n}\ndata.splice(1 + sopraCPTraces.length, 0, ...tra80e100Traces, ...sotto80Traces, ...coastingTraces);\n\n// Annotazioni sopra l'asse X con il valore kJ di ogni sezione\nconst kJTotaliPerSezione = sezioniIdx.map((idx, i) => {\n    const startIdx = sezioniIdx[i-1]||0;\n    let kJTot = 0;\n    for (let j = startIdx+1; j <= idx; j++) {\n        const dt = time[j] - time[j-1];\n        if (dt < 30) {\n            kJTot += power[j] * dt / 1000;\n        }\n    }\n    return kJTot;\n});\n\nlet sectionAnnotations = [];\nif (kJTotaliPerSezione.length > 0) {\n    const lastIdx = kJTotaliPerSezione.length - 1;\n    const prev = movingTime[sezioniIdx[lastIdx-1]||0];\n    const x = prev + (movingTime[sezioniIdx[lastIdx]] - prev) / 2;\n    sectionAnnotations.push({\n        x: x,\n        y: 0.98,\n        xref: 'x',\n        yref: 'paper',\n        text: `${fmt(kJTotaliPerSezione[lastIdx],0)} kJ`,\n        showarrow: false,\n        yanchor: 'top',\n        font: { color: '#24e04dff', size: 16, family: 'Arial', weight: 'bold' },\n        align: 'center',\n        yshift: 0\n    });\n}\nfor (let i = 0; i < kJOverCPPerSezione.length; i++) {\n    const prev = movingTime[sezioniIdx[i-1]||0];\n    const x = prev + (movingTime[sezioniIdx[i]] - prev) / 2;\n    const start = movingTime[sezioniIdx[i-1]||0];\n    const end = movingTime[sezioniIdx[i]];\n    const durataSec = end - start;\n    const min = Math.floor(durataSec / 60);\n    const sec = Math.round(durataSec % 60);\n    const percent = Math.round(kJOverCPPerSezione[i] / CONFIG.KJ_PER_SEZIONE * 100);\n    sectionAnnotations.push({\n        x: x,\n        y: 0,\n        xref: 'x',\n        yref: 'y2',\n        text: `${min}:${sec.toString().padStart(2,'0')}\n${percent}%`,\n        showarrow: false,\n        yanchor: 'bottom',\n        font: { color: '#000', size: 13, family: 'Arial Black', weight: 'bold' },\n        align: 'center',\n        yshift: 2\n    });\n}\n\nconst shapesVerticali = sezioniIdx.map(idx => ({\n    type: 'line',\n    xref: 'x',\n    yref: 'paper',\n    x0: movingTime[idx],\n    x1: movingTime[idx],\n    y0: 0,\n    y1: 1,\n    line: {\n        color: '#24e04dff', // verde\n        width: 1,\n        dash: 'solid'\n    }\n}));\n\nconst pauseAnnotations = [];\nfor (let i = 1; i < time.length; i++) {\n    const dt = time[i] - time[i - 1];\n    if (dt >= 300 && dt < 900) { // tra 5 e 15 minuti\n        pauseAnnotations.push({\n            x: movingTime[i],\n            y: altitude[i] + 70,\n            xref: 'x',\n            yref: 'y',\n            text: '',\n            showarrow: false,\n            font: { color: '#d80000', size: 15, family: 'Arial' },\n            yanchor: 'middle',\n            align: 'center',\n            yshift: 0\n        });\n    } else if (dt >= 900) { // sopra 15 minuti\n        pauseAnnotations.push({\n            x: movingTime[i],\n            y: altitude[i] + 70,\n            xref: 'x',\n            yref: 'y',\n            text: '',\n            showarrow: false,\n            font: { color: '#d80000', size: 15, family: 'Arial' },\n            yanchor: 'middle',\n            align: 'center',\n            yshift: 0\n        });\n    }\n}\n\nconst layout = {\n    ...BASE_LAYOUT,\n    title: `${CONFIG.KJ_KG_PER_SEZIONE} kJ*kg sections (${fmt(CONFIG.KJ_PER_SEZIONE,0)} kJ)`,\n    xaxis: {\n        title: 'Tempo in movimento (s)',\n        tickvals: (() => {\n            const vals = [];\n            for (let i = 0; i < distanceKm.length; i++) {\n                if (i === 0 || Math.floor(distanceKm[i] / 10) > Math.floor(distanceKm[i - 1] / 10)) {\n                    vals.push(movingTime[i]);\n                }\n            }\n            return vals;\n        })(),\n        ticktext: (() => {\n            const texts = [];\n            for (let i = 0; i < distanceKm.length; i++) {\n                if (i === 0 || Math.floor(distanceKm[i] / 10) > Math.floor(distanceKm[i - 1] / 10)) {\n                    texts.push(Math.round(distanceKm[i]) + ' km');\n                }\n            }\n            return texts;\n        })(),\n        hoverformat: '',\n    },\n    yaxis: {\n        title: 'Altitudine (m)',\n        range: [0, Math.max(...altitude, 1) * 1.05 + 50]\n    },\n    yaxis2: {\n        overlaying: 'y',\n        side: 'right',\n        showgrid: false,\n        zeroline: false,\n        visible: true,\n        title: 'kJ',\n        color: COLORI.BARRA_CP,\n        tickfont: { color: COLORI.BARRA_CP },\n        titlefont: { color: COLORI.BARRA_CP },\n        rangemode: 'tozero',\n        range: [0, CONFIG.KJ_PER_SEZIONE]\n    },\n    shapes: [...shapesVerticali],\n    annotations: [...sectionAnnotations, ...pauseAnnotations]\n};\n\nconst chart = { data: data, layout: layout };\nreturn chart;\n})();",
        "name": "kj*ks sections LITE"
      },
      "usage_count": 0,
      "index": 38,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-27T08:38:06.677+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 312255,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "HR+RPE AGATA",
      "description": "Max HR and Avg HR and RPE",
      "image": null,
      "content": {
        "id": "cug4ame8",
        "name": "HR+RPE AGATA",
        "plots": [
          {
            "id": 1,
            "agg": "none",
            "min": null,
            "vid": "273765.1",
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "Avg HR",
            "type": "dot",
            "field": "avg_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Avg heartrate",
            "extras": [
              {
                "id": 1,
                "y1": 0,
                "y2": 157,
                "fill": "#D627281A",
                "text": "Recovery",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.2
              },
              {
                "id": 2,
                "y1": 157,
                "y2": 175,
                "fill": "#D6272833",
                "text": "Aerobic",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.2
              },
              {
                "id": 3,
                "y1": 175,
                "y2": 183,
                "fill": "#D627284D",
                "text": "Tempo",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.2
              },
              {
                "id": 4,
                "y1": 184,
                "y2": 192,
                "fill": "#D6272866",
                "text": "Threshold",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.3
              },
              {
                "id": 5,
                "y1": 192,
                "y2": 197,
                "fill": "#D6272880",
                "text": "VO2Max",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.3
              },
              {
                "id": 6,
                "y1": 197,
                "y2": 211,
                "fill": "#D6272899",
                "text": "MAX",
                "type": "bar",
                "zone": 2,
                "labelX": "left",
                "labelY": "center",
                "stroke": "#000000FF",
                "opacity": 0.4
              }
            ],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(214,39,40)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Avg HR",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Avg heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": null,
            "vid": "273765.2",
            "band": 0,
            "fill": "rgba(214,39,40, 0.3)",
            "text": "AVG 42d",
            "type": "line",
            "field": "avg_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Avg heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#D6272873",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Avg HR",
            "markerValue": "right",
            "strokeWidth": 4,
            "i18nTitleKey": "Avg heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "vid": "273765.3",
            "band": 0,
            "fill": "#C728299C",
            "text": "Max HR",
            "type": "dot",
            "field": "max_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Max heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000FF",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Max HR",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Max heartrate",
            "showOnCalendar": false,
            "calendarOptions": {
              "day1": true,
              "day2": true,
              "day3": true,
              "day4": true,
              "day5": true,
              "day6": true,
              "day7": true,
              "label": "Max HR ",
              "units": " bpm",
              "weekPopupDay": 7,
              "weekSummaryDay": 7
            },
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "moving_avg",
            "min": null,
            "vid": "273765.4",
            "band": 0,
            "fill": "#A51A1B4A",
            "text": "MAX 42d",
            "type": "line",
            "field": "max_hr",
            "gauge": true,
            "scale": "bpm",
            "stack": "",
            "title": "Max heartrate",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#A31011FF",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "TrackRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Max HR",
            "markerValue": "right",
            "strokeWidth": 4,
            "i18nTitleKey": "Max heartrate",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Agata Chart",
        "height": 440,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "HR",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 1,
      "index": 39,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-07T11:45:20.752+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 658942,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "3s over 1000",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover1000",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 1000\nwindow = 3\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "3s over 1000"
      },
      "usage_count": 34,
      "index": 39,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T09:55:59.533+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 709448,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "2' efforts bar",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "250px",
        "script": "(function() {\n  const CONFIG = {\n    // CONFIGURAZIONE PRINCIPALE\n    // ============================================================================\n    DURATION: 120,                    // Durata finestra sforzo (secondi)\n    MIN_EFFORT_INTENSITY_FTP: 100,    // Soglia minima effort (% FTP)\n    // ============================================================================\n    // Ordinamento barre possibile su (valori stringa):\n    // 'avgPower', 'avgPowerPerKg', 'avgHR', 'maxHR', 'startTime', 'bestStart',\n    // 'dist', 'distKm', 'elevationGain', 'avgGrade', 'maxGrade',\n    // 'rat_1', 'rat_2', 'ratio', 'ascentSpeed', 'avgHorizontalSpeed',\n    // 'best5sWatts', 'best5sPerKg', 'TEORICWKG', 'TEORICVAM'\n    SORT_BY: 'avgPower',\n    BAR_TEXT_COLOR: '#000',                // Colore testo barre\n    BAR_TEXT_FONT: { family: 'Arial Black', size: 13 }, // Font testo barre\n    GRID_X_COLOR: '#eee',                  // Colore griglia X\n    GRID_X_WIDTH: 1,                       // Spessore griglia X\n    GRID_Y_COLOR: '#ccc',                  // Colore griglia Y\n    GRID_Y_WIDTH: 1,                       // Spessore griglia Y\n    VISIBLE_BARS: 7,                 // Numero barre visibili nel grafico\n\n    ZONES: [\n      { name: 'Z2', max: 76, color: '#4c72b0' },\n      { name: 'Z3', max: 91, color: '#55a868' },\n      { name: 'Z4', max: 106, color: '#dd8452' },\n      { name: 'Z5', max: 126, color: '#c44e52' },\n      { name: 'Z6', max: 151, color: '#a64d79' },\n      { name: 'Z7', max: Infinity, color: '#8172b3' }\n    ]\n  };\n// =====================\n// FINE CONFIGURAZIONE\n// =====================\n\n// =====================\n// LAYOUT GRAFICO\n// =====================\nconst LAYOUT = {\n  title: '',\n  barmode: 'group',\n  showlegend: false,\n  height: 250,\n  margin: {l: 40, r: 20, t: 40, b: 40},\n  xaxis: {\n    title: 'Effort',\n    range: [0, CONFIG.VISIBLE_BARS - 0.5],\n    fixedrange: false,\n    autorange: false,\n    tickmode: 'linear',\n    tick0: 1,\n    dtick: 1,\n    showgrid: true,\n    gridcolor: CONFIG.GRID_X_COLOR,\n    gridwidth: CONFIG.GRID_X_WIDTH,\n    scrollZoom: true\n  },\n  yaxis: {\n    title: 'Avg Power (W)',\n    dtick: 50,\n    gridcolor: CONFIG.GRID_Y_COLOR,\n    gridwidth: CONFIG.GRID_Y_WIDTH\n  }\n};\n\n// =====================\n// DATI ATTIVIT\n// =====================\nconst activity = icu.activity;\nconst weight = activity.icu_weight;\nconst FTP = activity.icu_ftp;\n\nfunction getStreamData(streamName) {\n  const stream = icu.streams.get(streamName);\n  return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n}\nconst power = getStreamData(\"fixed_watts\");\n\n// Trova tutti gli sforzi non sovrapposti sopra una certa soglia\nfunction getNonOverlappingEffortsAboveThreshold(data, n, threshold, samplingRate = 1) {\n  const windowSize = n * samplingRate;\n  let results = [];\n  if (data.length < windowSize) return results;\n  let sum = data.slice(0, windowSize).reduce((a, b) => a + b, 0);\n  let candidates = [];\n  if (sum / windowSize >= threshold) {\n    candidates.push({ avg: sum / windowSize, start: 0 });\n  }\n  for (let i = 1; i <= data.length - windowSize; i++) {\n    sum = sum - data[i - 1] + data[i + windowSize - 1];\n    const avg = sum / windowSize;\n    if (avg >= threshold) {\n      candidates.push({ avg, start: i });\n    }\n  }\n  candidates.sort((a, b) => b.avg - a.avg);\n  let used = Array(data.length).fill(false);\n  for (const cand of candidates) {\n    let overlap = false;\n    for (let j = cand.start; j < cand.start + windowSize; j++) {\n      if (used[j]) {\n        overlap = true;\n        break;\n      }\n    }\n    if (!overlap) {\n      results.push(cand);\n      for (let j = cand.start; j < cand.start + windowSize; j++) {\n        used[j] = true;\n      }\n    }\n  }\n  results.sort((a, b) => a.start - b.start);\n  return results;\n}\n\n\n\nlet x = [];\nlet y = [];\nlet hover = [];\nlet effortData = [];\nconst heartrate = getStreamData(\"fixed_heartrate\");\nconst time = getStreamData(\"time\");\nconst distance = getStreamData(\"distance\");\nconst altitude = getStreamData(\"fixed_altitude\");\nconst grade = getStreamData(\"grade_smooth\");\n\nfunction secondsToHms(seconds) {\n  seconds = Math.floor(seconds);\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds % 3600) / 60);\n  const s = seconds % 60;\n  let str = '';\n  if (h > 0) str += String(h).padStart(2, '0') + ':';\n  str += (h > 0 ? String(m).padStart(2, '0') : m) + ':' + String(s).padStart(2, '0');\n  return str;\n}\n\n// Soglia in watt (da percentuale FTP)\nconst threshold = (CONFIG.MIN_EFFORT_INTENSITY_FTP / 100) * FTP;\n\n\nconst allEfforts = getNonOverlappingEffortsAboveThreshold(\n  power,\n  CONFIG.DURATION,\n  threshold,\n  1\n);\nfor (const [idx, best] of allEfforts.entries()) {\n  const bestStart = best.start;\n  const bestEnd = bestStart + CONFIG.DURATION;\n  const sectionHR = heartrate.slice(bestStart, bestEnd);\n  const sectionDistance = distance.slice(bestStart, bestEnd);\n  const sectionAltitude = altitude.slice(bestStart, bestEnd);\n  const sectionGrade = grade.slice(bestStart, bestEnd);\n  const avgHR = sectionHR.reduce((a, b) => a + b, 0) / sectionHR.length;\n  const maxHR = Math.max(...sectionHR);\n  const startTime = secondsToHms(time[bestStart]);\n  const avgPower = best.avg;\n  const avgPowerPerKg = avgPower / weight;\n  const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n  const distKm = dist / 1000;\n  const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n  const avgGrade = dist > 0 ? (elevationGain / dist * 100) : 0;\n  const maxGrade = Math.max(...sectionGrade);\n  // Ratio: prima met, seconda met, ratio\n  const firstHalf = power.slice(bestStart, bestStart + CONFIG.DURATION/2);\n  const secondHalf = power.slice(bestStart + CONFIG.DURATION/2, bestEnd);\n  const rat_1 = firstHalf.reduce((a,b)=>a+b,0)/firstHalf.length;\n  const rat_2 = secondHalf.reduce((a,b)=>a+b,0)/secondHalf.length;\n  const ratio = rat_2 / rat_1;\n  // VAM\n  const climbTimeH = CONFIG.DURATION / 3600;\n  const ascentSpeed = elevationGain / climbTimeH;\n  const avgHorizontalSpeed = distKm / (CONFIG.DURATION / 3600);\n  // Best 5s\n  let best5sWatts = 0;\n  for (let i = 0; i <= power.slice(bestStart, bestEnd).length - 5; i++) {\n    const avg5 = power.slice(bestStart + i, bestStart + i + 5).reduce((a,b)=>a+b,0)/5;\n    if (avg5 > best5sWatts) best5sWatts = avg5;\n  }\n  const best5sPerKg = best5sWatts / weight;\n  // Teorici (come in PIAN HC)\n  const gradientFactor = (2 + avgGrade / 10) * 100;\n  const TEORICWKG = ascentSpeed / gradientFactor;\n  const TEORICVAM = avgPowerPerKg * gradientFactor;\n  effortData.push({\n    idx,\n    avgPower,\n    avgPowerPerKg,\n    avgHR,\n    maxHR,\n    startTime,\n    bestStart,\n    dist,\n    distKm,\n    elevationGain,\n    avgGrade,\n    maxGrade,\n    rat_1,\n    rat_2,\n    ratio,\n    ascentSpeed,\n    avgHorizontalSpeed,\n    best5sWatts,\n    best5sPerKg,\n    TEORICWKG,\n    TEORICVAM\n  });\n}\n\n// Ordina effort secondo la propriet scelta in config\neffortData.sort((a, b) => b[CONFIG.SORT_BY] - a[CONFIG.SORT_BY]);\nfor (const [i, effort] of effortData.entries()) {\n  x.push(`${i+1}`);\n  y.push(effort.avgPower);\n  hover.push(\n    ` ${(effort.dist / 1000).toFixed(2)} km (${effort.elevationGain.toFixed(0)} m)<br>`+\n    `  ${effort.avgGrade.toFixed(1)}% | max. ${effort.maxGrade.toFixed(1)}%<br>`+\n    ` ${effort.avgPower.toFixed(0)} W | 5 ${effort.best5sWatts.toFixed(0)} W<br>`+\n    ` ${effort.avgPowerPerKg.toFixed(2)} W/kg | 5 ${effort.best5sPerKg.toFixed(2)} W/kg<br>`+\n    ` ${effort.rat_1.toFixed(0)} W | ${effort.rat_2.toFixed(0)} W | ${(effort.ratio).toFixed(2)}<br>`+\n    `  ${effort.avgHR.toFixed(0)} bpm | max. ${effort.maxHR} bpm<br>`+\n    ` ${effort.avgHorizontalSpeed.toFixed(1)} km/h |  ${effort.ascentSpeed.toFixed(0)} m/h<br>`+\n    ` ${effort.startTime}`\n  );\n}\n\n\n\n// Restituisce il colore HEX della zona in base alla % FTP, usando la config\nfunction getZoneColor(avgPower, ftp) {\n  const percentage = (avgPower / ftp) * 100;\n  for (const zone of CONFIG.ZONES) {\n    if (percentage < zone.max) return zone.color;\n  }\n  // fallback (non dovrebbe mai servire)\n  return '#000';\n}\n\nconst barColors = y.map((v) => getZoneColor(v, FTP));\n\n\nconst data = [\n  {\n    x: x,\n    y: y,\n    type: 'bar',\n    marker: {\n      color: barColors\n    },\n    text: x.map((label, i) =>\n      `${y[i].toFixed(0)} W | ${effortData[i].avgPowerPerKg.toFixed(2)} W/kg<br>`\n      + `${effortData[i].rat_1.toFixed(0)} W | ${effortData[i].rat_2.toFixed(0)} W | ${effortData[i].ratio.toFixed(2)}<br>`\n      + ` ${effortData[i].avgHR.toFixed(0)} bpm | ${effortData[i].maxHR} bpm<br>`\n      + `${effortData[i].ascentSpeed.toFixed(0)} m/h |  ${effortData[i].avgGrade.toFixed(1)}%<br>`\n      + `${effortData[i].startTime}`\n    ),\n    textposition: 'inside',\n    insidetextanchor: 'start',\n    textfont: {\n      color: CONFIG.BAR_TEXT_COLOR,\n      size: CONFIG.BAR_TEXT_FONT.size,\n      family: CONFIG.BAR_TEXT_FONT.family\n    },\n    hoverinfo: 'text',\n    hovertext: hover,\n    hoverlabel: { font: { color: CONFIG.BAR_TEXT_COLOR, family: CONFIG.BAR_TEXT_FONT.family, size: CONFIG.BAR_TEXT_FONT.size }, align: 'left' },\n    name: 'Avg Power',\n    visible: true\n  }\n];\n\n\n\n// Aggiorna dinamicamente titolo e range xaxis in base alla config\nconst minEffort = CONFIG.MIN_EFFORT_INTENSITY_FTP;\nconst duration = CONFIG.DURATION;\nconst durationMin = duration % 60 === 0 ? (duration/60) + '' : duration + 's';\nLAYOUT.title = `${durationMin} efforts (>${minEffort}% FTP)`;\nLAYOUT.xaxis.range = [0, CONFIG.VISIBLE_BARS - 0.5];\n\nreturn { data: data, layout: LAYOUT };\n})();",
        "name": "2' efforts bar"
      },
      "usage_count": 0,
      "index": 39,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-23T06:05:13.266+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 719580,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "prototipo",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 100; // Soglia minima intensit (% FTP)\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n\n    // Limatura/estensione\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura/estensione (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura/estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Filtra solo effort sopra la soglia percentuale di FTP\n    let efforts = mergeConsecutiveWindows(power, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT)\n        .filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n\n    // Limatura inizio/fine effort con finestre da 15s\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n    // Limatura e prima estensione in testa (solo una volta, poi il ciclo iterativo fa il resto)\n    efforts = efforts.map(eff => {\n        let { start, end } = trimEffort(power, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        // Estensione in testa\n        let changed = true;\n        while (changed) {\n            changed = false;\n            if (start - TRIM_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - TRIM_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (TRIM_LOW_PERCENT / 100) * currAvg) {\n                    start -= TRIM_WINDOW_SECONDS;\n                    changed = true;\n                }\n            }\n        }\n        const trimmedPower = power.slice(start, end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start, end, avg: trimmedAvg };\n    });\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    function mergeEffortsPostTrim(efforts, power, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = power.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, power, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - TRIM_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - TRIM_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (TRIM_LOW_PERCENT / 100) * currAvg) {\n                    start -= TRIM_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + TRIM_WINDOW_SECONDS <= power.length) {\n                const extWin = power.slice(end, end + TRIM_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (TRIM_LOW_PERCENT / 100) * currAvg) {\n                    end += TRIM_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione\n        const trimmed = trimEffort(power, start, end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, power) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = power.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, power);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map(alt => `${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Elevation'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n    sortedEfforts.forEach((eff, idx) => {\n        const sectionPower = power.slice(eff.start, eff.end);\n        const sectionAltitude = altitude.slice(eff.start, eff.end);\n        const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n        const sectionTime = time.slice(eff.start, eff.end);\n        const avgPower = eff.avg;\n        const bgColor = getZoneColor(avgPower, FTP);\n        // Calcolo metriche aggiuntive come nel vecchio script\n        const sectionHR = heartrate.slice(eff.start, eff.end);\n        const sectionGrade = grade.slice(eff.start, eff.end);\n        const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n        const dist = distance.slice(eff.start, eff.end);\n        const distTot = dist[dist.length - 1] - dist[0];\n        const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n        // ...existing code...\n        const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n        const vam = elevationGain / (climbTimeInSeconds / 3600);\n        const avgGrade = elevationGain / distTot * 100;\n        const gradientFactor = 2 + (avgGrade / 10);\n        const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n        let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n        if (sectionPower.length) {\n            const half = Math.floor(sectionPower.length / 2);\n            avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n            avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n            wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n        }\n        const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n        const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n        const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n        const startTime = sectionTime.length ? sectionTime[0] : '';\n        let best5sWatt = '', best5sWattKg = '';\n        let avgPowerPerKg = 0;\n        if (sectionPower.length >= 5 && weight > 0) {\n            const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n            best5sWatt = Math.round(maxW);\n            best5sWattKg = fmt(maxW / weight, 2);\n            avgPowerPerKg = avgPower / weight;\n        }\n        let joules = 0, joulesOverCP = 0;\n        if (power && time && eff.start !== undefined && eff.start < power.length && FTP) {\n            for (let i = 0; i < eff.start; i++) {\n                const w = power[i];\n                const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n                if (secs < 30) {\n                    joules += w * secs;\n                    if (w >= FTP) joulesOverCP += w * secs;\n                }\n            }\n        }\n        const hours = (time && eff.start !== undefined && time[eff.start]) ? (time[eff.start] / 3600) : 0;\n        const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n        const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n        function formatSecondsToHHMMSS(seconds) {\n            const sec = Math.floor(seconds % 60);\n            const min = Math.floor((seconds / 60) % 60);\n            const hr = Math.floor(seconds / 3600);\n            return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n        }\n        const effortDurationSec = climbTimeInSeconds;\n        // Format mm:ss\n        function formatMMSS(seconds) {\n            const min = Math.floor(seconds / 60);\n            const sec = Math.floor(seconds % 60);\n            return `${min}:${sec.toString().padStart(2, '0')}`;\n        }\n        const traceText = [\n            (() => {\n                const sectionCadence = getStreamData(\"cadence\").slice(eff.start, eff.end);\n                const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n                return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n            })(),\n            (() => {\n                const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n                return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''}`;\n            })(),\n            ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n            ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n            ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n            ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n            (() => {\n                if (avgGrade >= 4.5) {\n                    const diffVAM = Math.abs(vamTeorico - vam);\n                    let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                    const wkgteoric = vam / (gradientFactor * 100);\n                    const diffWkg = avgPowerPerKg - wkgteoric;\n                    return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n                } else {\n                    return ` ${fmt(vam,0)} m/h`;\n                }\n            })(),\n            (() => {\n                if (avgGrade >= 4.5) {\n                    const wkgteoric = vam / (gradientFactor * 100);\n                    const diffWkg = avgPowerPerKg - wkgteoric;\n                    const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                    const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                    return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n                } else {\n                    return '';\n                }\n            })(),\n            ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n            ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n        ].filter(Boolean).join('<br>');\n        traces.push({\n            x: sectionDistanceKm,\n            y: sectionAltitude,\n            type: 'scatter',\n            mode: 'lines',\n            line: { color: bgColor, width: 2 },\n            name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n            hoverinfo: 'text',\n            visible: true,\n            hoverlabel: { align: 'left' },\n            text: traceText\n        });\n        annotations.push({\n            x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n            y: Math.max(...sectionAltitude) + 50 + eff.originalIdx * 25,\n            text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n            showarrow: false,\n            font: { family: 'Arial', size: 12, color: 'white' },\n            align: 'center',\n            bgcolor: bgColor,\n            opacity: 0.9\n        });\n    });\n\n    // Titolo compatto con tutte le variabili di configurazione\n    const configTitle = `EFFORTS | MRG:${MERGE_POWER_DIFF_PERCENT}% WIN:${WINDOW_SECONDS}s MIN:${MIN_EFFORT_INTENSITY_FTP}%FTP | TRIM:${TRIM_WINDOW_SECONDS}s LIM:${TRIM_LOW_PERCENT}%`;\n    const layout = {\n        title: configTitle,\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "prototipo"
      },
      "usage_count": 0,
      "index": 40,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-06T15:19:16.874+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 743956,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "VAM PEAKS",
      "description": null,
      "image": null,
      "content": {
        "id": "lyzvsztq",
        "name": "VAM PEAKS",
        "plots": [
          {
            "id": 1,
            "agg": "max_days",
            "min": 0,
            "band": 0,
            "fill": "#33333380",
            "text": "VAM 2'",
            "type": "line",
            "field": "af_VAM2",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM2",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#ffb000ff",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743949,
              "name": "VAM 2'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 82,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM2",
                "icon": null,
                "link": null,
                "name": "VAM 2'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 2 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T16:59:58.916+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1.3,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "max_days",
            "min": 0,
            "band": 0,
            "fill": "#33333380",
            "text": "VAM 3'",
            "type": "line",
            "field": "af_VAM3",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM3",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#ff7f0eff",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743950,
              "name": "VAM 3'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 83,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM3",
                "icon": null,
                "link": null,
                "name": "VAM 3'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 3 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:00:13.701+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1.3,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "max_days",
            "min": 0,
            "band": 0,
            "fill": "#33333380",
            "text": "VAM 5'",
            "type": "line",
            "field": "af_VAM5",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM5",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#334cccff",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743951,
              "name": "VAM 5'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 84,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM5",
                "icon": null,
                "link": null,
                "name": "VAM 5'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 5 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:01:13.600+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1.3,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "max_days",
            "min": 0,
            "band": 0,
            "fill": "#33333380",
            "text": "VAM 10'",
            "type": "line",
            "field": "af_VAM10",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM10",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#009e00ff",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743952,
              "name": "VAM 10'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 85,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM10",
                "icon": null,
                "link": null,
                "name": "VAM 10'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 10 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:02:31.893+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1.3,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "max_days",
            "min": 0,
            "band": 0,
            "fill": "#33333380",
            "text": "VAM 20'",
            "type": "line",
            "field": "af_VAM20",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM20",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#dd04a7ff",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743953,
              "name": "VAM 20'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 86,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM20",
                "icon": null,
                "link": null,
                "name": "VAM 20'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 20 * 20; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:02:40.824+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1.3,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "max_days",
            "min": 0,
            "band": 0,
            "fill": "#33333380",
            "text": "VAM 40'",
            "type": "line",
            "field": "af_VAM40",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM40",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#00c9ffff",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743954,
              "name": "VAM 40'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 87,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM40",
                "icon": null,
                "link": null,
                "name": "VAM 40'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 40 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:01:50.773+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1.3,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 7,
            "agg": "max_days",
            "min": 0,
            "band": 0,
            "fill": "#33333380",
            "text": "VAM 60'",
            "type": "line",
            "field": "af_VAM60",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM60",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#8d8247ff",
            "aggArgs": {
              "days": 42
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743955,
              "name": "VAM 60'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 88,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM60",
                "icon": null,
                "link": null,
                "name": "VAM 60'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 60 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:02:09.032+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1.3,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 8,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#ffb000ff",
            "text": "VAM 2'",
            "type": "dot",
            "field": "af_VAM2",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM2",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743949,
              "name": "VAM 2'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 82,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM2",
                "icon": null,
                "link": null,
                "name": "VAM 2'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 2 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T16:59:58.916+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "none",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 9,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#ff7f0eff",
            "text": "VAM 3'",
            "type": "dot",
            "field": "af_VAM3",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM3",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743950,
              "name": "VAM 3'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 83,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM3",
                "icon": null,
                "link": null,
                "name": "VAM 3'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 3 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:00:13.701+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "none",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 10,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#334cccff",
            "text": "VAM 5'",
            "type": "dot",
            "field": "af_VAM5",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM5",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743951,
              "name": "VAM 5'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 84,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM5",
                "icon": null,
                "link": null,
                "name": "VAM 5'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 5 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:01:13.600+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "none",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 11,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#009e00ff",
            "text": "VAM 10'",
            "type": "dot",
            "field": "af_VAM10",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM10",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743952,
              "name": "VAM 10'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 85,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM10",
                "icon": null,
                "link": null,
                "name": "VAM 10'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 10 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:02:31.893+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "none",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 12,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#dd04a7ff",
            "text": "VAM 20'",
            "type": "dot",
            "field": "af_VAM20",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM20",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743953,
              "name": "VAM 20'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 86,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM20",
                "icon": null,
                "link": null,
                "name": "VAM 20'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 20 * 20; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:02:40.824+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "none",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 13,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#00c9ffff",
            "text": "VAM 40'",
            "type": "dot",
            "field": "af_VAM40",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM40",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743954,
              "name": "VAM 40'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 87,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM40",
                "icon": null,
                "link": null,
                "name": "VAM 40'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 40 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:01:50.773+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "none",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 14,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#8d8247ff",
            "text": "VAM 60'",
            "type": "dot",
            "field": "af_VAM60",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "VAM60",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 743955,
              "name": "VAM 60'",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 88,
              "content": {
                "max": null,
                "min": null,
                "code": "VAM60",
                "icon": null,
                "link": null,
                "name": "VAM 60'",
                "type": "numeric",
                "color": "#333333",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": true,
                "prefix": null,
                "script": "{\nconst stream = icu.streams;\nconst interval = 60 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
                "suffix": null,
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "SUM",
                "text_wrap": "no",
                "pace_units": null,
                "text_align": "center",
                "number_format": ".0f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": null,
              "updated": "2025-08-28T17:02:09.032+00:00",
              "athlete_id": "i115436",
              "visibility": "PRIVATE",
              "description": null,
              "hide_script": false,
              "usage_count": 0,
              "from_athlete": {
                "id": null,
                "bio": null,
                "sex": null,
                "city": null,
                "name": null,
                "email": null,
                "state": null,
                "country": null,
                "website": null,
                "timezone": null,
                "profile_medium": "/no-profile-pic.png"
              },
              "hidden_by_id": null
            },
            "markerValue": "none",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 385,
        "yAxisMax": null,
        "yAxisMin": 800.0,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "VAM",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 40,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-28T19:02:48.483+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 273784,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "eFTP & W' Trend",
      "description": null,
      "image": null,
      "content": {
        "id": "u3rti7ck",
        "name": "eFTP & W' Trend",
        "plots": [
          {
            "id": 1,
            "agg": "max_days",
            "min": null,
            "band": 0,
            "fill": "#dd044780",
            "text": "eFTP/kg",
            "type": "line",
            "field": "eftp_kg",
            "gauge": true,
            "scale": "watts_kg",
            "stack": "",
            "title": "Estimated FTP/kg",
            "extras": [],
            "filter": "dec2_always",
            "radius": 3,
            "stroke": "#dd0447ff",
            "aggArgs": {
              "days": 7
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "eFTP/kg",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Estimated FTP/kg",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "moving_avg",
            "min": null,
            "band": 0,
            "fill": "#8d82474a",
            "text": "Weight",
            "type": "bars",
            "field": "weight",
            "gauge": true,
            "scale": "weight",
            "stack": "",
            "title": "Fatness",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#8d8247",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Weight",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Fatness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "moving_avg",
            "min": null,
            "band": 0,
            "fill": "#334ccc66",
            "text": "Efficiency",
            "type": "line",
            "field": "efficiency",
            "gauge": true,
            "scale": "efficiency",
            "stack": "",
            "title": "Normalized watts / HR",
            "extras": [],
            "filter": "dec2",
            "radius": 3,
            "stroke": "#334ccc91",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              },
              {
                "id": 2,
                "value": 600,
                "field_id": "moving_time",
                "operator": ">"
              }
            ],
            "i18nKey": "Efficiency",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Normalized watts / HR",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "fill_in",
            "min": null,
            "band": 0,
            "fill": "#6633CC4D",
            "text": "eFTP",
            "type": "line",
            "field": "eftp",
            "scale": "watts",
            "stack": "",
            "title": "Estimated FTP",
            "extras": [],
            "filter": "watts0",
            "radius": 3,
            "stroke": "#6633CCFF",
            "filters": [],
            "i18nKey": "eFTP",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "Estimated FTP",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 7,
            "agg": "fill_in",
            "min": null,
            "band": 0,
            "fill": "#8d824780",
            "text": "Weight",
            "type": "dot",
            "field": "weight",
            "gauge": true,
            "scale": "weight",
            "stack": "",
            "title": "Fatness",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#8D82474A",
            "filters": [],
            "i18nKey": "Weight",
            "markerValue": "none",
            "strokeWidth": 1,
            "i18nTitleKey": "Fatness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 8,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "rgba(0,158,0, 0.4)",
            "text": "Feel",
            "type": "dot",
            "field": "feel",
            "gauge": true,
            "scale": "feel",
            "stack": "",
            "title": "How did you feel?",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(0,158,0)",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Feel",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "feel",
            "showOnCalendar": false,
            "invertSubWellness": true
          },
          {
            "id": 9,
            "agg": "moving_avg",
            "min": null,
            "band": 0.3,
            "fill": "#8D824740",
            "text": "Weight",
            "type": "dot",
            "field": "weight",
            "gauge": true,
            "scale": "weight",
            "stack": "",
            "title": "Fatness",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#8D824700",
            "aggArgs": {
              "days": 31,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "Weight",
            "markerValue": "none",
            "strokeWidth": 0.1,
            "i18nTitleKey": "Fatness",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 10,
            "agg": "moving_avg",
            "min": 0,
            "band": 0,
            "fill": "#DD04A74D",
            "text": "W'",
            "type": "line",
            "field": "w_prime",
            "gauge": true,
            "scale": "kJ",
            "stack": "",
            "title": "W' (anaerobic work capacity)",
            "extras": [],
            "filter": "kJ_suffix",
            "radius": 3,
            "stroke": "#2CA02CFF",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "Run",
                  "TrailRun",
                  "Swim",
                  "VirtualRun"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "W'",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "W (anaerobic work capacity)",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 11,
            "agg": "max_days",
            "min": 0,
            "band": 0,
            "fill": "#FF00FFFF",
            "text": "W'bal ",
            "type": "line",
            "field": "max_wbal_depletion",
            "scale": "kJ",
            "stack": "",
            "title": "Max W'bal depletion",
            "extras": [],
            "filter": "kJ_suffix",
            "radius": 3,
            "stroke": "#FF00FFFF",
            "aggArgs": {
              "days": 14
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide",
                  "Run",
                  "TrailRun",
                  "Swim",
                  "VirtualRun"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Wbal ",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Max Wbal depletion",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": null,
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 1,
      "index": 41,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-09-02T12:24:12.990+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 719790,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "prot2",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 90; // Soglia minima intensit (% FTP)\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n\n    // Limatura\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura (% della media effort)\n    // Estensione\n    const EXTEND_WINDOW_SECONDS = 15;    // Finestra estensione (s)\n    const EXTEND_LOW_PERCENT = 80;       // Soglia estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Limatura inizio/fine effort con finestre da TRIM_WINDOW_SECONDS\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n\n    // 1. Crea finestre fisse\n    let efforts = mergeConsecutiveWindows(power, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT);\n\n    // 2. Applica limatura PRIMA del merge (con parametri limatura)\n    efforts = efforts.map(eff => {\n        const trimmed = trimEffort(power, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    // 3. Filtra solo effort sopra la soglia percentuale di FTP\n    efforts = efforts.filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    // (estensione con parametri estensione)\n    function mergeEffortsPostTrim(efforts, power, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = power.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, power, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda (con parametri estensione)\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - EXTEND_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - EXTEND_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    start -= EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + EXTEND_WINDOW_SECONDS <= power.length) {\n                const extWin = power.slice(end, end + EXTEND_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    end += EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione (con parametri limatura)\n        // Calcola la media aggiornata dopo l'estensione\n        const updatedPower = power.slice(start, end);\n        const updatedAvg = updatedPower.reduce((a,b)=>a+b,0) / (updatedPower.length || 1);\n        const trimmed = trimEffort(power, start, end, updatedAvg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, power) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = power.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, power);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map((alt, i) => ` ${fmt(distanceKm[i],2)} km<br> ${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Altitudine'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n// Curve ordinate per potenza (sortedEfforts)\nsortedEfforts.forEach((eff, idx) => {\n    const sectionPower = power.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionTime = time.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    // Calcolo metriche aggiuntive come nel vecchio script\n    const sectionHR = heartrate.slice(eff.start, eff.end);\n    const sectionGrade = grade.slice(eff.start, eff.end);\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const dist = distance.slice(eff.start, eff.end);\n    const distTot = dist[dist.length - 1] - dist[0];\n    const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n    const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n    const vam = elevationGain / (climbTimeInSeconds / 3600);\n    const avgGrade = elevationGain / distTot * 100;\n    const gradientFactor = 2 + (avgGrade / 10);\n    const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n    let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n    if (sectionPower.length) {\n        const half = Math.floor(sectionPower.length / 2);\n        avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n        avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n        wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n    }\n    const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n    const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n    const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n    const startTime = sectionTime.length ? sectionTime[0] : '';\n    let best5sWatt = '', best5sWattKg = '';\n    let avgPowerPerKg = 0;\n    if (sectionPower.length >= 5 && weight > 0) {\n        const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n        best5sWatt = Math.round(maxW);\n        best5sWattKg = fmt(maxW / weight, 2);\n        avgPowerPerKg = avgPower / weight;\n    }\n    let joules = 0, joulesOverCP = 0;\n    if (power && time && eff.start !== undefined && eff.start < power.length && FTP) {\n        for (let i = 0; i < eff.start; i++) {\n            const w = power[i];\n            const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n            if (secs < 30) {\n                joules += w * secs;\n                if (w >= FTP) joulesOverCP += w * secs;\n            }\n        }\n    }\n    const hours = (time && eff.start !== undefined && time[eff.start]) ? (time[eff.start] / 3600) : 0;\n    const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n    const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n    function formatSecondsToHHMMSS(seconds) {\n        const sec = Math.floor(seconds % 60);\n        const min = Math.floor((seconds / 60) % 60);\n        const hr = Math.floor(seconds / 3600);\n        return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n    }\n    const effortDurationSec = climbTimeInSeconds;\n    function formatMMSS(seconds) {\n        const min = Math.floor(seconds / 60);\n        const sec = Math.floor(seconds % 60);\n        return `${min}:${sec.toString().padStart(2, '0')}`;\n    }\n    const traceText = [\n        (() => {\n            const sectionCadence = getStreamData(\"cadence\").slice(eff.start, eff.end);\n            const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n            return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n        })(),\n        (() => {\n            const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n            const percFTP = FTP ? ((avgPower / FTP) * 100) : 0;\n            return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''} | ${fmt(percFTP,0)}%`;\n        })(),\n        ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n        ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n        ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n        ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n        (() => {\n            if (avgGrade >= 4.5) {\n                const diffVAM = Math.abs(vamTeorico - vam);\n                let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n            } else {\n                return ` ${fmt(vam,0)} m/h`;\n            }\n        })(),\n        (() => {\n            if (avgGrade >= 4.5) {\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n            } else {\n                return '';\n            }\n        })(),\n        ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n        ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n    ].filter(Boolean).join('<br>');\n    traces.push({\n        x: sectionDistanceKm,\n        y: sectionAltitude,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n        hoverinfo: 'text',\n        visible: true,\n        hoverlabel: { align: 'left' },\n        text: traceText\n    });\n});\n\n// Annotazioni alternate sopra/sotto secondo ordine temporale\nconst globalMaxAlt = Math.max(...altitude);\nconst globalMinAlt = Math.min(...altitude);\neffortsWithIndex.forEach((eff, idx) => {\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    const effortDurationSec = time[eff.end - 1] - time[eff.start] + 1;\n    // Tutte le annotazioni sopra la trace locale, offset fisso\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const yAnn = Math.max(...sectionAltitude) + 60;\n    annotations.push({\n        x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n        y: yAnn,\n        text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n        showarrow: false,\n        font: { family: 'Arial', size: 12, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        opacity: 0.9\n    });\n});\n\n    const configTitle =\n`<b>EFFORT</b> <b>|</b> ` +\n`<span style='color:#000000ff'>MRG [${MERGE_POWER_DIFF_PERCENT}%]</span> ` +\n`<span style='color:#000000ff'>WIN [${WINDOW_SECONDS}s]</span> ` +\n`<span style='color:#000000ff'>MIN [${MIN_EFFORT_INTENSITY_FTP}%FTP]</span> <b>|</b> ` +\n`<span style='color:#ff0000'>TRIM [${TRIM_WINDOW_SECONDS}s, ${TRIM_LOW_PERCENT}%]</span> ` +\n`<span style='color:#1901f5ff'> [${EXTEND_WINDOW_SECONDS}s, ${EXTEND_LOW_PERCENT}%]</span>`;\n    const layout = {\n        title: { text: configTitle, font: { color: '#222', size: 18 }, },\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "prot2"
      },
      "usage_count": 0,
      "index": 41,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-11T14:21:07.452+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 510008,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Monthly Volume",
      "description": "Work kJ + above FTP + chronic intensity load",
      "image": null,
      "content": {
        "id": "fcjsgtvx",
        "name": "Monthly Volume",
        "plots": [
          {
            "id": 1,
            "agg": "month_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(102,51,204,0.3)",
            "text": "Work",
            "type": "bars",
            "color": "rgb(102,51,204)",
            "field": "work",
            "scale": "kJ",
            "title": "Total work",
            "extras": [],
            "filter": "round0",
            "radius": 3,
            "stroke": "rgb(102,51,204)",
            "filters": [],
            "markerValue": "right",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "month_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(255,127,14,0.4)",
            "text": "kJ>FTP",
            "type": "bars",
            "color": "rgb(255,127,14)",
            "field": "kj_above_ftp",
            "scale": "kJ",
            "title": "Work above FTP",
            "extras": [],
            "filter": "round0",
            "radius": 3,
            "stroke": "rgb(255,127,14)",
            "filters": [],
            "markerValue": "right",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "month_tot",
            "min": 0,
            "band": 0,
            "fill": "#2ca02c66",
            "text": "Moving",
            "type": "line",
            "field": "moving_time",
            "scale": "hours",
            "stack": "moving_time",
            "title": "Moving time",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Moving",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Moving time",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "month_avg",
            "min": 0,
            "band": 0,
            "fill": "#037E6580",
            "text": "kJ/h",
            "type": "line",
            "field": "af_WorkHour",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "WorkHour",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#037E65",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 396110,
              "name": "kJ/h",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 11,
              "content": {
                "max": null,
                "min": null,
                "code": "WorkHour",
                "icon": "mdi-battery-70",
                "link": null,
                "name": "kJ/h",
                "type": "numeric",
                "color": "#037E65",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": false,
                "prefix": null,
                "script": "(activity.icu_joules/1000)/(activity. moving_time/3600)",
                "suffix": " kJ/h",
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "AVERAGE",
                "pace_units": null,
                "number_format": ".1f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": 127973,
              "updated": "2024-10-17T14:09:41.445+00:00",
              "athlete_id": "i115436",
              "visibility": "FOLLOWERS",
              "description": "Total work per moving_time",
              "hide_script": false,
              "usage_count": 41,
              "from_athlete": {
                "id": "i62859",
                "bio": null,
                "sex": "M",
                "city": "Paterna",
                "name": "OSCAR MARTINEZ",
                "email": null,
                "state": "Valencia",
                "country": "Spain",
                "website": null,
                "timezone": "Europe/Madrid",
                "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c295a232-660c-4a1c-abdb-a7ff5be4aaac"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1,
            "invertSubWellness": false
          }
        ],
        "title": "Monthly Volume",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "kJ",
        "y2AxisLabel": "h",
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 42,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2026-01-15T17:28:54.355+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 721804,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "PROTOTYPE24",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 90; // Soglia minima intensit (% FTP)\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n\n    // Limatura\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura (% della media effort)\n    // Estensione\n    const EXTEND_WINDOW_SECONDS = 15;    // Finestra estensione (s)\n    const EXTEND_LOW_PERCENT = 80;       // Soglia estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Limatura inizio/fine effort con finestre da TRIM_WINDOW_SECONDS\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n\n    // 1. Crea finestre fisse\n    let efforts = mergeConsecutiveWindows(power, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT);\n\n    // 2. Applica limatura PRIMA del merge (con parametri limatura)\n    efforts = efforts.map(eff => {\n        const trimmed = trimEffort(power, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    // 3. Filtra solo effort sopra la soglia percentuale di FTP\n    efforts = efforts.filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    // (estensione con parametri estensione)\n    function mergeEffortsPostTrim(efforts, power, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = power.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, power, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda (con parametri estensione)\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - EXTEND_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - EXTEND_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    start -= EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + EXTEND_WINDOW_SECONDS <= power.length) {\n                const extWin = power.slice(end, end + EXTEND_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    end += EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione (con parametri limatura)\n        // Calcola la media aggiornata dopo l'estensione\n        const updatedPower = power.slice(start, end);\n        const updatedAvg = updatedPower.reduce((a,b)=>a+b,0) / (updatedPower.length || 1);\n        const trimmed = trimEffort(power, start, end, updatedAvg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, power) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = power.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, power);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map((alt, i) => ` ${fmt(distanceKm[i],2)} km<br> ${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Altitudine'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n// Curve ordinate per potenza (sortedEfforts)\nsortedEfforts.forEach((eff, idx) => {\n    const sectionPower = power.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionTime = time.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    // Calcolo metriche aggiuntive come nel vecchio script\n    const sectionHR = heartrate.slice(eff.start, eff.end);\n    const sectionGrade = grade.slice(eff.start, eff.end);\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const dist = distance.slice(eff.start, eff.end);\n    const distTot = dist[dist.length - 1] - dist[0];\n    const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n    const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n    const vam = elevationGain / (climbTimeInSeconds / 3600);\n    const avgGrade = elevationGain / distTot * 100;\n    const gradientFactor = 2 + (avgGrade / 10);\n    const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n    let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n    if (sectionPower.length) {\n        const half = Math.floor(sectionPower.length / 2);\n        avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n        avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n        wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n    }\n    const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n    const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n    const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n    const startTime = sectionTime.length ? sectionTime[0] : '';\n    let best5sWatt = '', best5sWattKg = '';\n    let avgPowerPerKg = 0;\n    if (sectionPower.length >= 5 && weight > 0) {\n        const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n        best5sWatt = Math.round(maxW);\n        best5sWattKg = fmt(maxW / weight, 2);\n        avgPowerPerKg = avgPower / weight;\n    }\n    let joules = 0, joulesOverCP = 0;\n    if (power && time && eff.start !== undefined && eff.start < power.length && FTP) {\n        for (let i = 0; i < eff.start; i++) {\n            const w = power[i];\n            const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n            if (secs < 30) {\n                joules += w * secs;\n                if (w >= FTP) joulesOverCP += w * secs;\n            }\n        }\n    }\n    const hours = (time && eff.start !== undefined && time[eff.start]) ? (time[eff.start] / 3600) : 0;\n    const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n    const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n    function formatSecondsToHHMMSS(seconds) {\n        const sec = Math.floor(seconds % 60);\n        const min = Math.floor((seconds / 60) % 60);\n        const hr = Math.floor(seconds / 3600);\n        return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n    }\n    const effortDurationSec = climbTimeInSeconds;\n    function formatMMSS(seconds) {\n        const min = Math.floor(seconds / 60);\n        const sec = Math.floor(seconds % 60);\n        return `${min}:${sec.toString().padStart(2, '0')}`;\n    }\n    const traceText = [\n        (() => {\n            const sectionCadence = getStreamData(\"cadence\").slice(eff.start, eff.end);\n            const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n            return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n        })(),\n        (() => {\n            const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n            const percFTP = FTP ? ((avgPower / FTP) * 100) : 0;\n            return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''} | ${fmt(percFTP,0)}%`;\n        })(),\n        ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n        ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n        ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n        ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n        (() => {\n            if (avgGrade >= 4.5) {\n                const diffVAM = Math.abs(vamTeorico - vam);\n                let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n            } else {\n                return ` ${fmt(vam,0)} m/h`;\n            }\n        })(),\n        (() => {\n            if (avgGrade >= 4.5) {\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n            } else {\n                return '';\n            }\n        })(),\n        ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n        ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n    ].filter(Boolean).join('<br>');\n    traces.push({\n        x: sectionDistanceKm,\n        y: sectionAltitude,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n        hoverinfo: 'text',\n        visible: true,\n        hoverlabel: { align: 'left' },\n        text: traceText\n    });\n});\n\n// Annotazioni alternate sopra/sotto secondo ordine temporale\nconst globalMaxAlt = Math.max(...altitude);\nconst globalMinAlt = Math.min(...altitude);\neffortsWithIndex.forEach((eff, idx) => {\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    const effortDurationSec = time[eff.end - 1] - time[eff.start] + 1;\n    // Alternanza tra due livelli fissi rispetto al massimo/minimo globale dell'altitudine\n    let yAnn;\n    if (idx % 2 === 0) {\n        // Sopra: alterna tra basso e alto rispetto al massimo globale\n        yAnn = globalMaxAlt + ( ( (Math.floor(idx/2) % 2) === 0 ) ? 10 : 100 );\n    } else {\n        // Sotto: alterna tra basso e alto rispetto al minimo globale\n        yAnn = globalMinAlt - ( ( (Math.floor(idx/2) % 2) === 0 ) ? 10 : 100 );\n    }\n    annotations.push({\n        x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n        y: yAnn,\n        text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n        showarrow: false,\n        font: { family: 'Arial', size: 12, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        opacity: 0.9\n    });\n});\n\n    const configTitle =\n`<b>EFFORT</b> <b>|</b> ` +\n`<span style='color:#000000ff'>MRG [${MERGE_POWER_DIFF_PERCENT}%]</span> ` +\n`<span style='color:#000000ff'>WIN [${WINDOW_SECONDS}s]</span> ` +\n`<span style='color:#000000ff'>MIN [${MIN_EFFORT_INTENSITY_FTP}%FTP]</span> <b>|</b> ` +\n`<span style='color:#ff0000'>TRIM [${TRIM_WINDOW_SECONDS}s, ${TRIM_LOW_PERCENT}%]</span> ` +\n`<span style='color:#1901f5ff'> [${EXTEND_WINDOW_SECONDS}s, ${EXTEND_LOW_PERCENT}%]</span>`;\n    const layout = {\n        title: { text: configTitle, font: { color: '#222', size: 18 }, },\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "PROTOTYPE24"
      },
      "usage_count": 0,
      "index": 42,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-11T14:20:52.338+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 273760,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Chronic Intensity Load + Work",
      "description": "Work kJ + above FTP + chronic intensity load",
      "image": null,
      "content": {
        "id": "88l2javg",
        "name": "Chronic Intensity Load + Work",
        "plots": [
          {
            "id": 1,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(102,51,204,0.3)",
            "text": "Work",
            "type": "bars",
            "color": "rgb(102,51,204)",
            "field": "work",
            "scale": "kJ",
            "title": "Total work",
            "extras": [],
            "filter": "round0",
            "radius": 3,
            "stroke": "rgb(102,51,204)",
            "filters": [],
            "markerValue": "right",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "fitness_avg",
            "band": 0,
            "fill": "rgba(255,82,14, 0.4)",
            "text": "CIL",
            "type": "line",
            "color": "rgb(255,82,14)",
            "field": "cil",
            "scale": "load",
            "title": "42d exp avg of intensity",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(255,82,14)",
            "filters": [],
            "markerValue": "right",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 3,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "rgba(255,127,14,0.4)",
            "text": "kJ>FTP",
            "type": "bars",
            "color": "rgb(255,127,14)",
            "field": "kj_above_ftp",
            "scale": "kJ",
            "title": "Work above FTP",
            "extras": [],
            "filter": "round0",
            "radius": 3,
            "stroke": "rgb(255,127,14)",
            "filters": [],
            "markerValue": "right",
            "strokeWidth": 1,
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 4,
            "agg": "week_avg",
            "min": 0,
            "band": 0,
            "fill": "#037e6580",
            "text": "kJ/h",
            "type": "line",
            "field": "af_WorkHour",
            "gauge": true,
            "scale": null,
            "stack": "",
            "title": "WorkHour",
            "extras": [],
            "filter": "customInput",
            "radius": 3,
            "stroke": "#037e65ff",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "tickFormat": "customInput",
            "customInput": {
              "id": 396110,
              "name": "kJ/h",
              "type": "ACTIVITY_FIELD",
              "image": null,
              "index": 11,
              "content": {
                "max": null,
                "min": null,
                "code": "WorkHour",
                "icon": "mdi-battery-70",
                "link": null,
                "name": "kJ/h",
                "type": "numeric",
                "color": "#037E65",
                "gauge": true,
                "total": null,
                "units": null,
                "inline": false,
                "prefix": null,
                "script": "(activity.icu_joules/1000)/(activity. moving_time/3600)",
                "suffix": " kJ/h",
                "average": null,
                "convert": "",
                "example": 42,
                "options": null,
                "aggregate": "AVERAGE",
                "pace_units": null,
                "number_format": ".1f",
                "fit_session_field": null,
                "processes_fit_messages": false
              },
              "from_id": 127973,
              "updated": "2024-10-17T14:09:41.445+00:00",
              "athlete_id": "i115436",
              "visibility": "FOLLOWERS",
              "description": "Total work per moving_time",
              "hide_script": false,
              "usage_count": 41,
              "from_athlete": {
                "id": "i62859",
                "bio": null,
                "sex": "M",
                "city": "Paterna",
                "name": "OSCAR MARTINEZ",
                "email": null,
                "state": "Valencia",
                "country": "Spain",
                "website": null,
                "timezone": "Europe/Madrid",
                "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c295a232-660c-4a1c-abdb-a7ff5be4aaac"
              },
              "hidden_by_id": null
            },
            "markerValue": "right",
            "strokeWidth": 1,
            "invertSubWellness": false
          }
        ],
        "title": "CIL + Work",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 0,
      "index": 43,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2026-01-15T17:29:44.214+00:00",
      "from_athlete": {
        "id": "2049151",
        "name": "David (intervals.icu)",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/37e18c85-cac7-4c45-8dc8-2e716f4b66d2",
        "city": "Cape Town",
        "state": "Western Cape",
        "country": "South Africa",
        "timezone": "Africa/Johannesburg",
        "sex": "M",
        "bio": "Software Engineer and keen cyclist!",
        "website": "https://intervals.icu",
        "email": null
      },
      "from_id": 8044
    },
    {
      "id": 721862,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "prot3",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 90; // Soglia minima intensit (% FTP)\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n\n    // Limatura\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura (% della media effort)\n    // Estensione\n    const EXTEND_WINDOW_SECONDS = 15;    // Finestra estensione (s)\n    const EXTEND_LOW_PERCENT = 80;       // Soglia estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Limatura inizio/fine effort con finestre da TRIM_WINDOW_SECONDS\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n\n    // 1. Crea finestre fisse\n    let efforts = mergeConsecutiveWindows(power, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT);\n\n    // 2. Applica limatura PRIMA del merge (con parametri limatura)\n    efforts = efforts.map(eff => {\n        const trimmed = trimEffort(power, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    // 3. Filtra solo effort sopra la soglia percentuale di FTP\n    efforts = efforts.filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    // (estensione con parametri estensione)\n    function mergeEffortsPostTrim(efforts, power, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = power.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, power, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda (con parametri estensione)\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - EXTEND_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - EXTEND_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    start -= EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + EXTEND_WINDOW_SECONDS <= power.length) {\n                const extWin = power.slice(end, end + EXTEND_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    end += EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione (con parametri limatura)\n        // Calcola la media aggiornata dopo l'estensione\n        const updatedPower = power.slice(start, end);\n        const updatedAvg = updatedPower.reduce((a,b)=>a+b,0) / (updatedPower.length || 1);\n        const trimmed = trimEffort(power, start, end, updatedAvg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, power) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = power.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, power);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map((alt, i) => ` ${fmt(distanceKm[i],2)} km<br> ${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Altitudine'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n// Curve ordinate per potenza (sortedEfforts)\nsortedEfforts.forEach((eff, idx) => {\n    const sectionPower = power.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionTime = time.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    // Calcolo metriche aggiuntive come nel vecchio script\n    const sectionHR = heartrate.slice(eff.start, eff.end);\n    const sectionGrade = grade.slice(eff.start, eff.end);\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const dist = distance.slice(eff.start, eff.end);\n    const distTot = dist[dist.length - 1] - dist[0];\n    const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n    const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n    const vam = elevationGain / (climbTimeInSeconds / 3600);\n    const avgGrade = elevationGain / distTot * 100;\n    const gradientFactor = 2 + (avgGrade / 10);\n    const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n    let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n    if (sectionPower.length) {\n        const half = Math.floor(sectionPower.length / 2);\n        avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n        avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n        wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n    }\n    const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n    const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n    const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n    const startTime = sectionTime.length ? sectionTime[0] : '';\n    let best5sWatt = '', best5sWattKg = '';\n    let avgPowerPerKg = 0;\n    if (sectionPower.length >= 5 && weight > 0) {\n        const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n        best5sWatt = Math.round(maxW);\n        best5sWattKg = fmt(maxW / weight, 2);\n        avgPowerPerKg = avgPower / weight;\n    }\n    let joules = 0, joulesOverCP = 0;\n    if (power && time && eff.start !== undefined && eff.start < power.length && FTP) {\n        for (let i = 0; i < eff.start; i++) {\n            const w = power[i];\n            const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n            if (secs < 30) {\n                joules += w * secs;\n                if (w >= FTP) joulesOverCP += w * secs;\n            }\n        }\n    }\n    const hours = (time && eff.start !== undefined && time[eff.start]) ? (time[eff.start] / 3600) : 0;\n    const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n    const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n    function formatSecondsToHHMMSS(seconds) {\n        const sec = Math.floor(seconds % 60);\n        const min = Math.floor((seconds / 60) % 60);\n        const hr = Math.floor(seconds / 3600);\n        return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n    }\n    const effortDurationSec = climbTimeInSeconds;\n    function formatMMSS(seconds) {\n        const min = Math.floor(seconds / 60);\n        const sec = Math.floor(seconds % 60);\n        return `${min}:${sec.toString().padStart(2, '0')}`;\n    }\n    const traceText = [\n        (() => {\n            const sectionCadence = getStreamData(\"cadence\").slice(eff.start, eff.end);\n            const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n            return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n        })(),\n        (() => {\n            const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n            return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''}`;\n        })(),\n        ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n        ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n        ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n        ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n        (() => {\n            if (avgGrade >= 4.5) {\n                const diffVAM = Math.abs(vamTeorico - vam);\n                let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n            } else {\n                return ` ${fmt(vam,0)} m/h`;\n            }\n        })(),\n        (() => {\n            if (avgGrade >= 4.5) {\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n            } else {\n                return '';\n            }\n        })(),\n        ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n        ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n    ].filter(Boolean).join('<br>');\n    traces.push({\n        x: sectionDistanceKm,\n        y: sectionAltitude,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n        hoverinfo: 'text',\n        visible: true,\n        hoverlabel: { align: 'left' },\n        text: traceText\n    });\n});\n\n// Annotazioni alternate sopra/sotto secondo ordine temporale\nconst globalMaxAlt = Math.max(...altitude);\nconst globalMinAlt = Math.min(...altitude);\n\neffortsWithIndex.forEach((eff, idx) => {\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    const effortDurationSec = time[eff.end - 1] - time[eff.start] + 1;\n    // Tutte le annotazioni sopra la curva, offset incrementale\n    const yAnn = Math.max(...sectionAltitude) + 50 + eff.originalIdx * 25;\n    annotations.push({\n        x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n        y: yAnn,\n        text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n        showarrow: false,\n        font: { family: 'Arial', size: 12, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        opacity: 0.9\n    });\n});\n\n    const configTitle =\n`<b>EFFORT</b> <b>|</b> ` +\n`<span style='color:#000000ff'>MRG [${MERGE_POWER_DIFF_PERCENT}%]</span> ` +\n`<span style='color:#000000ff'>WIN [${WINDOW_SECONDS}s]</span> ` +\n`<span style='color:#000000ff'>MIN [${MIN_EFFORT_INTENSITY_FTP}%FTP]</span> <b>|</b> ` +\n`<span style='color:#ff0000'>TRIM [${TRIM_WINDOW_SECONDS}s, ${TRIM_LOW_PERCENT}%]</span> ` +\n`<span style='color:#1901f5ff'> [${EXTEND_WINDOW_SECONDS}s, ${EXTEND_LOW_PERCENT}%]</span>`;\n    const layout = {\n        title: { text: configTitle, font: { color: '#222', size: 18 }, },\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "prot3"
      },
      "usage_count": 0,
      "index": 43,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-11T14:22:03.948+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 273777,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Cycling time in power zones",
      "description": "Time in power zones using 5 zone model",
      "image": null,
      "content": {
        "id": "mrby0dy3",
        "name": "Cycling time in power zones",
        "plots": [
          {
            "id": "time_in_s3",
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#34ACE466",
            "text": "Z1",
            "type": "bars",
            "field": "time_in_z1",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z1",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#009e80",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z1",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z1",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": "time_in_s2",
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#009E0080",
            "text": "Z2",
            "type": "bars",
            "field": "time_in_z2",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z2",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#009e00",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z2",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z2",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": "time_in_s1",
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#FFCB0E80",
            "text": "Z3",
            "type": "bars",
            "field": "time_in_z3",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z3",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#ffcb0e",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z3",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z3",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 1,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#FF7F0EFF",
            "text": "Z4",
            "type": "bars",
            "field": "time_in_z4",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z4",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "#ff7f0e",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z4",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z4",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 2,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#DD0447B8",
            "text": "Z5+",
            "type": "bars",
            "field": "time_in_s3",
            "scale": "hours",
            "stack": "sieler_hours",
            "title": "Time in Z5, Z6 and Z7",
            "extras": [],
            "filter": "hours",
            "future": true,
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Z5+",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "Time in Z5, Z6 and Z7",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "5 zones model ",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "Power zones (h)",
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 1,
      "index": 44,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T10:11:05.161+00:00",
      "from_athlete": {
        "id": "i30021",
        "name": "Nimmerichter",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/4db948e6-c8d9-46c4-ba9d-77ad29397f38",
        "city": null,
        "state": null,
        "country": null,
        "timezone": "Europe/Vienna",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 65666
    },
    {
      "id": 726115,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "prot4",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 90; // Soglia minima intensit (% FTP)\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n\n    // Limatura\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura (% della media effort)\n    // Estensione\n    const EXTEND_WINDOW_SECONDS = 15;    // Finestra estensione (s)\n    const EXTEND_LOW_PERCENT = 80;       // Soglia estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Limatura inizio/fine effort con finestre da TRIM_WINDOW_SECONDS\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n\n    // 1. Crea finestre fisse\n    let efforts = mergeConsecutiveWindows(power, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT);\n\n    // 2. Applica limatura PRIMA del merge (con parametri limatura)\n    efforts = efforts.map(eff => {\n        const trimmed = trimEffort(power, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    // 3. Filtra solo effort sopra la soglia percentuale di FTP\n    efforts = efforts.filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    // (estensione con parametri estensione)\n    function mergeEffortsPostTrim(efforts, power, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = power.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, power, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda (con parametri estensione)\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - EXTEND_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - EXTEND_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    start -= EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + EXTEND_WINDOW_SECONDS <= power.length) {\n                const extWin = power.slice(end, end + EXTEND_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    end += EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione (con parametri limatura)\n        // Calcola la media aggiornata dopo l'estensione\n        const updatedPower = power.slice(start, end);\n        const updatedAvg = updatedPower.reduce((a,b)=>a+b,0) / (updatedPower.length || 1);\n        const trimmed = trimEffort(power, start, end, updatedAvg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, power) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = power.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, power);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map((alt, i) => ` ${fmt(distanceKm[i],2)} km<br> ${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Altitudine'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n// Curve ordinate per potenza (sortedEfforts)\nsortedEfforts.forEach((eff, idx) => {\n    const sectionPower = power.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionTime = time.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    // Calcolo metriche aggiuntive come nel vecchio script\n    const sectionHR = heartrate.slice(eff.start, eff.end);\n    const sectionGrade = grade.slice(eff.start, eff.end);\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const dist = distance.slice(eff.start, eff.end);\n    const distTot = dist[dist.length - 1] - dist[0];\n    const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n    const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n    const vam = elevationGain / (climbTimeInSeconds / 3600);\n    const avgGrade = elevationGain / distTot * 100;\n    const gradientFactor = 2 + (avgGrade / 10);\n    const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n    let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n    if (sectionPower.length) {\n        const half = Math.floor(sectionPower.length / 2);\n        avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n        avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n        wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n    }\n    const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n    const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n    const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n    const startTime = sectionTime.length ? sectionTime[0] : '';\n    let best5sWatt = '', best5sWattKg = '';\n    let avgPowerPerKg = 0;\n    if (sectionPower.length >= 5 && weight > 0) {\n        const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n        best5sWatt = Math.round(maxW);\n        best5sWattKg = fmt(maxW / weight, 2);\n        avgPowerPerKg = avgPower / weight;\n    }\n    let joules = 0, joulesOverCP = 0;\n    if (power && time && eff.start !== undefined && eff.start < power.length && FTP) {\n        for (let i = 0; i < eff.start; i++) {\n            const w = power[i];\n            const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n            if (secs < 30) {\n                joules += w * secs;\n                if (w >= FTP) joulesOverCP += w * secs;\n            }\n        }\n    }\n    const hours = (time && eff.start !== undefined && time[eff.start]) ? (time[eff.start] / 3600) : 0;\n    const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n    const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n    function formatSecondsToHHMMSS(seconds) {\n        const sec = Math.floor(seconds % 60);\n        const min = Math.floor((seconds / 60) % 60);\n        const hr = Math.floor(seconds / 3600);\n        return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n    }\n    const effortDurationSec = climbTimeInSeconds;\n    function formatMMSS(seconds) {\n        const min = Math.floor(seconds / 60);\n        const sec = Math.floor(seconds % 60);\n        return `${min}:${sec.toString().padStart(2, '0')}`;\n    }\n    const traceText = [\n        (() => {\n            const sectionCadence = getStreamData(\"cadence\").slice(eff.start, eff.end);\n            const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n            return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n        })(),\n        (() => {\n            const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n            const percFTP = FTP ? ((avgPower / FTP) * 100) : 0;\n            return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''} | ${fmt(percFTP,0)}% FTP`;\n        })(),\n        ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n        ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n        ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n        ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n        (() => {\n            if (avgGrade >= 4.5) {\n                const diffVAM = Math.abs(vamTeorico - vam);\n                let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n            } else {\n                return ` ${fmt(vam,0)} m/h`;\n            }\n        })(),\n        (() => {\n            if (avgGrade >= 4.5) {\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n            } else {\n                return '';\n            }\n        })(),\n        ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n        ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n    ].filter(Boolean).join('<br>');\n    traces.push({\n        x: sectionDistanceKm,\n        y: sectionAltitude,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n        hoverinfo: 'text',\n        visible: true,\n        hoverlabel: { align: 'left' },\n        text: traceText\n    });\n});\n\n// Annotazioni alternate sopra/sotto secondo ordine temporale\nconst globalMaxAlt = Math.max(...altitude);\nconst globalMinAlt = Math.min(...altitude);\n\neffortsWithIndex.forEach((eff, idx) => {\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    const effortDurationSec = time[eff.end - 1] - time[eff.start] + 1;\n    // Offset verticale: ogni annotation +100, max 4 (450), poi ricomincia da 50\n    const offsetStep = 40;\n    const maxSteps = 4;\n    const baseOffset = 50;\n    const yAnn = Math.max(...sectionAltitude) + baseOffset + ((eff.originalIdx % (maxSteps + 1)) * offsetStep);\n    annotations.push({\n        x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n        y: yAnn,\n        text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n        showarrow: false,\n        font: { family: 'Arial', size: 12, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        opacity: 0.9\n    });\n});\n\n    const configTitle =\n`<b>EFFORT</b> <b>|</b> ` +\n`<span style='color:#000000ff'>MRG [${MERGE_POWER_DIFF_PERCENT}%]</span> ` +\n`<span style='color:#000000ff'>WIN [${WINDOW_SECONDS}s]</span> ` +\n`<span style='color:#000000ff'>MIN [${MIN_EFFORT_INTENSITY_FTP}%FTP]</span> <b>|</b> ` +\n`<span style='color:#ff0000'>TRIM [${TRIM_WINDOW_SECONDS}s, ${TRIM_LOW_PERCENT}%]</span> ` +\n`<span style='color:#1901f5ff'> [${EXTEND_WINDOW_SECONDS}s, ${EXTEND_LOW_PERCENT}%]</span>`;\n    const layout = {\n        title: { text: configTitle, font: { color: '#222', size: 18 }, },\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "prot4"
      },
      "usage_count": 0,
      "index": 44,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-11T14:22:08.846+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 726134,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "prot5",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 90; // Soglia minima intensit (% FTP)\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n\n    // Limatura\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura (% della media effort)\n    // Estensione\n    const EXTEND_WINDOW_SECONDS = 15;    // Finestra estensione (s)\n    const EXTEND_LOW_PERCENT = 80;       // Soglia estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Limatura inizio/fine effort con finestre da TRIM_WINDOW_SECONDS\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n\n    // 1. Crea finestre fisse\n    let efforts = mergeConsecutiveWindows(power, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT);\n\n    // 2. Applica limatura PRIMA del merge (con parametri limatura)\n    efforts = efforts.map(eff => {\n        const trimmed = trimEffort(power, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    // 3. Filtra solo effort sopra la soglia percentuale di FTP\n    efforts = efforts.filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    // (estensione con parametri estensione)\n    function mergeEffortsPostTrim(efforts, power, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = power.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, power, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda (con parametri estensione)\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - EXTEND_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - EXTEND_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    start -= EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + EXTEND_WINDOW_SECONDS <= power.length) {\n                const extWin = power.slice(end, end + EXTEND_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    end += EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione (con parametri limatura)\n        // Calcola la media aggiornata dopo l'estensione\n        const updatedPower = power.slice(start, end);\n        const updatedAvg = updatedPower.reduce((a,b)=>a+b,0) / (updatedPower.length || 1);\n        const trimmed = trimEffort(power, start, end, updatedAvg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, power) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = power.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, power);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map((alt, i) => ` ${fmt(distanceKm[i],2)} km<br> ${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Altitudine'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n// Curve ordinate per potenza (sortedEfforts)\nsortedEfforts.forEach((eff, idx) => {\n    const sectionPower = power.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionTime = time.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    // Calcolo metriche aggiuntive come nel vecchio script\n    const sectionHR = heartrate.slice(eff.start, eff.end);\n    const sectionGrade = grade.slice(eff.start, eff.end);\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const dist = distance.slice(eff.start, eff.end);\n    const distTot = dist[dist.length - 1] - dist[0];\n    const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n    const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n    const vam = elevationGain / (climbTimeInSeconds / 3600);\n    const avgGrade = elevationGain / distTot * 100;\n    const gradientFactor = 2 + (avgGrade / 10);\n    const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n    let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n    if (sectionPower.length) {\n        const half = Math.floor(sectionPower.length / 2);\n        avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n        avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n        wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n    }\n    const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n    const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n    const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n    const startTime = sectionTime.length ? sectionTime[0] : '';\n    let best5sWatt = '', best5sWattKg = '';\n    let avgPowerPerKg = 0;\n    if (sectionPower.length >= 5 && weight > 0) {\n        const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n        best5sWatt = Math.round(maxW);\n        best5sWattKg = fmt(maxW / weight, 2);\n        avgPowerPerKg = avgPower / weight;\n    }\n    let joules = 0, joulesOverCP = 0;\n    if (power && time && eff.start !== undefined && eff.start < power.length && FTP) {\n        for (let i = 0; i < eff.start; i++) {\n            const w = power[i];\n            const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n            if (secs < 30) {\n                joules += w * secs;\n                if (w >= FTP) joulesOverCP += w * secs;\n            }\n        }\n    }\n    const hours = (time && eff.start !== undefined && time[eff.start]) ? (time[eff.start] / 3600) : 0;\n    const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n    const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n    function formatSecondsToHHMMSS(seconds) {\n        const sec = Math.floor(seconds % 60);\n        const min = Math.floor((seconds / 60) % 60);\n        const hr = Math.floor(seconds / 3600);\n        return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n    }\n    const effortDurationSec = climbTimeInSeconds;\n    function formatMMSS(seconds) {\n        const min = Math.floor(seconds / 60);\n        const sec = Math.floor(seconds % 60);\n        return `${min}:${sec.toString().padStart(2, '0')}`;\n    }\n    const traceText = [\n        (() => {\n            const sectionCadence = getStreamData(\"cadence\").slice(eff.start, eff.end);\n            const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n            return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n        })(),\n        (() => {\n            const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n            const percFTP = FTP ? ((avgPower / FTP) * 100) : 0;\n            return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''} | ${fmt(percFTP,0)}%`;\n        })(),\n        ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n        ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n        ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n        ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n        (() => {\n            if (avgGrade >= 4.5) {\n                const diffVAM = Math.abs(vamTeorico - vam);\n                let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n            } else {\n                return ` ${fmt(vam,0)} m/h`;\n            }\n        })(),\n        (() => {\n            if (avgGrade >= 4.5) {\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n            } else {\n                return '';\n            }\n        })(),\n        ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n        ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n    ].filter(Boolean).join('<br>');\n    traces.push({\n        x: sectionDistanceKm,\n        y: sectionAltitude,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n        hoverinfo: 'text',\n        visible: true,\n        hoverlabel: { align: 'left' },\n        text: traceText\n    });\n});\n\n// Annotazioni alternate sopra/sotto secondo ordine temporale\nconst globalMaxAlt = Math.max(...altitude);\nconst globalMinAlt = Math.min(...altitude);\n\neffortsWithIndex.forEach((eff, idx) => {\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    const effortDurationSec = time[eff.end - 1] - time[eff.start] + 1;\n    // Offset fissi\n    const offsets = [40, 115, 190];\n    const yAnn = globalMaxAlt + offsets[eff.originalIdx % offsets.length];\n    annotations.push({\n        x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n        y: yAnn,\n        text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n        showarrow: false,\n        font: { family: 'Arial', size: 12, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        opacity: 0.9\n    });\n});\n\n    const configTitle =\n`<b>EFFORT</b> <b>|</b> ` +\n`<span style='color:#000000ff'>MRG [${MERGE_POWER_DIFF_PERCENT}%]</span> ` +\n`<span style='color:#000000ff'>WIN [${WINDOW_SECONDS}s]</span> ` +\n`<span style='color:#000000ff'>MIN [${MIN_EFFORT_INTENSITY_FTP}%FTP]</span> <b>|</b> ` +\n`<span style='color:#ff0000'>TRIM [${TRIM_WINDOW_SECONDS}s, ${TRIM_LOW_PERCENT}%]</span> ` +\n`<span style='color:#1901f5ff'> [${EXTEND_WINDOW_SECONDS}s, ${EXTEND_LOW_PERCENT}%]</span>`;\n    const layout = {\n        title: { text: configTitle, font: { color: '#222', size: 18 }, },\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "prot5"
      },
      "usage_count": 0,
      "index": 45,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-11T14:22:14.106+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 839007,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "Distance",
      "description": null,
      "image": null,
      "content": {
        "id": "fyqxhfss",
        "name": "Distance",
        "plots": [
          {
            "id": 4,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#dd04a7ff",
            "text": "Run",
            "type": "bars",
            "field": "distance",
            "scale": "distance",
            "stack": "distance",
            "title": "Distance covered",
            "extras": [],
            "filter": "distance_units",
            "future": true,
            "radius": 3,
            "stroke": "rgb(23,190,207)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Run"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Distance",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Distance covered",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#8c564bff",
            "text": "Trail",
            "type": "bars",
            "field": "distance",
            "scale": "distance",
            "stack": "distance",
            "title": "Distance covered",
            "extras": [],
            "filter": "distance_units",
            "future": true,
            "radius": 3,
            "stroke": "rgb(23,190,207)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "TrailRun"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Distance",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Distance covered",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "week_tot",
            "min": 0,
            "band": 0,
            "fill": "#009e00ff",
            "text": "Hike",
            "type": "bars",
            "field": "distance",
            "scale": "distance",
            "stack": "distance",
            "title": "Distance covered",
            "extras": [],
            "filter": "distance_units",
            "future": true,
            "radius": 3,
            "stroke": "rgb(23,190,207)",
            "filters": [
              {
                "id": 1,
                "value": [
                  "Hike"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Distance",
            "markerValue": "right-inline",
            "strokeWidth": 1,
            "i18nTitleKey": "Distance covered",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "Distance",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "km",
        "y2AxisLabel": "",
        "stackTo100Percent": false
      },
      "usage_count": 0,
      "index": 45,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-11-23T08:40:43.815+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 504118,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "FOLLOWERS",
      "name": "Feel CHR",
      "description": null,
      "image": null,
      "content": {
        "id": "1jdfxgr4",
        "name": "Feel CHR",
        "plots": [
          {
            "id": 1,
            "agg": "moving_avg",
            "min": null,
            "band": 0.4,
            "fill": "#33333380",
            "text": "Feel",
            "type": "line",
            "field": "feel",
            "gauge": true,
            "scale": "feel",
            "stack": "",
            "title": "How did you feel?",
            "extras": [
              {
                "id": 1,
                "y1": 0.5,
                "y2": 1.5,
                "fill": "#DD0447FF",
                "text": "WEAK",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 2,
                "y1": 1.5,
                "y2": 2.5,
                "fill": "#FC7C0CFF",
                "text": "POOR",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 3,
                "y1": 2.5,
                "y2": 3.5,
                "fill": "#E5A718FF",
                "text": "NORMAL",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 4,
                "y1": 3.5,
                "y2": 4.5,
                "fill": "#16BB16FF",
                "text": "GOOD",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              },
              {
                "id": 5,
                "y1": 4.5,
                "y2": 5.5,
                "fill": "#1F77B4FF",
                "text": "STRONG",
                "type": "bar",
                "zone": 2,
                "labelX": "right",
                "labelY": "center",
                "stroke": "#333333FF",
                "opacity": 0.8
              }
            ],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#0E7BF1FF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "Ride",
                  "MountainBikeRide",
                  "GravelRide",
                  "VirtualRide"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Feel",
            "markerValue": "none",
            "strokeWidth": 1.5,
            "i18nTitleKey": "feel",
            "showOnCalendar": false,
            "invertSubWellness": true
          },
          {
            "id": 2,
            "agg": "moving_avg",
            "min": null,
            "band": 0.4,
            "fill": "#33333380",
            "text": "Feel",
            "type": "line",
            "field": "feel",
            "gauge": true,
            "scale": "feel",
            "stack": "",
            "title": "How did you feel?",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#EE2C6DFF",
            "aggArgs": {
              "days": 42,
              "factor": 1
            },
            "filters": [
              {
                "id": 1,
                "value": [
                  "WeightTraining",
                  "Workout"
                ],
                "field_id": "type"
              }
            ],
            "i18nKey": "Feel",
            "markerValue": "none",
            "strokeWidth": 1.5,
            "i18nTitleKey": "feel",
            "showOnCalendar": false,
            "invertSubWellness": true
          },
          {
            "id": 3,
            "agg": "none",
            "min": null,
            "band": 0,
            "fill": "#0E7BF100",
            "text": "Feel",
            "type": "bars",
            "field": "feel",
            "gauge": true,
            "scale": "feel",
            "stack": "",
            "title": "How did you feel?",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(0,158,0)",
            "filters": [],
            "i18nKey": "Feel",
            "markerValue": "top",
            "strokeWidth": 1,
            "i18nTitleKey": "feel",
            "showOnCalendar": false,
            "invertSubWellness": true
          }
        ],
        "title": "Feel 42d",
        "height": 165,
        "yAxisMax": 5.5,
        "yAxisMin": 0.5,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": null,
        "y2AxisLabel": null,
        "stackTo100Percent": null
      },
      "usage_count": 1,
      "index": 46,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2024-12-20T08:21:33.501+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 726147,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "prot6",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 90; // Soglia minima intensit (% FTP)\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n\n    // Limatura\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura (% della media effort)\n    // Estensione\n    const EXTEND_WINDOW_SECONDS = 15;    // Finestra estensione (s)\n    const EXTEND_LOW_PERCENT = 80;       // Soglia estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Limatura inizio/fine effort con finestre da TRIM_WINDOW_SECONDS\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n\n    // 1. Crea finestre fisse\n    let efforts = mergeConsecutiveWindows(power, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT);\n\n    // 2. Applica limatura PRIMA del merge (con parametri limatura)\n    efforts = efforts.map(eff => {\n        const trimmed = trimEffort(power, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    // 3. Filtra solo effort sopra la soglia percentuale di FTP\n    efforts = efforts.filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    // (estensione con parametri estensione)\n    function mergeEffortsPostTrim(efforts, power, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = power.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, power, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda (con parametri estensione)\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - EXTEND_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - EXTEND_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    start -= EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + EXTEND_WINDOW_SECONDS <= power.length) {\n                const extWin = power.slice(end, end + EXTEND_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    end += EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione (con parametri limatura)\n        // Calcola la media aggiornata dopo l'estensione\n        const updatedPower = power.slice(start, end);\n        const updatedAvg = updatedPower.reduce((a,b)=>a+b,0) / (updatedPower.length || 1);\n        const trimmed = trimEffort(power, start, end, updatedAvg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, power) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = power.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, power);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map((alt, i) => ` ${fmt(distanceKm[i],2)} km<br> ${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Altitudine'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n// Curve ordinate per potenza (sortedEfforts)\nsortedEfforts.forEach((eff, idx) => {\n    const sectionPower = power.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionTime = time.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    // Calcolo metriche aggiuntive come nel vecchio script\n    const sectionHR = heartrate.slice(eff.start, eff.end);\n    const sectionGrade = grade.slice(eff.start, eff.end);\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const dist = distance.slice(eff.start, eff.end);\n    const distTot = dist[dist.length - 1] - dist[0];\n    const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n    const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n    const vam = elevationGain / (climbTimeInSeconds / 3600);\n    const avgGrade = elevationGain / distTot * 100;\n    const gradientFactor = 2 + (avgGrade / 10);\n    const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n    let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n    if (sectionPower.length) {\n        const half = Math.floor(sectionPower.length / 2);\n        avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n        avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n        wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n    }\n    const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n    const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n    const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n    const startTime = sectionTime.length ? sectionTime[0] : '';\n    let best5sWatt = '', best5sWattKg = '';\n    let avgPowerPerKg = 0;\n    if (sectionPower.length >= 5 && weight > 0) {\n        const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n        best5sWatt = Math.round(maxW);\n        best5sWattKg = fmt(maxW / weight, 2);\n        avgPowerPerKg = avgPower / weight;\n    }\n    let joules = 0, joulesOverCP = 0;\n    if (power && time && eff.start !== undefined && eff.start < power.length && FTP) {\n        for (let i = 0; i < eff.start; i++) {\n            const w = power[i];\n            const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n            if (secs < 30) {\n                joules += w * secs;\n                if (w >= FTP) joulesOverCP += w * secs;\n            }\n        }\n    }\n    const hours = (time && eff.start !== undefined && time[eff.start]) ? (time[eff.start] / 3600) : 0;\n    const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n    const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n    function formatSecondsToHHMMSS(seconds) {\n        const sec = Math.floor(seconds % 60);\n        const min = Math.floor((seconds / 60) % 60);\n        const hr = Math.floor(seconds / 3600);\n        return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n    }\n    const effortDurationSec = climbTimeInSeconds;\n    function formatMMSS(seconds) {\n        const min = Math.floor(seconds / 60);\n        const sec = Math.floor(seconds % 60);\n        return `${min}:${sec.toString().padStart(2, '0')}`;\n    }\n    const traceText = [\n        (() => {\n            const sectionCadence = getStreamData(\"cadence\").slice(eff.start, eff.end);\n            const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n            return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n        })(),\n        (() => {\n            const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n            const percFTP = FTP ? ((avgPower / FTP) * 100) : 0;\n            return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''} | ${fmt(percFTP,0)}%`;\n        })(),\n        ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n        ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n        ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n        ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n        (() => {\n            if (avgGrade >= 4.5) {\n                const diffVAM = Math.abs(vamTeorico - vam);\n                let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n            } else {\n                return ` ${fmt(vam,0)} m/h`;\n            }\n        })(),\n        (() => {\n            if (avgGrade >= 4.5) {\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n            } else {\n                return '';\n            }\n        })(),\n        ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n        ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n    ].filter(Boolean).join('<br>');\n    traces.push({\n        x: sectionDistanceKm,\n        y: sectionAltitude,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n        hoverinfo: 'text',\n        visible: true,\n        hoverlabel: { align: 'left' },\n        text: traceText\n    });\n});\n\n// Annotazioni alternate sopra/sotto secondo ordine temporale\nconst globalMaxAlt = Math.max(...altitude);\nconst globalMinAlt = Math.min(...altitude);\n\neffortsWithIndex.forEach((eff, idx) => {\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    const effortDurationSec = time[eff.end - 1] - time[eff.start] + 1;\n//valori di offset\n    const offsets = [115, 40, -10, -70];    // Sequenza: sopra (+nn), sotto (-nn)\n    const yAnn = (eff.originalIdx % 4 < 2)\n        ? globalMaxAlt + offsets[eff.originalIdx % 4]\n        : globalMinAlt + offsets[eff.originalIdx % 4];\n    annotations.push({\n        x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n        y: yAnn,\n        text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n        showarrow: false,\n        font: { family: 'Arial', size: 12, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        opacity: 0.9\n    });\n});\n\n    const configTitle =\n`<b>EFFORT</b> <b>|</b> ` +\n`<span style='color:#000000ff'>MRG [${MERGE_POWER_DIFF_PERCENT}%]</span> ` +\n`<span style='color:#000000ff'>WIN [${WINDOW_SECONDS}s]</span> ` +\n`<span style='color:#000000ff'>MIN [${MIN_EFFORT_INTENSITY_FTP}%FTP]</span> <b>|</b> ` +\n`<span style='color:#ff0000'>TRIM [${TRIM_WINDOW_SECONDS}s, ${TRIM_LOW_PERCENT}%]</span> ` +\n`<span style='color:#1901f5ff'> [${EXTEND_WINDOW_SECONDS}s, ${EXTEND_LOW_PERCENT}%]</span>`;\n    const layout = {\n        title: { text: configTitle, font: { color: '#222', size: 18 }, },\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "prot6"
      },
      "usage_count": 0,
      "index": 46,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-11T14:22:32.011+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 726157,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "prot7%",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 100; // Soglia minima intensit (% FTP)\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n\n    // Limatura\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura (% della media effort)\n    // Estensione\n    const EXTEND_WINDOW_SECONDS = 15;    // Finestra estensione (s)\n    const EXTEND_LOW_PERCENT = 80;       // Soglia estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Limatura inizio/fine effort con finestre da TRIM_WINDOW_SECONDS\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n\n    // 1. Crea finestre fisse\n    let efforts = mergeConsecutiveWindows(power, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT);\n\n    // 2. Applica limatura PRIMA del merge (con parametri limatura)\n    efforts = efforts.map(eff => {\n        const trimmed = trimEffort(power, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    // 3. Filtra solo effort sopra la soglia percentuale di FTP\n    efforts = efforts.filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    // (estensione con parametri estensione)\n    function mergeEffortsPostTrim(efforts, power, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = power.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, power, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda (con parametri estensione)\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - EXTEND_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - EXTEND_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    start -= EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + EXTEND_WINDOW_SECONDS <= power.length) {\n                const extWin = power.slice(end, end + EXTEND_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    end += EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione (con parametri limatura)\n        // Calcola la media aggiornata dopo l'estensione\n        const updatedPower = power.slice(start, end);\n        const updatedAvg = updatedPower.reduce((a,b)=>a+b,0) / (updatedPower.length || 1);\n        const trimmed = trimEffort(power, start, end, updatedAvg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, power) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = power.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, power);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map((alt, i) => ` ${fmt(distanceKm[i],2)} km<br> ${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Altitudine'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n// Curve ordinate per potenza (sortedEfforts)\nsortedEfforts.forEach((eff, idx) => {\n    const sectionPower = power.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionTime = time.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    // Calcolo metriche aggiuntive come nel vecchio script\n    const sectionHR = heartrate.slice(eff.start, eff.end);\n    const sectionGrade = grade.slice(eff.start, eff.end);\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const dist = distance.slice(eff.start, eff.end);\n    const distTot = dist[dist.length - 1] - dist[0];\n    const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n    const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n    const vam = elevationGain / (climbTimeInSeconds / 3600);\n    const avgGrade = elevationGain / distTot * 100;\n    const gradientFactor = 2 + (avgGrade / 10);\n    const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n    let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n    if (sectionPower.length) {\n        const half = Math.floor(sectionPower.length / 2);\n        avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n        avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n        wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n    }\n    const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n    const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n    const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n    const startTime = sectionTime.length ? sectionTime[0] : '';\n    let best5sWatt = '', best5sWattKg = '';\n    let avgPowerPerKg = 0;\n    if (sectionPower.length >= 5 && weight > 0) {\n        const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n        best5sWatt = Math.round(maxW);\n        best5sWattKg = fmt(maxW / weight, 2);\n        avgPowerPerKg = avgPower / weight;\n    }\n    let joules = 0, joulesOverCP = 0;\n    if (power && time && eff.start !== undefined && eff.start < power.length && FTP) {\n        for (let i = 0; i < eff.start; i++) {\n            const w = power[i];\n            const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n            if (secs < 30) {\n                joules += w * secs;\n                if (w >= FTP) joulesOverCP += w * secs;\n            }\n        }\n    }\n    const hours = (time && eff.start !== undefined && time[eff.start]) ? (time[eff.start] / 3600) : 0;\n    const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n    const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n    function formatSecondsToHHMMSS(seconds) {\n        const sec = Math.floor(seconds % 60);\n        const min = Math.floor((seconds / 60) % 60);\n        const hr = Math.floor(seconds / 3600);\n        return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n    }\n    const effortDurationSec = climbTimeInSeconds;\n    function formatMMSS(seconds) {\n        const min = Math.floor(seconds / 60);\n        const sec = Math.floor(seconds % 60);\n        return `${min}:${sec.toString().padStart(2, '0')}`;\n    }\n    const traceText = [\n        (() => {\n            const sectionCadence = getStreamData(\"cadence\").slice(eff.start, eff.end);\n            const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n            return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n        })(),\n        (() => {\n            const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n            const percFTP = FTP ? ((avgPower / FTP) * 100) : 0;\n            return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''} | ${fmt(percFTP,0)}%`;\n        })(),\n        ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n        ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n        ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n        ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n        (() => {\n            if (avgGrade >= 4.5) {\n                const diffVAM = Math.abs(vamTeorico - vam);\n                let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n            } else {\n                return ` ${fmt(vam,0)} m/h`;\n            }\n        })(),\n        (() => {\n            if (avgGrade >= 4.5) {\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n            } else {\n                return '';\n            }\n        })(),\n        ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n        ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n    ].filter(Boolean).join('<br>');\n    traces.push({\n        x: sectionDistanceKm,\n        y: sectionAltitude,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n        hoverinfo: 'text',\n        visible: true,\n        hoverlabel: { align: 'left' },\n        text: traceText\n    });\n});\n\n// Annotazioni alternate sopra/sotto secondo ordine temporale\nconst globalMaxAlt = Math.max(...altitude);\nconst globalMinAlt = Math.min(...altitude);\nconst altRange = globalMaxAlt - globalMinAlt;\n\neffortsWithIndex.forEach((eff, idx) => {\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    const effortDurationSec = time[eff.end - 1] - time[eff.start] + 1;\n\n    // Offset proporzionale al range di altitudine\n    const offsets = [0.25, 0.75, 1.25]; // percentuali del range\n    const yAnn = globalMaxAlt + offsets[eff.originalIdx % offsets.length] * altRange;\n    annotations.push({\n        x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n        y: yAnn,\n        text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n        showarrow: false,\n        font: { family: 'Arial', size: 12, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        opacity: 0.9\n    });\n});\n\n    const configTitle =\n`<b>EFFORT</b> <b>|</b> ` +\n`<span style='color:#000000ff'>MRG [${MERGE_POWER_DIFF_PERCENT}%]</span> ` +\n`<span style='color:#000000ff'>WIN [${WINDOW_SECONDS}s]</span> ` +\n`<span style='color:#000000ff'>MIN [${MIN_EFFORT_INTENSITY_FTP}%FTP]</span> <b>|</b> ` +\n`<span style='color:#ff0000'>TRIM [${TRIM_WINDOW_SECONDS}s, ${TRIM_LOW_PERCENT}%]</span> ` +\n`<span style='color:#1901f5ff'> [${EXTEND_WINDOW_SECONDS}s, ${EXTEND_LOW_PERCENT}%]</span>`;\n    const layout = {\n        title: { text: configTitle, font: { color: '#222', size: 18 }, },\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "prot7%"
      },
      "usage_count": 0,
      "index": 47,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2026-01-09T20:55:06.126+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 884358,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "SSCP",
      "description": null,
      "image": null,
      "content": {
        "id": "75axset9",
        "name": "SSCP",
        "plots": [
          {
            "id": 7,
            "agg": "fitness_avg",
            "min": 0,
            "band": 0,
            "fill": "#009e0066",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "FITNESS",
            "type": "line",
            "field": "ss_cp",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "Aerobic strain score",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009e00ff",
            "filters": [],
            "i18nKey": "SS CP",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "ss_cp_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 8,
            "agg": "fatique_avg",
            "min": 0,
            "band": 0,
            "fill": "#009e0066",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "FAT",
            "type": "line",
            "field": "ss_cp",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "Aerobic strain score",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#009e00ff",
            "filters": [],
            "i18nKey": "SS CP",
            "markerValue": "right",
            "strokeWidth": 1.1,
            "i18nTitleKey": "ss_cp_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 9,
            "agg": "moving_avg",
            "min": 0,
            "band": 0,
            "fill": "#009e0026",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "7D",
            "type": "bars",
            "field": "ss_cp",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "Aerobic strain score",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(0,158,0)",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "SS CP",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "ss_cp_title",
            "invertSubWellness": false
          },
          {
            "id": 10,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#009e0000",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "DAY",
            "type": "dot",
            "field": "ss_cp",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "Aerobic strain score",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [],
            "i18nKey": "SS CP",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "ss_cp_title",
            "invertSubWellness": false
          }
        ],
        "title": "SSCP",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "",
        "y2AxisLabel": "",
        "stackTo100Percent": false
      },
      "usage_count": 0,
      "index": 47,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-30T20:46:11.500+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 726169,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "prot8%",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 90; // Soglia minima intensit (% FTP)\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n\n    // Limatura\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura (% della media effort)\n    // Estensione\n    const EXTEND_WINDOW_SECONDS = 15;    // Finestra estensione (s)\n    const EXTEND_LOW_PERCENT = 80;       // Soglia estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Limatura inizio/fine effort con finestre da TRIM_WINDOW_SECONDS\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n\n    // 1. Crea finestre fisse\n    let efforts = mergeConsecutiveWindows(power, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT);\n\n    // 2. Applica limatura PRIMA del merge (con parametri limatura)\n    efforts = efforts.map(eff => {\n        const trimmed = trimEffort(power, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    // 3. Filtra solo effort sopra la soglia percentuale di FTP\n    efforts = efforts.filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    // (estensione con parametri estensione)\n    function mergeEffortsPostTrim(efforts, power, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = power.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, power, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda (con parametri estensione)\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - EXTEND_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - EXTEND_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    start -= EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + EXTEND_WINDOW_SECONDS <= power.length) {\n                const extWin = power.slice(end, end + EXTEND_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    end += EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione (con parametri limatura)\n        // Calcola la media aggiornata dopo l'estensione\n        const updatedPower = power.slice(start, end);\n        const updatedAvg = updatedPower.reduce((a,b)=>a+b,0) / (updatedPower.length || 1);\n        const trimmed = trimEffort(power, start, end, updatedAvg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, power) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = power.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, power);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map((alt, i) => ` ${fmt(distanceKm[i],2)} km<br> ${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Altitudine'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n// Curve ordinate per potenza (sortedEfforts)\nsortedEfforts.forEach((eff, idx) => {\n    const sectionPower = power.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionTime = time.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    // Calcolo metriche aggiuntive come nel vecchio script\n    const sectionHR = heartrate.slice(eff.start, eff.end);\n    const sectionGrade = grade.slice(eff.start, eff.end);\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const dist = distance.slice(eff.start, eff.end);\n    const distTot = dist[dist.length - 1] - dist[0];\n    const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n    const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n    const vam = elevationGain / (climbTimeInSeconds / 3600);\n    const avgGrade = elevationGain / distTot * 100;\n    const gradientFactor = 2 + (avgGrade / 10);\n    const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n    let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n    if (sectionPower.length) {\n        const half = Math.floor(sectionPower.length / 2);\n        avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n        avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n        wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n    }\n    const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n    const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n    const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n    const startTime = sectionTime.length ? sectionTime[0] : '';\n    let best5sWatt = '', best5sWattKg = '';\n    let avgPowerPerKg = 0;\n    if (sectionPower.length >= 5 && weight > 0) {\n        const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n        best5sWatt = Math.round(maxW);\n        best5sWattKg = fmt(maxW / weight, 2);\n        avgPowerPerKg = avgPower / weight;\n    }\n    let joules = 0, joulesOverCP = 0;\n    if (power && time && eff.start !== undefined && eff.start < power.length && FTP) {\n        for (let i = 0; i < eff.start; i++) {\n            const w = power[i];\n            const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n            if (secs < 30) {\n                joules += w * secs;\n                if (w >= FTP) joulesOverCP += w * secs;\n            }\n        }\n    }\n    const hours = (time && eff.start !== undefined && time[eff.start]) ? (time[eff.start] / 3600) : 0;\n    const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n    const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n    function formatSecondsToHHMMSS(seconds) {\n        const sec = Math.floor(seconds % 60);\n        const min = Math.floor((seconds / 60) % 60);\n        const hr = Math.floor(seconds / 3600);\n        return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n    }\n    const effortDurationSec = climbTimeInSeconds;\n    function formatMMSS(seconds) {\n        const min = Math.floor(seconds / 60);\n        const sec = Math.floor(seconds % 60);\n        return `${min}:${sec.toString().padStart(2, '0')}`;\n    }\n    const traceText = [\n        (() => {\n            const sectionCadence = getStreamData(\"cadence\").slice(eff.start, eff.end);\n            const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n            return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n        })(),\n        (() => {\n            const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n            const percFTP = FTP ? ((avgPower / FTP) * 100) : 0;\n            return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''} | ${fmt(percFTP,0)}%`;\n        })(),\n        ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n        ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n        ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n        ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n        (() => {\n            if (avgGrade >= 4.5) {\n                const diffVAM = Math.abs(vamTeorico - vam);\n                let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n            } else {\n                return ` ${fmt(vam,0)} m/h`;\n            }\n        })(),\n        (() => {\n            if (avgGrade >= 4.5) {\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n            } else {\n                return '';\n            }\n        })(),\n        ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n        ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n    ].filter(Boolean).join('<br>');\n    traces.push({\n        x: sectionDistanceKm,\n        y: sectionAltitude,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n        hoverinfo: 'text',\n        visible: true,\n        hoverlabel: { align: 'left' },\n        text: traceText\n    });\n});\n\n// Annotazioni alternate sopra/sotto secondo ordine temporale\nconst globalMaxAlt = Math.max(...altitude);\nconst globalMinAlt = Math.min(...altitude);\nconst altRange = globalMaxAlt - globalMinAlt;\n\neffortsWithIndex.forEach((eff, idx) => {\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    const effortDurationSec = time[eff.end - 1] - time[eff.start] + 1;\n\n    // Offset percentuali rispetto al range di altitudine\n    const offsetsPerc = [0.25, 0.65, -0.1, -0.5]; // sopra: +10%, +3%; sotto: -3%, -10%\n    const yAnn = (eff.originalIdx % 4 < 2)\n        ? globalMaxAlt + offsetsPerc[eff.originalIdx % 4] * altRange\n        : globalMinAlt + offsetsPerc[eff.originalIdx % 4] * altRange;\n    annotations.push({\n        x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n        y: yAnn,\n        text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n        showarrow: false,\n        font: { family: 'Arial', size: 12, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        opacity: 0.9\n    });\n});\n\n    const configTitle =\n`<b>EFFORT</b> <b>|</b> ` +\n`<span style='color:#000000ff'>MRG [${MERGE_POWER_DIFF_PERCENT}%]</span> ` +\n`<span style='color:#000000ff'>WIN [${WINDOW_SECONDS}s]</span> ` +\n`<span style='color:#000000ff'>MIN [${MIN_EFFORT_INTENSITY_FTP}%FTP]</span> <b>|</b> ` +\n`<span style='color:#ff0000'>TRIM [${TRIM_WINDOW_SECONDS}s, ${TRIM_LOW_PERCENT}%]</span> ` +\n`<span style='color:#1901f5ff'> [${EXTEND_WINDOW_SECONDS}s, ${EXTEND_LOW_PERCENT}%]</span>`;\n    const layout = {\n        title: { text: configTitle, font: { color: '#222', size: 18 }, },\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "prot8%"
      },
      "usage_count": 0,
      "index": 48,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-11T14:22:37.277+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 884379,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "SSW'",
      "description": null,
      "image": null,
      "content": {
        "id": "yg3euh7n",
        "name": "SSW'",
        "plots": [
          {
            "id": 7,
            "agg": "fitness_avg",
            "min": 0,
            "band": 0,
            "fill": "#ff7f0e80",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "FITNESS",
            "type": "line",
            "field": "ss_w_prime",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "Glycolytic strain score",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#ff7f0eff",
            "filters": [],
            "i18nKey": "SS Wprime",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "ss_w_prime_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 8,
            "agg": "fatique_avg",
            "min": 0,
            "band": 0,
            "fill": "#ff7f0e80",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "FAT",
            "type": "line",
            "field": "ss_w_prime",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "Glycolytic strain score",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#ff7f0eff",
            "filters": [],
            "i18nKey": "SS Wprime",
            "markerValue": "right",
            "strokeWidth": 1.1,
            "i18nTitleKey": "ss_w_prime_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 9,
            "agg": "moving_avg",
            "min": 0,
            "band": 0,
            "fill": "#ff7f0e26",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "7D",
            "type": "bars",
            "field": "ss_w_prime",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "Glycolytic strain score",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(255,127,14)",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "SS Wprime",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "ss_w_prime_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 10,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#0e7bf100",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "DAY",
            "type": "dot",
            "field": "ss_w_prime",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "Glycolytic strain score",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [],
            "i18nKey": "SS Wprime",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "ss_w_prime_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "SSW'",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "",
        "y2AxisLabel": "",
        "stackTo100Percent": false
      },
      "usage_count": 0,
      "index": 48,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-30T20:47:05.016+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659181,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "3s over 600",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover600",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 600\nwindow = 3\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "3s over 600"
      },
      "usage_count": 33,
      "index": 49,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T10:34:17.870+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 726186,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "prot10PIXEL",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 90; // Soglia minima intensit (% FTP)\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n\n    // Limatura\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura (% della media effort)\n    // Estensione\n    const EXTEND_WINDOW_SECONDS = 15;    // Finestra estensione (s)\n    const EXTEND_LOW_PERCENT = 80;       // Soglia estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Limatura inizio/fine effort con finestre da TRIM_WINDOW_SECONDS\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n\n    // 1. Crea finestre fisse\n    let efforts = mergeConsecutiveWindows(power, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT);\n\n    // 2. Applica limatura PRIMA del merge (con parametri limatura)\n    efforts = efforts.map(eff => {\n        const trimmed = trimEffort(power, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    // 3. Filtra solo effort sopra la soglia percentuale di FTP\n    efforts = efforts.filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    // (estensione con parametri estensione)\n    function mergeEffortsPostTrim(efforts, power, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = power.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, power, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda (con parametri estensione)\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - EXTEND_WINDOW_SECONDS >= 0) {\n                const extWin = power.slice(start - EXTEND_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    start -= EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + EXTEND_WINDOW_SECONDS <= power.length) {\n                const extWin = power.slice(end, end + EXTEND_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = power.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    end += EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione (con parametri limatura)\n        // Calcola la media aggiornata dopo l'estensione\n        const updatedPower = power.slice(start, end);\n        const updatedAvg = updatedPower.reduce((a,b)=>a+b,0) / (updatedPower.length || 1);\n        const trimmed = trimEffort(power, start, end, updatedAvg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = power.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, power) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = power.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = power.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = power.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, power);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map((alt, i) => ` ${fmt(distanceKm[i],2)} km<br> ${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Altitudine'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n// Curve ordinate per potenza (sortedEfforts)\nsortedEfforts.forEach((eff, idx) => {\n    const sectionPower = power.slice(eff.start, eff.end);\n    const sectionAltitude = altitude.slice(eff.start, eff.end);\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const sectionTime = time.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    // Calcolo metriche aggiuntive come nel vecchio script\n    const sectionHR = heartrate.slice(eff.start, eff.end);\n    const sectionGrade = grade.slice(eff.start, eff.end);\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const dist = distance.slice(eff.start, eff.end);\n    const distTot = dist[dist.length - 1] - dist[0];\n    const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n    const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n    const vam = elevationGain / (climbTimeInSeconds / 3600);\n    const avgGrade = elevationGain / distTot * 100;\n    const gradientFactor = 2 + (avgGrade / 10);\n    const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n    let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n    if (sectionPower.length) {\n        const half = Math.floor(sectionPower.length / 2);\n        avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n        avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n        wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n    }\n    const avgHR = sectionHR.length ? sectionHR.reduce((a,b)=>a+b,0)/sectionHR.length : 0;\n    const maxHR = sectionHR.length ? Math.max(...sectionHR) : 0;\n    const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n    const startTime = sectionTime.length ? sectionTime[0] : '';\n    let best5sWatt = '', best5sWattKg = '';\n    let avgPowerPerKg = 0;\n    if (sectionPower.length >= 5 && weight > 0) {\n        const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n        best5sWatt = Math.round(maxW);\n        best5sWattKg = fmt(maxW / weight, 2);\n        avgPowerPerKg = avgPower / weight;\n    }\n    let joules = 0, joulesOverCP = 0;\n    if (power && time && eff.start !== undefined && eff.start < power.length && FTP) {\n        for (let i = 0; i < eff.start; i++) {\n            const w = power[i];\n            const secs = time[i] - (i > 0 ? time[i - 1] : 0);\n            if (secs < 30) {\n                joules += w * secs;\n                if (w >= FTP) joulesOverCP += w * secs;\n            }\n        }\n    }\n    const hours = (time && eff.start !== undefined && time[eff.start]) ? (time[eff.start] / 3600) : 0;\n    const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n    const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n    function formatSecondsToHHMMSS(seconds) {\n        const sec = Math.floor(seconds % 60);\n        const min = Math.floor((seconds / 60) % 60);\n        const hr = Math.floor(seconds / 3600);\n        return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n    }\n    const effortDurationSec = climbTimeInSeconds;\n    function formatMMSS(seconds) {\n        const min = Math.floor(seconds / 60);\n        const sec = Math.floor(seconds % 60);\n        return `${min}:${sec.toString().padStart(2, '0')}`;\n    }\n    const traceText = [\n        (() => {\n            const sectionCadence = getStreamData(\"cadence\").slice(eff.start, eff.end);\n            const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n            return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n        })(),\n        (() => {\n            const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n            const percFTP = FTP ? ((avgPower / FTP) * 100) : 0;\n            return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''} | ${fmt(percFTP,0)}%`;\n        })(),\n        ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n        ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n        ` ${fmt(avgHR)} bpm |${maxHR} bpm`,\n        ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n        (() => {\n            if (avgGrade >= 4.5) {\n                const diffVAM = Math.abs(vamTeorico - vam);\n                let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n            } else {\n                return ` ${fmt(vam,0)} m/h`;\n            }\n        })(),\n        (() => {\n            if (avgGrade >= 4.5) {\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n            } else {\n                return '';\n            }\n        })(),\n        ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n        ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n    ].filter(Boolean).join('<br>');\n    traces.push({\n        x: sectionDistanceKm,\n        y: sectionAltitude,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n        hoverinfo: 'text',\n        visible: true,\n        hoverlabel: { align: 'left' },\n        text: traceText\n    });\n});\n\n// Annotazioni alternate sopra/sotto secondo ordine temporale\nconst globalMaxAlt = Math.max(...altitude);\nconst globalMinAlt = Math.min(...altitude);\nconst altRange = globalMaxAlt - globalMinAlt;\n\n// Annotazioni a triplette basso-medio-alto in coordinate 'paper'\nconst yTriplet = [1, 0.5, 0.8]; // basso, medio, alto\neffortsWithIndex.forEach((eff, idx) => {\n    const sectionDistanceKm = distanceKm.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    const effortDurationSec = time[eff.end - 1] - time[eff.start] + 1;\n    const yAnn = yTriplet[eff.originalIdx % 3];\n    annotations.push({\n        x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n        yref: 'paper',\n        y: yAnn,\n        text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n        showarrow: false,\n        font: { family: 'Arial', size: 12, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        opacity: 0.9\n    });\n});\n\n    const configTitle =\n`<b>EFFORT</b> <b>|</b> ` +\n`<span style='color:#000000ff'>MRG [${MERGE_POWER_DIFF_PERCENT}%]</span> ` +\n`<span style='color:#000000ff'>WIN [${WINDOW_SECONDS}s]</span> ` +\n`<span style='color:#000000ff'>MIN [${MIN_EFFORT_INTENSITY_FTP}%FTP]</span> <b>|</b> ` +\n`<span style='color:#ff0000'>TRIM [${TRIM_WINDOW_SECONDS}s, ${TRIM_LOW_PERCENT}%]</span> ` +\n`<span style='color:#1901f5ff'> [${EXTEND_WINDOW_SECONDS}s, ${EXTEND_LOW_PERCENT}%]</span>`;\n    // Calcolo nuovo range per l'asse y\n    const minAlt = Math.min(...altitude);\n    const maxAlt = Math.max(...altitude);\n    // Minimo: multiplo di 200 inferiore a (minAlt - 200)\n    const yMin = Math.floor((minAlt - 200) / 200) * 200;\n    // Massimo: multiplo di 200 superiore a (maxAlt + 200)\n    const yMax = Math.ceil((maxAlt + 200) / 200) * 200;\n    const layout = {\n        title: { text: configTitle, font: { color: '#222', size: 18 }, },\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)', range: [yMin, yMax] },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "prot10PIXEL"
      },
      "usage_count": 0,
      "index": 49,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-11T14:22:26.246+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 884378,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "SSPmax",
      "description": null,
      "image": null,
      "content": {
        "id": "fmgne9qp",
        "name": "SSPmax",
        "plots": [
          {
            "id": 7,
            "agg": "fitness_avg",
            "min": 0,
            "band": 0,
            "fill": "#dd044780",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "FITNESS",
            "type": "line",
            "field": "ss_p_max",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "PCr strain score",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "filters": [],
            "i18nKey": "SS Pmax",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "ss_p_max_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 8,
            "agg": "fatique_avg",
            "min": 0,
            "band": 0,
            "fill": "#dd044780",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "FAT",
            "type": "line",
            "field": "ss_p_max",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "PCr strain score",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "filters": [],
            "i18nKey": "SS Pmax",
            "markerValue": "right",
            "strokeWidth": 1.1,
            "i18nTitleKey": "ss_p_max_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 9,
            "agg": "moving_avg",
            "min": 0,
            "band": 0,
            "fill": "#dd044726",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "7D",
            "type": "bars",
            "field": "ss_p_max",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "PCr strain score",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "aggArgs": {
              "days": 7,
              "factor": 1
            },
            "filters": [],
            "i18nKey": "SS Pmax",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "ss_p_max_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 10,
            "agg": "none",
            "min": 0,
            "band": 0,
            "fill": "#d6272800",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "DAY",
            "type": "dot",
            "field": "ss_p_max",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "PCr strain score",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "#000000ff",
            "filters": [],
            "i18nKey": "SS Pmax",
            "markerValue": "right",
            "strokeWidth": 1,
            "i18nTitleKey": "ss_p_max_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "SSPmax",
        "height": 275,
        "yAxisMax": null,
        "yAxisMin": null,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "",
        "y2AxisLabel": "",
        "stackTo100Percent": false
      },
      "usage_count": 0,
      "index": 49,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-30T20:48:20.927+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659182,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "5s over 600",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "S5over600",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 600\nwindow = 5\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "5s over 600"
      },
      "usage_count": 34,
      "index": 50,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T10:35:09.805+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 730882,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "prot 70",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(() => {\n\n    // === CONFIGURAZIONE INIZIALE ===\n\n    // Filtro intervallo temporale (secondi o 'hh:mm:ss')\n    const FILTER_START_RAW = '2400';   // start time (es: '1:07:04', 3600, h ecc)\n    const FILTER_END_RAW = '60000';  // end time (es: '2:01:04', 6400, h ecc)\n\n    // Parametri principali\n    const MERGE_POWER_DIFF_PERCENT = 15; // % diff. potenza per unire sezioni (es: 15)\n    const WINDOW_SECONDS = 60;           // Durata finestra analisi (s)\n    const MIN_EFFORT_INTENSITY_FTP = 100; // Soglia minima intensit (% FTP)\n\n    // Limatura\n    const TRIM_WINDOW_SECONDS = 10;      // Finestra limatura (s)\n    const TRIM_LOW_PERCENT = 85;         // Soglia limatura (% della media effort)\n    // Estensione\n    const EXTEND_WINDOW_SECONDS = 15;    // Finestra estensione (s)\n    const EXTEND_LOW_PERCENT = 80;       // Soglia estensione (% della media effort)\n\n    // Colori zone potenza\n    const ZONE_COLORS = [\n        { threshold: 106, color: \"#1f77b4\", label: \"CPjust above\" },\n        { threshold: 116, color: \"#3eb33eff\", label: \"Threshold+\" },\n        { threshold: 126, color: \"#ff7f0e\", label: \"VOmax\" },\n        { threshold: 136, color: \"#da2fbdff\", label: \"High VOmax / MAP\" },\n        { threshold: 151, color: \"#7315caff\", label: \"Supra-MAP\" },\n    ];\n    const ZONE_COLOR_DEFAULT = { color: \"#000000ff\", label: \"Anaerobico\" };\n\n    // Utility\n    const FTP = icu.activity.icu_ftp;    // FTP dell'attivit\n    const fmt = (num, digits = 0) => Number(num).toFixed(digits);\n    // === FINE CONFIGURAZIONE ===\n\n        // Funzione per convertire 'hh:mm:ss' o secondi in secondi\n    function parseTimeToSeconds(val) {\n        if (typeof val === 'number') return val;\n        if (typeof val === 'string') {\n            if (/^\\d+$/.test(val)) return Number(val);\n            // hh:mm:ss\n            if (/^\\d{1,2}:\\d{1,2}:\\d{1,2}$/.test(val)) {\n                const parts = val.split(':').map(Number);\n                return parts[0] * 3600 + parts[1] * 60 + parts[2];\n            }\n            // mm:ss\n            if (/^\\d{1,2}:\\d{1,2}$/.test(val)) {\n                const parts = val.split(':').map(Number);\n                return parts[0] * 60 + parts[1];\n            }\n            // 1h07m04s\n            if (/^(\\d+h)?(\\d+m)?(\\d+s)?$/.test(val.replace(/\\s+/g, ''))) {\n                let h = 0, m = 0, s = 0;\n                const matchH = val.match(/(\\d+)h/);\n                const matchM = val.match(/(\\d+)m/);\n                const matchS = val.match(/(\\d+)s/);\n                if (matchH) h = Number(matchH[1]);\n                if (matchM) m = Number(matchM[1]);\n                if (matchS) s = Number(matchS[1]);\n                return h * 3600 + m * 60 + s;\n            }\n            // Solo secondi\n            if (/^\\d+s$/.test(val)) return Number(val.replace('s',''));\n            // Solo minuti\n            if (/^\\d+m$/.test(val)) return Number(val.replace('m','')) * 60;\n            // Solo ore\n            if (/^\\d+h$/.test(val)) return Number(val.replace('h','')) * 3600;\n        }\n        return 0;\n    }\n\n    const FILTER_START_SEC = parseTimeToSeconds(FILTER_START_RAW);\n    const FILTER_END_SEC = parseTimeToSeconds(FILTER_END_RAW);\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n\n    // Filtra i dati in base all'intervallo selezionato\n    // Trova gli indici di inizio/fine del filtro\n    let filterStartIdx = time.findIndex(t => t >= FILTER_START_SEC);\n    let filterEndIdx = time.length - 1;\n    for (let i = filterStartIdx; i < time.length; i++) {\n        if (time[i] > FILTER_END_SEC) {\n            filterEndIdx = i - 1;\n            break;\n        }\n    }\n    if (filterStartIdx === -1) filterStartIdx = 0;\n    if (filterEndIdx < filterStartIdx) filterEndIdx = filterStartIdx;\n\n    // Taglia tutti gli array\n    const altitudeF = altitude.slice(filterStartIdx, filterEndIdx + 1);\n    const distanceF = distance.slice(filterStartIdx, filterEndIdx + 1);\n    const distanceKmF = distanceKm.slice(filterStartIdx, filterEndIdx + 1);\n    const powerF = power.slice(filterStartIdx, filterEndIdx + 1);\n    const heartrateF = heartrate.slice(filterStartIdx, filterEndIdx + 1);\n    const gradeF = grade.slice(filterStartIdx, filterEndIdx + 1);\n    const timeF = time.slice(filterStartIdx, filterEndIdx + 1);\n\n    function getZoneColor(avgPower, FTP) {\n        if (!FTP || FTP <= 0) return 'grey';\n        const percentage = (avgPower / FTP) * 100;\n        for (const zone of ZONE_COLORS) {\n            if (percentage < zone.threshold) return zone.color;\n        }\n        return ZONE_COLOR_DEFAULT.color;\n    }\n\n\n    // --- LOGICA: finestre NON sovrapposte da WINDOW_SECONDS (step = window) + MERGE ---\n    function mergeConsecutiveWindows(power, windowSec, mergePercent) {\n        const samplingRate = 1; // 1Hz\n        const windowSize = windowSec * samplingRate;\n        const windows = [];\n        for (let i = 0; i <= power.length - windowSize; i += windowSize) {\n            let sum = 0;\n            for (let j = 0; j < windowSize; j++) sum += power[i + j];\n            let avg = sum / windowSize;\n            windows.push({ start: i, end: i + windowSize, sum, avg, len: windowSize });\n        }\n        // Merge consecutive windows se la differenza percentuale  sotto soglia\n        const efforts = [];\n        let idx = 0;\n        while (idx < windows.length) {\n            let curr = windows[idx];\n            let sum = curr.sum;\n            let len = curr.len;\n            let start = curr.start;\n            let end = curr.end;\n            let avg = curr.avg;\n            let nextIdx = idx + 1;\n            while (nextIdx < windows.length) {\n                let next = windows[nextIdx];\n                let diff = Math.abs(next.avg - avg);\n                let percDiff = avg !== 0 ? (diff / avg) * 100 : 0;\n                if (percDiff <= mergePercent) {\n                    sum += next.sum;\n                    len += next.len;\n                    end = next.end;\n                    avg = sum / len;\n                    nextIdx++;\n                } else {\n                    break;\n                }\n            }\n            efforts.push({ start, end, avg });\n            idx = nextIdx;\n        }\n        return efforts;\n    }\n\n    // Limatura inizio/fine effort con finestre da TRIM_WINDOW_SECONDS\n    function trimEffort(power, start, end, avg, trimWindowSec, trimLowPercent) {\n        const samplingRate = 1; // 1Hz\n        const trimWindow = trimWindowSec * samplingRate;\n        let newStart = start;\n        let newEnd = end;\n        let canTrim = true;\n        while (canTrim && newEnd - newStart >= trimWindow * 2) {\n            canTrim = false;\n            // Limatura inizio\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newStart, newStart + trimWindow);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newStart += trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n            // Limatura fine\n            while (newEnd - newStart >= trimWindow * 2) {\n                const currPower = power.slice(newStart, newEnd);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                const win = power.slice(newEnd - trimWindow, newEnd);\n                const winAvg = win.reduce((a,b)=>a+b,0) / win.length;\n                if (winAvg < (trimLowPercent / 100) * currAvg) {\n                    newEnd -= trimWindow;\n                    canTrim = true;\n                } else {\n                    break;\n                }\n            }\n        }\n        // Se la limatura ha eliminato tutto, restituisci l'effort originale\n        if (newEnd - newStart < trimWindow * 2) return { start, end };\n        return { start: newStart, end: newEnd };\n    }\n\n\n    // 1. Crea finestre fisse\n    // Gli effort sono gi filtrati sull'intervallo, non serve ulteriore filtro\n    let efforts = mergeConsecutiveWindows(powerF, WINDOW_SECONDS, MERGE_POWER_DIFF_PERCENT);\n\n    // 2. Applica limatura PRIMA del merge (con parametri limatura)\n    efforts = efforts.map(eff => {\n        const trimmed = trimEffort(powerF, eff.start, eff.end, eff.avg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = powerF.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    // 3. Filtra solo effort sopra la soglia percentuale di FTP\n    efforts = efforts.filter(eff => eff.avg > (MIN_EFFORT_INTENSITY_FTP / 100) * FTP);\n    // Filtra gli effort che iniziano nell'intervallo selezionato\n    efforts = efforts.filter(eff => timeF[eff.start] >= FILTER_START_SEC && timeF[eff.start] <= FILTER_END_SEC);\n\n    // Merge + estensione iterativi finch la lista non cambia pi\n    // (estensione con parametri estensione)\n    function mergeEffortsPostTrim(efforts, powerF, mergePercent) {\n        if (efforts.length === 0) return [];\n        // Ordina per inizio\n        const sorted = efforts.slice().sort((a, b) => a.start - b.start);\n        const merged = [];\n        let curr = { ...sorted[0] };\n        for (let i = 1; i < sorted.length; i++) {\n            const next = sorted[i];\n            // Unisci se si sovrappongono anche solo parzialmente (next.start < curr.end)\n            if (next.start < curr.end) {\n                const allPower = powerF.slice(Math.min(curr.start, next.start), Math.max(curr.end, next.end));\n                const avg = allPower.reduce((a,b)=>a+b,0) / allPower.length;\n                const percDiff = Math.abs(curr.avg - next.avg) / ((curr.avg + next.avg) / 2) * 100;\n                if (percDiff <= mergePercent) {\n                    curr.start = Math.min(curr.start, next.start);\n                    curr.end = Math.max(curr.end, next.end);\n                    curr.avg = avg;\n                    continue;\n                }\n            }\n            merged.push(curr);\n            curr = { ...next };\n        }\n        merged.push(curr);\n        return merged;\n    }\n\nlet changed = true;\nwhile (changed) {\n    changed = false;\n    const prevEfforts = JSON.stringify(efforts);\n    // Merge\n    efforts = mergeEffortsPostTrim(efforts, powerF, MERGE_POWER_DIFF_PERCENT);\n    // Estensione in testa e in coda (con parametri estensione)\n    efforts = efforts.map(eff => {\n        let { start, end } = eff;\n        // Estensione in testa\n        let extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (start - EXTEND_WINDOW_SECONDS >= 0) {\n                const extWin = powerF.slice(start - EXTEND_WINDOW_SECONDS, start);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = powerF.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    start -= EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Estensione in coda\n        extChanged = true;\n        while (extChanged) {\n            extChanged = false;\n            if (end + EXTEND_WINDOW_SECONDS <= powerF.length) {\n                const extWin = powerF.slice(end, end + EXTEND_WINDOW_SECONDS);\n                const extAvg = extWin.reduce((a,b)=>a+b,0) / extWin.length;\n                const currPower = powerF.slice(start, end);\n                const currAvg = currPower.reduce((a,b)=>a+b,0) / (currPower.length || 1);\n                if (extAvg >= (EXTEND_LOW_PERCENT / 100) * currAvg) {\n                    end += EXTEND_WINDOW_SECONDS;\n                    extChanged = true;\n                }\n            }\n        }\n        // Limatura dopo merge+estensione (con parametri limatura)\n        // Calcola la media aggiornata dopo l'estensione\n        const updatedPower = powerF.slice(start, end);\n        const updatedAvg = updatedPower.reduce((a,b)=>a+b,0) / (updatedPower.length || 1);\n        const trimmed = trimEffort(powerF, start, end, updatedAvg, TRIM_WINDOW_SECONDS, TRIM_LOW_PERCENT);\n        const trimmedPower = powerF.slice(trimmed.start, trimmed.end);\n        const trimmedAvg = trimmedPower.reduce((a,b)=>a+b,0) / (trimmedPower.length || 1);\n        return { ...eff, start: trimmed.start, end: trimmed.end, avg: trimmedAvg };\n    });\n\n    if (JSON.stringify(efforts) !== prevEfforts) changed = true;\n}\n\n// --- SPLIT: se un effort  completamente contenuto in un altro, splitta il pi lungo in 3 parti ---\n\nfunction splitEffortsOnInclusion(efforts, powerF) {\n    // Ordina per inizio\n    let result = efforts.slice().sort((a, b) => a.start - b.start);\n    let changed = true;\n    while (changed) {\n        changed = false;\n        outer: for (let i = 0; i < result.length; i++) {\n            for (let j = 0; j < result.length; j++) {\n                if (i === j) continue;\n                const a = result[i];\n                const b = result[j];\n                // b  incluso in a (anche se inizia o finisce nello stesso punto, ma non entrambi)\n                if (\n                    a.start < b.start && b.end < a.end && b.start < b.end\n                    // b completamente dentro a\n                ) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = powerF.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = powerF.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    // Sostituisci a e b con i nuovi segmenti\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // b inizia o finisce esattamente come a (ma non entrambi)\n                // Caso 1: b.start === a.start && b.end < a.end\n                if (b.start === a.start && b.end < a.end) {\n                    const newEfforts = [];\n                    // b stesso\n                    newEfforts.push(b);\n                    // Dopo b\n                    if (b.end < a.end) {\n                        const pow2 = powerF.slice(b.end, a.end);\n                        if (pow2.length > 0) {\n                            newEfforts.push({ start: b.end, end: a.end, avg: pow2.reduce((x,y)=>x+y,0)/pow2.length });\n                        }\n                    }\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n                // Caso 2: b.end === a.end && b.start > a.start\n                if (b.end === a.end && b.start > a.start) {\n                    const newEfforts = [];\n                    // Prima di b\n                    if (b.start > a.start) {\n                        const pow1 = powerF.slice(a.start, b.start);\n                        if (pow1.length > 0) {\n                            newEfforts.push({ start: a.start, end: b.start, avg: pow1.reduce((x,y)=>x+y,0)/pow1.length });\n                        }\n                    }\n                    // b stesso\n                    newEfforts.push(b);\n                    result = result.filter((_, idx) => idx !== i && idx !== j).concat(newEfforts);\n                    result = result.sort((x, y) => x.start - y.start);\n                    changed = true;\n                    break outer;\n                }\n            }\n        }\n    }\n    // Dopo lo split, assicurati che non ci siano sovrapposizioni: end deve essere sempre <= start del successivo\n    result = result.sort((a, b) => a.start - b.start);\n    for (let i = 1; i < result.length; i++) {\n        if (result[i].start < result[i-1].end) {\n            result[i].start = result[i-1].end;\n            // Ricalcola avg se necessario\n            const pow = powerF.slice(result[i].start, result[i].end);\n            result[i].avg = pow.length > 0 ? pow.reduce((x,y)=>x+y,0)/pow.length : 0;\n        }\n    }\n    return result;\n}\n\nefforts = splitEffortsOnInclusion(efforts, powerF);\n\n    // (Logica di accorpamento in testa rimossa: lasciamo solo limatura ed estensione in coda)\n\n    // --- GRAFICO ---\n    const traces = [\n        {\n            x: distanceKmF,\n            y: altitudeF,\n            text: altitudeF.map((alt, i) => ` ${fmt(distanceKmF[i],2)} km<br> ${fmt(alt,1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Altitudine'\n        }\n    ];\n    const annotations = [];\n    // Associa a ogni effort il suo indice temporale originale\n    const effortsWithIndex = efforts.map((eff, idx) => ({ ...eff, originalIdx: idx }));\n    // Ordina per watt decrescente SOLO per la legenda\n    const sortedEfforts = effortsWithIndex.slice().sort((a, b) => b.avg - a.avg);\n// Curve ordinate per potenza (sortedEfforts)\nsortedEfforts.forEach((eff, idx) => {\n    const sectionPower = powerF.slice(eff.start, eff.end);\n    const sectionAltitude = altitudeF.slice(eff.start, eff.end);\n    const sectionDistanceKm = distanceKmF.slice(eff.start, eff.end);\n    const sectionTime = timeF.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    // Calcolo metriche aggiuntive come nel vecchio script\n    const sectionHR = heartrateF.slice(eff.start, eff.end);\n    const sectionGrade = gradeF.slice(eff.start, eff.end);\n    const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n    const dist = distanceF.slice(eff.start, eff.end);\n    const distTot = dist[dist.length - 1] - dist[0];\n    const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n    const avgSpeed = distTot / (climbTimeInSeconds / 3600) / 1000;\n    const vam = elevationGain / (climbTimeInSeconds / 3600);\n    const avgGrade = elevationGain / distTot * 100;\n    const gradientFactor = 2 + (avgGrade / 10);\n    const vamTeorico = (avgPower / weight) * (gradientFactor * 100);\n    let avgWattsFirstHalf = 0, avgWattsSecondHalf = 0, wattsRatio = 0;\n    if (sectionPower.length) {\n        const half = Math.floor(sectionPower.length / 2);\n        avgWattsFirstHalf = sectionPower.slice(0, half).reduce((a,b)=>a+b,0) / (half || 1);\n        avgWattsSecondHalf = sectionPower.slice(half).reduce((a,b)=>a+b,0) / (sectionPower.length - half || 1);\n        wattsRatio = avgWattsSecondHalf ? avgWattsFirstHalf / avgWattsSecondHalf : 0;\n    }\n    const validHR = sectionHR.filter(hr => hr > 0);\n    const avgHR = validHR.length ? validHR.reduce((a,b)=>a+b,0)/validHR.length : 0;\n    const maxHR = validHR.length ? Math.max(...validHR) : 0;\n    const maxGrade = sectionGrade.length ? Math.max(...sectionGrade) : 0;\n    const startTime = sectionTime.length ? sectionTime[0] : '';\n    let best5sWatt = '', best5sWattKg = '';\n    let avgPowerPerKg = 0;\n    if (sectionPower.length >= 5 && weight > 0) {\n        const maxW = Math.max(...Array.from({length: sectionPower.length - 4}, (_, i) => sectionPower.slice(i, i + 5).reduce((a,b)=>a+b,0)/5));\n        best5sWatt = Math.round(maxW);\n        best5sWattKg = fmt(maxW / weight, 2);\n        avgPowerPerKg = avgPower / weight;\n    }\n    // Calcolo kJ totali accumulati dall'inizio attivit (dati globali) fino all'inizio dell'effort\n    let joules = 0, joulesOverCP = 0;\n    if (power && time && eff.start > 0 && FTP) {\n        for (let i = 1; i < filterStartIdx + eff.start; i++) {\n            const w = power[i];\n            const secs = time[i] - time[i - 1];\n            if (secs > 0 && secs < 30) {\n                joules += w * secs;\n                if (w >= FTP) joulesOverCP += w * secs;\n            }\n        }\n    }\n    const hours = (time && eff.start !== undefined && time[filterStartIdx + eff.start]) ? (time[filterStartIdx + eff.start] / 3600) : 0;\n    const kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n    const kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n    function formatSecondsToHHMMSS(seconds) {\n        const sec = Math.floor(seconds % 60);\n        const min = Math.floor((seconds / 60) % 60);\n        const hr = Math.floor(seconds / 3600);\n        return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n    }\n    const effortDurationSec = climbTimeInSeconds;\n    function formatMMSS(seconds) {\n        const min = Math.floor(seconds / 60);\n        const sec = Math.floor(seconds % 60);\n        return `${min}:${sec.toString().padStart(2, '0')}`;\n    }\n    const traceText = [\n        (() => {\n            const sectionCadence = getStreamData(\"cadence\").slice(filterStartIdx + eff.start, filterStartIdx + eff.end);\n            const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : 0;\n            return ` ${fmt(avgPower)} W | 5\"${best5sWatt} W  ${fmt(avgCadence)} rpm`;\n        })(),\n        (() => {\n            const timeStr = startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '';\n            const percFTP = FTP ? ((avgPower / FTP) * 100) : 0;\n            return ` ${formatMMSS(effortDurationSec)}${timeStr ? ' | ' + timeStr : ''} | ${fmt(percFTP,0)}%`;\n        })(),\n        ` ${fmt(avgPowerPerKg,2)} W/kg | 5\"${best5sWattKg} W/kg`,\n        ` ${fmt(avgWattsFirstHalf)} W | ${fmt(avgWattsSecondHalf)} W | ${fmt(wattsRatio,2)}`,\n    (validHR.length ? ` ${fmt(avgHR)} bpm |${maxHR} bpm` : null),\n        ` ${fmt(avgSpeed,1)} km/h   ${fmt(avgGrade,1)}% |${fmt(maxGrade,1)}%`,\n        (() => {\n            if (avgGrade >= 4.5) {\n                const diffVAM = Math.abs(vamTeorico - vam);\n                let arrow = vamTeorico - vam > 0 ? '' : (vamTeorico - vam < 0 ? '' : '');\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                return ` ${fmt(vam,0)} m/h ${arrow} ${fmt(diffVAM,0)} m/h | ${fmt(Math.abs(diffWkg),2)} W/kg`;\n            } else {\n                return ` ${fmt(vam,0)} m/h`;\n            }\n        })(),\n        (() => {\n            if (avgGrade >= 4.5) {\n                const wkgteoric = vam / (gradientFactor * 100);\n                const diffWkg = avgPowerPerKg - wkgteoric;\n                const percErr = avgPowerPerKg !== 0 ? (diffWkg / avgPowerPerKg) * 100 : 0;\n                const sign = percErr > 0 ? '+' : (percErr < 0 ? '-' : '');\n                return ` ${fmt(vamTeorico,0)} m/h | ${fmt(wkgteoric,2)} W/kg | ${sign}${fmt(Math.abs(percErr),1)}%`;\n            } else {\n                return '';\n            }\n        })(),\n        ` ${fmt(joules/1000)} kJ | ${fmt(joulesOverCP/1000)} kJ > CP`,\n        ` ${fmt(kJ_h_kg,1)} kJ/h/kg | ${fmt(kJ_h_kg_overCP,1)} kJ/h/kg > CP`,\n    ].filter(Boolean).join('<br>');\n    traces.push({\n        x: sectionDistanceKm,\n        y: sectionAltitude,\n        type: 'scatter',\n        mode: 'lines',\n        line: { color: bgColor, width: 2 },\n        name: `${fmt(avgPower)} W | #${eff.originalIdx + 1}`,\n        hoverinfo: 'text',\n        visible: true,\n        hoverlabel: { align: 'left' },\n        text: traceText\n    });\n});\n\n// Annotazioni alternate sopra/sotto secondo ordine temporale\nconst globalMaxAlt = Math.max(...altitudeF);\nconst globalMinAlt = Math.min(...altitudeF);\nconst altRange = globalMaxAlt - globalMinAlt;\n\neffortsWithIndex.forEach((eff, idx) => {\n    const sectionDistanceKm = distanceKmF.slice(eff.start, eff.end);\n    const sectionAltitude = altitudeF.slice(eff.start, eff.end);\n    const avgPower = eff.avg;\n    const bgColor = getZoneColor(avgPower, FTP);\n    const effortDurationSec = timeF[eff.end - 1] - timeF[eff.start] + 1;\n\n    // Offset proporzionale al range di altitudine\n    const offsets = [0.25, 0.75, 1.25]; // percentuali del range\n    const yAnn = globalMaxAlt + offsets[eff.originalIdx % offsets.length] * altRange;\n    annotations.push({\n        x: (sectionDistanceKm[0] + sectionDistanceKm[sectionDistanceKm.length - 1]) / 2,\n        y: yAnn,\n        text: `#${eff.originalIdx + 1}<br> ${fmt(avgPower)}<br> ${fmt(effortDurationSec,0)}s`,\n        showarrow: false,\n        font: { family: 'Arial', size: 12, color: 'white' },\n        align: 'center',\n        bgcolor: bgColor,\n        opacity: 0.9\n    });\n});\n\n    const configTitle =\n`<b>EFFORT</b> <b>|</b> ` +\n`<span style='color:#000000ff'>MRG [${MERGE_POWER_DIFF_PERCENT}%]</span> ` +\n`<span style='color:#000000ff'>WIN [${WINDOW_SECONDS}s]</span> ` +\n`<span style='color:#000000ff'>MIN [${MIN_EFFORT_INTENSITY_FTP}%FTP]</span> <b>|</b> ` +\n`<span style='color:#ff0000'>TRIM [${TRIM_WINDOW_SECONDS}s, ${TRIM_LOW_PERCENT}%]</span> ` +\n`<span style='color:#1901f5ff'> [${EXTEND_WINDOW_SECONDS}s, ${EXTEND_LOW_PERCENT}%]</span>`;\n    const layout = {\n        title: { text: configTitle, font: { color: '#222', size: 18 }, },\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    return chart;\n})();",
        "name": "prot 70"
      },
      "usage_count": 0,
      "index": 50,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2026-01-09T20:55:28.104+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 884343,
      "athlete_id": "i115436",
      "type": "FITNESS_CHART",
      "visibility": "PRIVATE",
      "name": "SS Form",
      "description": null,
      "image": null,
      "content": {
        "id": "9is2j4ew",
        "name": "SS Form",
        "plots": [
          {
            "id": 4,
            "agg": "form_avg_percent",
            "min": 0,
            "band": 0,
            "fill": "rgba(0,158,0, 0.4)",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "SS CP",
            "type": "line",
            "field": "ss_cp",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "Aerobic strain score",
            "extras": [],
            "filter": "dec0",
            "radius": 3,
            "stroke": "rgb(0,158,0)",
            "filters": [],
            "i18nKey": "SS CP",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "ss_cp_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 5,
            "agg": "form_avg_percent",
            "min": 0,
            "band": 0,
            "fill": "rgba(255,127,14, 0.5)",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "SS W'",
            "type": "line",
            "field": "ss_w_prime",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "Glycolytic strain score",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(255,127,14)",
            "filters": [],
            "i18nKey": "SS Wprime",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "ss_w_prime_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          },
          {
            "id": 6,
            "agg": "form_avg_percent",
            "min": 0,
            "band": 0,
            "fill": "rgba(221,4,71,0.5)",
            "link": "https://forum.intervals.icu/t/three-dimensional-impulse-response-model/109644",
            "text": "SS Pmax",
            "type": "line",
            "field": "ss_p_max",
            "scale": "strain_score",
            "stack": "strain_score",
            "title": "PCr strain score",
            "extras": [],
            "filter": "dec1",
            "radius": 3,
            "stroke": "rgb(221,4,71)",
            "filters": [],
            "i18nKey": "SS Pmax",
            "markerValue": "right",
            "strokeWidth": 2,
            "i18nTitleKey": "ss_p_max_title",
            "showOnCalendar": false,
            "invertSubWellness": false
          }
        ],
        "title": "",
        "height": 165,
        "yAxisMax": 100.0,
        "yAxisMin": -150.0,
        "y2AxisMax": null,
        "y2AxisMin": null,
        "y3AxisMax": null,
        "y3AxisMin": null,
        "yAxisLabel": "SS Form",
        "y2AxisLabel": "",
        "stackTo100Percent": false
      },
      "usage_count": 0,
      "index": 50,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-30T20:49:15.646+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659184,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "3s over 650",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover650",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 650\nwindow = 3\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "3s over 650"
      },
      "usage_count": 33,
      "index": 51,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T10:35:32.877+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 786823,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "ssurges",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "(function() {\nconst CONFIG_surges = {\n// =====================\n// CONFIGURAZIONE PRINCIPALE\n// =====================\n  MIN_EFFORT_INTENSITY_FTP: 220,    // Soglia minima effort (% FTP)\n        // Rilevamento per secondo: considera solo secondi >= soglia\n        // MIN_SURGE_SECONDS: durata minima (in secondi) di un surge per essere considerato\n        MIN_SURGE_SECONDS: 3,\n        // Se due surges sono separati da meno di questo valore (secondi) vengono uniti\n        MERGE_GAP_SECONDS: 1,\n// ============================================================================\n  ZONES: [\n    { name: 'Z2', max: 251, color: '#4c72b0' },\n    { name: 'Z3', max: 301, color: '#55a868' },\n    { name: 'Z4', max: 351, color: '#dd8452' },\n    { name: 'Z5', max: 401, color: '#c44e52' },\n    { name: 'Z6', max: 451, color: '#a64d79' },\n    { name: 'Z7', max: Infinity, color: '#8172b3' }\n  ],\n  BAR_TEXT_COLOR: '#000000',\n  BAR_TEXT_FONT: { family: 'Arial Black', size: 13 },\n  GRID_X_COLOR: '#EEEEEE',\n  GRID_X_WIDTH: 1,\n  GRID_Y_COLOR: '#CCCCCC',\n  GRID_Y_WIDTH: 1,\n};\n// =====================\n// FINE CONFIGURAZIONE\n\n{\n    // Configurazione\n    const FTP = icu.activity.icu_ftp;\n\n    function getStreamData(streamName) {\n        const stream = icu.streams.get(streamName);\n        return stream && stream.data ? stream.data.map(value => value ?? 0) : Array(icu.streams.get(\"time\").data.length).fill(0);\n    }\n\n    const altitude = getStreamData(\"fixed_altitude\");\n    const distance = getStreamData(\"distance\");\n    const distanceKm = distance.map(d => d / 1000);\n    const power = getStreamData(\"fixed_watts\");\n    const heartrate = getStreamData(\"fixed_heartrate\");\n    const grade = getStreamData(\"grade_smooth\");\n    const time = getStreamData(\"time\");\n    const weight = icu.activity.icu_weight;\n        const cadence = getStreamData(\"cadence\");\n        const torque = getStreamData(\"torque\");\n\n    // Fix initial altitude values\n    const firstNonZeroAltitude = altitude.find(value => value !== 0);\n    if (firstNonZeroAltitude !== undefined) {\n        for (let i = 0; i < altitude.length; i++) {\n            if (altitude[i] === 0) {\n                altitude[i] = firstNonZeroAltitude;\n            } else {\n                break;\n            }\n        }\n    }\n\n    let traces = [\n        {\n            x: distanceKm,\n            y: altitude,\n            text: altitude.map(alt => `${alt.toFixed(1)} m`),\n            hoverinfo: 'text',\n            fill: 'tozeroy',\n            type: 'scatter',\n            fillcolor: 'whitesmoke',\n            mode: 'none',\n            name: 'Elevation'\n        }\n    ];\n    let annotations = [];\n    // Nuovo rilevamento: trova run di secondi sopra la soglia, scarta quelli corti (< MIN), poi unisce run vicini (gap <= MERGE_GAP_SECONDS)\n    // Compute typical sample interval (seconds) from `time` stream using median of deltas\n    function computeSampleInterval(timeArr) {\n        if (!timeArr || timeArr.length < 2) return 1;\n        const deltas = [];\n        for (let i = 1; i < timeArr.length; i++) {\n            const d = timeArr[i] - timeArr[i - 1];\n            if (d > 0 && isFinite(d)) deltas.push(d);\n        }\n        if (deltas.length === 0) return 1;\n        deltas.sort((a, b) => a - b);\n        const mid = Math.floor(deltas.length / 2);\n        return deltas.length % 2 === 1 ? deltas[mid] : (deltas[mid - 1] + deltas[mid]) / 2;\n    }\n\n    // Get clusters in samples (minSamples, mergeGapSamples are counts of samples)\n    function getSurgeClusters(data, threshold, minSamples = 3, mergeGapSamples = 3) {\n        const above = data.map(v => (v >= threshold));\n        const runs = [];\n        let i = 0;\n        while (i < above.length) {\n            if (above[i]) {\n                let start = i;\n                while (i + 1 < above.length && above[i + 1]) i++;\n                let end = i;\n                const len = end - start + 1;\n                if (len >= minSamples) runs.push({ start, end, length: len });\n            }\n            i++;\n        }\n\n        if (runs.length === 0) return [];\n\n        // Merge runs that are close (gap <= mergeGapSamples)\n        const clusters = [];\n        let current = { runs: [runs[0]], start: runs[0].start, end: runs[0].end };\n        for (let r = 1; r < runs.length; r++) {\n            const gap = runs[r].start - current.end - 1;\n            if (gap <= mergeGapSamples) {\n                current.runs.push(runs[r]);\n                current.end = runs[r].end;\n            } else {\n                clusters.push(current);\n                current = { runs: [runs[r]], start: runs[r].start, end: runs[r].end };\n            }\n        }\n        clusters.push(current);\n\n        // Compute aggregate stats for each cluster (avg weighted by sample count, total duration = sum of runs)\n        for (const cl of clusters) {\n            let totalSamples = 0;\n            let totalPower = 0;\n            for (const r of cl.runs) {\n                totalSamples += (r.end - r.start + 1);\n                for (let k = r.start; k <= r.end; k++) totalPower += data[k];\n            }\n            cl.avg = totalSamples > 0 ? totalPower / totalSamples : 0;\n            cl.duration = totalSamples; // in seconds since sampling 1Hz\n        }\n\n        return clusters;\n    }\n\n    const threshold = (CONFIG_surges.MIN_EFFORT_INTENSITY_FTP / 100) * FTP;\n    // Determine typical sample interval (seconds) and convert configured seconds to samples\n    const sampleInterval = computeSampleInterval(time) || 1; // sec per sample (float)\n    const minSamples = Math.max(1, Math.round(CONFIG_surges.MIN_SURGE_SECONDS / sampleInterval));\n    const mergeGapSamples = Math.max(0, Math.round(CONFIG_surges.MERGE_GAP_SECONDS / sampleInterval));\n    const clusters = getSurgeClusters(power, threshold, minSamples, mergeGapSamples);\n    // Sort clusters by avg power desc for legend order\n    const sortedClusters = clusters.slice().sort((a, b) => b.avg - a.avg);\n    sortedClusters.forEach((cluster, idx) => {\n    const avgPower = cluster.avg;\n    const bestStart = cluster.start;\n    const bestEnd = cluster.end + 1;\n    const displayDurationSec = Math.round(cluster.duration * sampleInterval);\n        // For metrics we need to aggregate across all runs in the cluster\n    let sectionPower = [];\n    let sectionHR = [];\n    let sectionAltitude = [];\n    let sectionDistance = [];\n    let sectionDistanceKm = [];\n    let sectionGrade = [];\n    let sectionTime = [];\n    let sectionCadence = [];\n    let sectionTorque = [];\n        for (const r of cluster.runs) {\n            sectionPower = sectionPower.concat(power.slice(r.start, r.end + 1));\n            sectionHR = sectionHR.concat(heartrate.slice(r.start, r.end + 1));\n            sectionAltitude = sectionAltitude.concat(altitude.slice(r.start, r.end + 1));\n            sectionDistance = sectionDistance.concat(distance.slice(r.start, r.end + 1));\n            sectionDistanceKm = sectionDistanceKm.concat(distanceKm.slice(r.start, r.end + 1));\n            sectionGrade = sectionGrade.concat(grade.slice(r.start, r.end + 1));\n            sectionTime = sectionTime.concat(time.slice(r.start, r.end + 1));\n            sectionCadence = sectionCadence.concat(cadence.slice(r.start, r.end + 1));\n            sectionTorque = sectionTorque.concat(torque.slice(r.start, r.end + 1));\n        }\n\n        // --- Metrics block ---\n    const minHR = Math.min(...sectionHR);\n    const maxHR = Math.max(...sectionHR);\n    // cadence and torque min/max (if streams available)\n    const minCadence = sectionCadence.length ? Math.min(...sectionCadence) : null;\n    const maxCadence = sectionCadence.length ? Math.max(...sectionCadence) : null;\n    const minTorque = sectionTorque.length ? Math.min(...sectionTorque) : null;\n    const maxTorque = sectionTorque.length ? Math.max(...sectionTorque) : null;\n        const elevationGain = sectionAltitude[sectionAltitude.length - 1] - sectionAltitude[0];\n        const dist = sectionDistance[sectionDistance.length - 1] - sectionDistance[0];\n        const avgGrade = elevationGain / dist * 100;\n        const avgPowerPerKg = avgPower / weight;\n        const maxGrade = Math.max(...sectionGrade);\n        const climbTimeInSeconds = sectionTime[sectionTime.length - 1] - sectionTime[0] + 1;\n        const ascentSpeed = elevationGain / (climbTimeInSeconds / 3600);\n        // --- Speed details ---\n        let v1 = '', v2 = '';\n        if (sectionDistanceKm.length >= 2) {\n            v1 = ((sectionDistanceKm[1] - sectionDistanceKm[0]) * 3600).toFixed(1); // km/h primo secondo\n            v2 = ((sectionDistanceKm[sectionDistanceKm.length-1] - sectionDistanceKm[sectionDistanceKm.length-2]) * 3600).toFixed(1); // km/h ultimo secondo\n        }\n        // --- Start time ---\n        let startTime = '';\n        if (sectionTime && sectionTime.length > 0) {\n            startTime = sectionTime[0].toFixed(1);\n        }\n        // --- Power min/max ---\n        let minWatt = null, maxWatt = null;\n        if (sectionPower.length > 0) {\n            minWatt = Math.min(...sectionPower);\n            maxWatt = Math.max(...sectionPower);\n        }\n        // averages for cadence and torque\n        const avgCadence = sectionCadence.length ? sectionCadence.reduce((a,b)=>a+b,0)/sectionCadence.length : null;\n        const avgTorque = sectionTorque.length ? sectionTorque.reduce((a,b)=>a+b,0)/sectionTorque.length : null;\n        // helper: find first global index in cluster where power equals value\n        function findIndexForPowerValue(cluster, value) {\n            if (value === null || value === undefined) return -1;\n            for (const r of cluster.runs) {\n                for (let k = r.start; k <= r.end; k++) {\n                    const p = power[k];\n                    if (Math.abs(p - value) < 1e-6) return k;\n                }\n            }\n            return -1;\n        }\n        const maxIdx = findIndexForPowerValue(cluster, maxWatt);\n        const minIdx = findIndexForPowerValue(cluster, minWatt);\n        const rpmAtMax = (maxIdx >= 0 && cadence && cadence[maxIdx] != null) ? Math.round(cadence[maxIdx]) : '';\n        const torqueAtMax = (maxIdx >= 0 && torque && torque[maxIdx] != null) ? Math.round(torque[maxIdx]) : '';\n        const rpmAtMin = (minIdx >= 0 && cadence && cadence[minIdx] != null) ? Math.round(cadence[minIdx]) : '';\n        const torqueAtMin = (minIdx >= 0 && torque && torque[minIdx] != null) ? Math.round(torque[minIdx]) : '';\n        // --- kJ and kJ/h/kg up to effort start ---\n        let bgColor = getZoneColor(avgPower, FTP);\n        if (bgColor && !bgColor.startsWith('#')) bgColor = '#' + bgColor;\n        let joules = 0, joulesOverCP = 0;\n        if (power && time && bestStart !== undefined && bestStart < power.length && FTP) {\n            for (let i = 0; i < bestStart; i++) {\n                let w = power[i];\n                let secs = time[i] - (i > 0 ? time[i - 1] : 0);\n                if (secs < 30) {\n                    joules += w * secs;\n                    if (w >= FTP) joulesOverCP += w * secs;\n                }\n            }\n        }\n        const hours = (time && bestStart !== undefined && time[bestStart]) ? (time[bestStart] / 3600) : 0;\n        let kJ_h_kg = (weight && hours > 0) ? (joules/1000) / hours / weight : 0;\n        let kJ_h_kg_overCP = (weight && hours > 0) ? (joulesOverCP/1000) / hours / weight : 0;\n        // --- Trace text layout (organized) ---\n        function formatSecondsToHHMMSS(seconds) {\n            const sec = Math.floor(seconds % 60);\n            const min = Math.floor((seconds / 60) % 60);\n            const hr = Math.floor(seconds / 3600);\n            return `${hr.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;\n        }\n        const traceText = [\n            `#${idx + 1}    ${avgCadence !== null ? Math.round(avgCadence) : ''} rpm | ${avgTorque !== null ? Math.round(avgTorque) : ''} Nm | ${displayDurationSec} s`,\n            ` ${maxWatt !== null ? maxWatt : ''} W at ${rpmAtMax} rpm @ ${torqueAtMax} Nm`,\n            ` ${minWatt !== null ? minWatt : ''} W at ${rpmAtMin} rpm @ ${torqueAtMin} Nm`,\n            ` ${minCadence !== null ? Math.round(maxCadence) : ''} rpm | ${maxCadence !== null ? Math.round(minCadence) : ''} rpm`,\n            ` ${minTorque !== null ? Math.round(maxTorque) : ''} Nm | ${maxTorque !== null ? Math.round(minTorque) : ''} Nm`,\n            ` ${minHR.toFixed(0)} bpm |${maxHR} bpm`,\n            v1 && v2 ? ` ${v1} km/h | ${v2} km/h` : '',\n            `  ${avgGrade.toFixed(1)}% max. ${maxGrade.toFixed(1)}%`,\n            startTime ? ` ${formatSecondsToHHMMSS(Number(startTime))}` : '',\n            ` ${Math.round(joules/1000)} kJ | ${Math.round(joulesOverCP/1000)} kJ > CP`,\n            ` ${kJ_h_kg.toFixed(1)} kJ/h/kg | ${kJ_h_kg_overCP.toFixed(1)} kJ/h/kg > CP`\n        ].filter(Boolean).join('<br>');\n        // Create one trace per run (subsegment) to avoid connecting below-threshold gaps\n        cluster.runs.forEach((r, runIdx) => {\n            const segX = distanceKm.slice(r.start, r.end + 1);\n            const segY = altitude.slice(r.start, r.end + 1);\n            traces.push({\n                x: segX,\n                y: segY,\n                type: 'scatter',\n                mode: 'lines',\n                line: { color: bgColor, width: 2 },\n                // use cluster-level name but mark run index if cluster has multiple runs\n                name: `${avgPower.toFixed(0)} W | ${displayDurationSec}s | #${idx + 1}${cluster.runs.length>1?(' (part '+(runIdx+1)+')'):''}`,\n                hoverinfo: 'text',\n                visible: true,\n                hoverlabel: { align: 'left' },\n                text: traceText\n            });\n        });\n\n        // Offset annotation positions to avoid overlap\n        // Place annotation near the middle of the cluster (use first run midpoint)\n        const firstRun = cluster.runs[0];\n        const lastRun = cluster.runs[cluster.runs.length-1];\n        const midIdx = Math.floor((firstRun.start + lastRun.end) / 2);\n        const annX = distanceKm[midIdx] || ((distanceKm[firstRun.start] + distanceKm[lastRun.end]) / 2);\n        const annY = Math.max(...cluster.runs.flatMap(r => altitude.slice(r.start, r.end + 1))) + 50 + idx * 25;\n        annotations.push({\n            x: annX,\n            y: annY,\n            text: `#${idx + 1}<br> ${avgPower.toFixed(0)} W<br> ${displayDurationSec}s`,\n            showarrow: false,\n            font: { family: 'Arial', size: 12, color: 'white' },\n            align: 'center',\n            bgcolor: bgColor,\n            opacity: 0.9\n        });\n    });\n\n    const layout = {\n    title: `Surges ${CONFIG_surges.MIN_SURGE_SECONDS}s >${CONFIG_surges.MIN_EFFORT_INTENSITY_FTP}% FTP`,\n        xaxis: { title: 'Distance (km)' },\n        yaxis: { title: 'Altitude (m)' },\n        annotations: annotations,\n        hovermode: 'x unified',\n        showlegend: true,\n        margin: { t: 100, l: 50, r: 50, b: 50 },\n        height: 500\n    };\n\n    const chart = { data: traces, layout: layout };\n    globalThis.chart = chart;\n    return chart;\n}\n\nfunction getZoneColor(avgPower, FTP) {\n    if (!FTP || FTP <= 0) return 'grey';\n    const percentage = (avgPower / FTP) * 100;\n    for (const zone of CONFIG_surges.ZONES) {\n        if (percentage < zone.max) return zone.color;\n    }\n    return '#000'; // fallback\n}\n})();",
        "name": "ssurges"
      },
      "usage_count": 0,
      "index": 51,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-10-10T17:14:55.068+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659185,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "5s over 650",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "S5over650",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 650\nwindow = 5\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "5s over 650"
      },
      "usage_count": 34,
      "index": 52,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T10:35:48.125+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 879857,
      "athlete_id": "i115436",
      "type": "ACTIVITY_CHART",
      "visibility": "PRIVATE",
      "name": "Torque Curve",
      "description": null,
      "image": null,
      "content": {
        "link": null,
        "width": "100%",
        "height": "500px",
        "script": "{\n  let torqueRaw = icu.streams.torque\n  let time = icu.streams.time\n  let weight = icu.activity.icu_weight || 1\n\n  // Torque normalizzato (Nm/kg)\n  let torque = torqueRaw.map(t => t / weight)\n  let n = torque.length\n\n  // Somma cumulativa\n  let cum = Array(n).fill(0)\n  cum[0] = torque[0]\n  for (let i = 1; i < n; i++) cum[i] = cum[i - 1] + torque[i]\n\n  // Durate stile MMP\n  let durations = [5, 10, 30, 60, 120, 180, 300, 360]\n  let MMT = []\n\n  for (let d of durations) {\n    let maxMean = 0\n    let startIdx = 0\n\n    for (let endIdx = 0; endIdx < n; endIdx++) {\n      while (time[endIdx] - time[startIdx] > d) startIdx++\n\n      let sum = cum[endIdx] - (startIdx > 0 ? cum[startIdx - 1] : 0)\n      let mean = sum / (endIdx - startIdx + 1)\n\n      if (mean > maxMean) maxMean = mean\n    }\n\n    MMT.push(maxMean)\n  }\n\n  let data = [{\n    type: 'line',\n    x: durations,\n    y: MMT,\n    name: 'Max Mean Torque',\n    line: { color: '#32aaaaff', width: 3 },\n    hovertemplate: '%{y:.2f} Nm/kg<extra></extra>'\n  }]\n\n  let layout = {\n    margin: { l: 65, r: 20, t: 20, b: 45 },\n\n    xaxis: {\n      title: 'Duration',\n      type: 'linear',\n      tickvals: durations,\n      ticktext: ['5s','10s','30s','1m','2m','3m','5m','6m'],\n      showline: true,\n      zeroline: false\n    },\n\n    yaxis: {\n      title: 'Max Mean Torque (Nm/kg)',\n      showline: true,\n      zeroline: false\n    },\n\n    showlegend: false\n  }\n\n  chart = { data, layout }\n}",
        "name": "Torque Curve"
      },
      "usage_count": 0,
      "index": 52,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-27T14:54:36.860+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659186,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "3s over 700",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover700",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 700\nwindow = 3\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "3s over 700"
      },
      "usage_count": 33,
      "index": 53,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T10:36:11.310+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659189,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "5s over 700",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "S5over700",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 700\nwindow = 5\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "5s over 700"
      },
      "usage_count": 34,
      "index": 54,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T10:36:31.556+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659190,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "3s over 750",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover750",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 750\nwindow = 3\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "3s over 750"
      },
      "usage_count": 34,
      "index": 55,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T10:36:48.383+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659192,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "5s over 750",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "S5over750",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 750\nwindow = 5\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "5s over 750"
      },
      "usage_count": 34,
      "index": 56,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T11:07:10.473+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659193,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "3s over 800",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover800",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 800\nwindow = 3\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "3s over 800"
      },
      "usage_count": 34,
      "index": 57,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T11:07:03.834+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659194,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "5s over 800",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "S5over800",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 800\nwindow = 5\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "5s over 800"
      },
      "usage_count": 34,
      "index": 58,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T11:06:57.243+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659195,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "10s over 400",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover400",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 400\nwindow = 10\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "10s over 400"
      },
      "usage_count": 34,
      "index": 59,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T10:38:18.418+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659196,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "10s over 450",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover450",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 450\nwindow = 10\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "10s over 450"
      },
      "usage_count": 34,
      "index": 60,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T10:38:39.232+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659197,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "10s over 500",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover500",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntarget = 500\nwindow = 10\ncooldown_ratio = 0.85\ncooldown_threshold = target * cooldown_ratio\n\noccurrences = 0\ni = 0\n\nwhile (i <= watts.length - window) {\n  sum = 0\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j]\n  }\n  avg = sum / window\n\n  if (avg >= target) {\n    occurrences += 1\n\n    // Skip avanti finch non troviamo almeno 1s sotto cooldown\n    i += window\n    cooldown_met = false\n    while (i < watts.length && !cooldown_met) {\n      if (watts[i] < cooldown_threshold) {\n        cooldown_met = true\n      }\n      i += 1\n    }\n  } else {\n    i += 1\n  }\n}\n\noccurrences",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "10s over 500"
      },
      "usage_count": 34,
      "index": 61,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T10:38:55.407+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659336,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "6W/kg",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Wkg",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "6*activity.icu_weight",
        "suffix": "watt",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "6W/kg"
      },
      "usage_count": 34,
      "index": 63,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T12:13:04.164+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659338,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "7W/kg",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Wkg7",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "7*activity.icu_weight",
        "suffix": "watt",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "7W/kg"
      },
      "usage_count": 34,
      "index": 64,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T12:12:53.321+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659340,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "8W/kg",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Wkg8",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "activity.icu_weight*8",
        "suffix": "watt",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "8W/kg"
      },
      "usage_count": 34,
      "index": 66,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T12:13:10.287+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659343,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "5W/kg",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Wkg5",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "activity.icu_weight*5",
        "suffix": "watt",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "5W/kg"
      },
      "usage_count": 35,
      "index": 68,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-22T12:32:16.036+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659344,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "20s over 6W/kg",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover6Wkg",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data;\nweight = activity.icu_weight;\ntarget = weight * 6;\nwindow = 20;\ncooldown_ratio = 0.77;\ncooldown_threshold = target * cooldown_ratio;\n\noccurrences = 0;\ni = 0;\n\nwhile (i <= watts.length - window) {\n  sum = 0;\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j];\n  }\n  avg = sum / window;\n\n  if (avg >= target) {\n    // Cerchiamo almeno 3s consecutivi sotto soglia\n    cooldown_start = i + window;\n    cooldown_streak = 0;\n    cooldown_met = false;\n\n    while (cooldown_start < watts.length) {\n      if (watts[cooldown_start] < cooldown_threshold) {\n        cooldown_streak += 1;\n        if (cooldown_streak >= 5) {\n          cooldown_met = true;\n          break;\n        }\n      } else {\n        cooldown_streak = 0;\n      }\n      cooldown_start += 1;\n    }\n\n    if (cooldown_met) {\n      occurrences += 1;\n      i = cooldown_start + 1; // riprende dopo il cooldown\n    } else {\n      i += 1;\n    }\n  } else {\n    i += 1;\n  }\n}\n\noccurrences;",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "20s over 6W/kg"
      },
      "usage_count": 34,
      "index": 69,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-26T14:26:23.040+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659348,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "20s over 7W/kg",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover7Wkg",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data;\nweight = activity.icu_weight;\ntarget = weight * 7;\nwindow = 20;\ncooldown_ratio = 0.77;\ncooldown_threshold = target * cooldown_ratio;\n\noccurrences = 0;\ni = 0;\n\nwhile (i <= watts.length - window) {\n  sum = 0;\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j];\n  }\n  avg = sum / window;\n\n  if (avg >= target) {\n    // Cerchiamo almeno 3s consecutivi sotto soglia\n    cooldown_start = i + window;\n    cooldown_streak = 0;\n    cooldown_met = false;\n\n    while (cooldown_start < watts.length) {\n      if (watts[cooldown_start] < cooldown_threshold) {\n        cooldown_streak += 1;\n        if (cooldown_streak >= 5) {\n          cooldown_met = true;\n          break;\n        }\n      } else {\n        cooldown_streak = 0;\n      }\n      cooldown_start += 1;\n    }\n\n    if (cooldown_met) {\n      occurrences += 1;\n      i = cooldown_start + 1; // riprende dopo il cooldown\n    } else {\n      i += 1;\n    }\n  } else {\n    i += 1;\n  }\n}\n\noccurrences;",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "20s over 7W/kg"
      },
      "usage_count": 34,
      "index": 70,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-26T14:26:45.981+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659350,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "20s over 8W/kg",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover8Wkg",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data;\nweight = activity.icu_weight;\ntarget = weight * 8;\nwindow = 20;\ncooldown_ratio = 0.77;\ncooldown_threshold = target * cooldown_ratio;\n\noccurrences = 0;\ni = 0;\n\nwhile (i <= watts.length - window) {\n  sum = 0;\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j];\n  }\n  avg = sum / window;\n\n  if (avg >= target) {\n    // Cerchiamo almeno 3s consecutivi sotto soglia\n    cooldown_start = i + window;\n    cooldown_streak = 0;\n    cooldown_met = false;\n\n    while (cooldown_start < watts.length) {\n      if (watts[cooldown_start] < cooldown_threshold) {\n        cooldown_streak += 1;\n        if (cooldown_streak >= 5) {\n          cooldown_met = true;\n          break;\n        }\n      } else {\n        cooldown_streak = 0;\n      }\n      cooldown_start += 1;\n    }\n\n    if (cooldown_met) {\n      occurrences += 1;\n      i = cooldown_start + 1; // riprende dopo il cooldown\n    } else {\n      i += 1;\n    }\n  } else {\n    i += 1;\n  }\n}\n\noccurrences;",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "20s over 8W/kg"
      },
      "usage_count": 34,
      "index": 71,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-26T14:26:38.836+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 659351,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "20s over 5W/kg",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Sover5Wkg",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data;\nweight = activity.icu_weight;\ntarget = weight * 5;\nwindow = 20;\ncooldown_ratio = 0.77;\ncooldown_threshold = target * cooldown_ratio;\n\noccurrences = 0;\ni = 0;\n\nwhile (i <= watts.length - window) {\n  sum = 0;\n  for (j = 0; j < window; j++) {\n    sum += watts[i + j];\n  }\n  avg = sum / window;\n\n  if (avg >= target) {\n    // Cerchiamo almeno 3s consecutivi sotto soglia\n    cooldown_start = i + window;\n    cooldown_streak = 0;\n    cooldown_met = false;\n\n    while (cooldown_start < watts.length) {\n      if (watts[cooldown_start] < cooldown_threshold) {\n        cooldown_streak += 1;\n        if (cooldown_streak >= 5) {\n          cooldown_met = true;\n          break;\n        }\n      } else {\n        cooldown_streak = 0;\n      }\n      cooldown_start += 1;\n    }\n\n    if (cooldown_met) {\n      occurrences += 1;\n      i = cooldown_start + 1; // riprende dopo il cooldown\n    } else {\n      i += 1;\n    }\n  } else {\n    i += 1;\n  }\n}\n\noccurrences;",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "20s over 5W/kg"
      },
      "usage_count": 35,
      "index": 72,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-26T14:26:08.259+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 662839,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Avg No Coasting",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Avgnocoasting",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\npower = 0\ncount = 0\n\nfor (i = 0; i < watts.length; i++) {\n  w = watts[i]\n  if (w >= 50) {\n    power += w\n    count += 1\n  }\n}\n\ncount > 0 ? power / count : 0",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Avg No Coasting"
      },
      "usage_count": 34,
      "index": 74,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-30T16:43:08.473+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 662851,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Coast DIFF",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "CoastDIFF",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\n\ntotal_power = 0\ntotal_count = 0\nno_coast_power = 0\nno_coast_count = 0\n\nfor (i = 0; i < watts.length; i++) {\n  w = watts[i]\n  total_power += w\n  total_count += 1\n\n  if (w >= 50) {\n    no_coast_power += w\n    no_coast_count += 1\n  }\n}\n\navg_power = total_count > 0 ? total_power / total_count : 0\navg_no_coast = no_coast_count > 0 ? no_coast_power / no_coast_count : 0\n\navg_no_coast - avg_power",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Coast DIFF"
      },
      "usage_count": 34,
      "index": 76,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-05-30T16:42:42.571+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 707263,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Time 90%+ HRmax",
      "description": "Get time inside 90-95% HRmax.\nVO2max intervals needs to be done with ERG mode off for the intervals (if you're doing it indoors).\n4-8M of varying power output, starting out to rapidly raise HR close to max. Throughout interval, vary power output up and down to keep HR >90-95% heart rate max. Take 4-5M active recovery between each interval. The point of these intervals is that you should be producing the lowest power required to keep your heart rate in the target zone.\n\nPURPOSE: To increase the maximal volume of oxygen the body can take in, deliver to the working muscles and utilize for energy production. Stimulates improvements in cardiac output, particularly stroke volume of the left ventricle (central adaptations) and greater mitochondrial function (peripheral adaptations).",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Time9095HRmax",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#FF00FF",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": false,
        "prefix": "",
        "script": "var minPercent = 90;\nvar maxHr = activity.athlete_max_hr;\nvar lowerLimit = maxHr * minPercent / 100;\nvar hrs = streams.get(\"fixed_heartrate\").data;\nvar times = streams.get(\"time\").data;\nvar totalTime = 0;\nvar prevTime = times[0];\nfor (var i = 1; i < hrs.length; i++) {\n    var currentTime = times[i];\n    var currentHr = hrs[i];\n    if (currentHr >= lowerLimit) {\n        totalTime += (currentTime - prevTime);\n    }\n    prevTime = currentTime;\n}\ntotalTime;",
        "suffix": "",
        "average": null,
        "convert": "duration_full",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".2f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Time 90%+ HRmax"
      },
      "usage_count": 0,
      "index": 77,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-07-20T20:50:32.252+00:00",
      "from_athlete": {
        "id": "i93513",
        "name": "Aleksandr Isaikin",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/a625a4f6-f721-4cf4-a02c-82ac950b7d43",
        "city": "Amsterdam",
        "state": "North Holland",
        "country": "Netherlands",
        "timezone": "Europe/Moscow",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 350429
    },
    {
      "id": 743949,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "VAM 2'",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "VAM2",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nconst stream = icu.streams;\nconst interval = 2 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "VAM 2'"
      },
      "usage_count": 2,
      "index": 82,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-28T18:01:41.193+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 743950,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "VAM 3'",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "VAM3",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nconst stream = icu.streams;\nconst interval = 3 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "VAM 3'"
      },
      "usage_count": 2,
      "index": 83,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-28T18:01:52.818+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 743951,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "VAM 5'",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "VAM5",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nconst stream = icu.streams;\nconst interval = 5 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "VAM 5'"
      },
      "usage_count": 2,
      "index": 84,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-28T18:01:57.001+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 743952,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "VAM 10'",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "VAM10",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nconst stream = icu.streams;\nconst interval = 10 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "VAM 10'"
      },
      "usage_count": 2,
      "index": 85,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-28T18:02:00.881+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 743953,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "VAM 20'",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "VAM20",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nconst stream = icu.streams;\nconst interval = 20 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "VAM 20'"
      },
      "usage_count": 2,
      "index": 86,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-28T18:02:04.455+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 743954,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "VAM 40'",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "VAM40",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nconst stream = icu.streams;\nconst interval = 40 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "VAM 40'"
      },
      "usage_count": 2,
      "index": 87,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-28T18:02:08.032+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 743955,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "VAM 60'",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "VAM60",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "{\nconst stream = icu.streams;\nconst interval = 60 * 60; // 5 minuti in secondi\n\n// Trova il primo punto valido di altitudine\nlet firstValidIndex = stream.altitude.findIndex(alt => alt > 0);\nif (firstValidIndex === -1) firstValidIndex = 0;\n\nlet bestGain = 0;\n\n// Scorri l'attivit e trova il miglior dislivello su 5 min\nfor (let i = firstValidIndex; i < stream.altitude.length - interval; i++) {\n  let gain = stream.altitude[i + interval] - stream.altitude[i];\n  if (gain > bestGain) bestGain = gain;\n}\n\n// Calcola la VAM in m/h\nlet bestVAM = (bestGain / interval) * 3600;\nbestVAM;\n}",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "VAM 60'"
      },
      "usage_count": 2,
      "index": 88,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-08-28T18:02:11.789+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 748879,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "% DIFF COAST",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "DIFFCOAST",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\n\ntotal_power = 0\ntotal_count = 0\nno_coast_power = 0\nno_coast_count = 0\n\nfor (i = 0; i < watts.length; i++) {\n  w = watts[i]\n  total_power += w\n  total_count += 1\n\n  if (w >= 50) {\n    no_coast_power += w\n    no_coast_count += 1\n  }\n}\n\navg_power = total_count > 0 ? total_power / total_count : 0\navg_no_coast = no_coast_count > 0 ? no_coast_power / no_coast_count : 0\ncoast_diff= avg_no_coast - avg_power\n\ncoast_diff / avg_power",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".1%",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "% DIFF COAST"
      },
      "usage_count": 34,
      "index": 89,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-09-02T19:28:02.200+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 748895,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "tOverCOAST",
      "description": "",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "TOverCOAST",
        "icon": "",
        "link": "",
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": "",
        "inline": true,
        "prefix": "",
        "script": "watts = streams.get(\"fixed_watts\").data\ntime_above = 0\nfor (let i = 0; i < watts.length; i++) {\n   w = watts[i]\n  if (w >= 50) time_above += 1\n}\n\ntime_above",
        "suffix": "",
        "average": null,
        "convert": "duration_full",
        "example": 42,
        "options": [],
        "aggregate": "SUM",
        "text_wrap": "wrap",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": "",
        "processes_fit_messages": false,
        "name": "tOverCOAST"
      },
      "usage_count": 34,
      "index": 90,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-04T21:36:02.054+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 748897,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "% over COAST",
      "description": null,
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "OverCOAST",
        "icon": null,
        "link": null,
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "watts = streams.get(\"fixed_watts\").data\ntime_below = 0\ntotal_time = watts.length\nfor (let i = 0; i < watts.length; i++) {\n   w = watts[i]\n  if (w >= 50) time_below += 1\n}\n\ntime_below/total_time",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".1%",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "% over COAST"
      },
      "usage_count": 34,
      "index": 91,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-09-02T19:39:02.942+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 761540,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "Matches",
      "description": "Displays the number of matches, time average, power average , and total energy for the matches. Match time and % FTP can be configured.",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "Matches",
        "icon": null,
        "link": null,
        "type": "text",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": null,
        "inline": true,
        "prefix": null,
        "script": "// Configuracin\nvar ftp = activity.icu_ftp;\nvar threshold = ftp * 1.3; // 120% de FTP, es decir, 336W\nvar minDuration = 10;       // Duracin mnima en segundos para considerar un match\nvar gracePeriod = 3;        // Permitir hasta 3 segundos consecutivos por debajo del umbral\n\n// Verificar que existan datos de potencia\nif (!streams || !streams.watts || streams.watts.length === 0) {\n  \"No hay datos de potencia\";\n}\n\n// Variables para acumular matches\nvar matches = [];       // Se guardarn objetos { duration, avg, joules }\nvar currentMatch = [];  // Almacena los segundos (valores de potencia) que forman el match\nvar dropCount = 0;      // Cuenta segundos consecutivos por debajo del umbral\n\n// Iterar por cada segundo de la sesin\nfor (var i = 0; i < streams.watts.length; i++) {\n  var p = streams.watts[i];\n  \n  if (p >= threshold) {\n    // Si la potencia est por encima del umbral, reiniciamos el contador de cada\n    dropCount = 0;\n    currentMatch.push(p);\n  } else {\n    // Si la potencia cae por debajo del umbral, aumentamos el contador de cada\n    dropCount++;\n    \n    // Si an no se alcanzan los 3 segundos de cada, no finalizamos el match\n    if (dropCount < gracePeriod) {\n      // Esperamos para confirmar que la cada es sostenida\n      continue;\n    } else {\n      // Se han cumplido 3 segundos consecutivos por debajo del umbral,\n      // por lo que se finaliza el match (sin incluir esos segundos de cada)\n      if (currentMatch.length >= minDuration) {\n        var sum = currentMatch.reduce(function(a, b) { return a + b; }, 0);\n        var avg = Math.round(sum / currentMatch.length);\n        var joules = currentMatch.reduce(function(total, power) {\n          return total + (power - ftp);\n        }, 0);\n        joules = Math.round(joules);\n        var duration = currentMatch.length;\n        matches.push({ duration: duration, avg: avg, joules: joules });\n      }\n      // Reiniciar el match y el contador de cada\n      currentMatch = [];\n      dropCount = 0;\n    }\n  }\n}\n\n// Si la sesin termina durante un match en el que no se complet el grace period, se procesa igualmente\nif (currentMatch.length >= minDuration) {\n  var sum = currentMatch.reduce(function(a, b) { return a + b; }, 0);\n  var avg = Math.round(sum / currentMatch.length);\n  var joules = currentMatch.reduce(function(total, power) {\n    return total + (power - ftp);\n  }, 0);\n  joules = Math.round(joules);\n  var duration = currentMatch.length;\n  matches.push({ duration: duration, avg: avg, joules: joules });\n}\n\n// Resumir los datos de los matches\nif (matches.length === 0) {\n  \"No - Matches\";\n} else {\n  var totalMatches = matches.length;\n  var sumDurations = 0, sumPower = 0, sumJoules = 0;\n  for (var j = 0; j < matches.length; j++) {\n    sumDurations += matches[j].duration;\n    sumPower += matches[j].avg;\n    sumJoules += matches[j].joules;\n  }\n  var avgDuration = Math.round(sumDurations / totalMatches);\n  var avgPower = Math.round(sumPower / totalMatches);\n  var totalEnergy = (sumJoules / 1000).toFixed(2); // Convertir a kJ con dos decimales\n  \n   totalMatches + \" -> \" + avgDuration + \"s-\" + avgPower + \"w-\" + totalEnergy + \"kJ\";\n}",
        "suffix": null,
        "average": null,
        "convert": "",
        "example": 42,
        "options": null,
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".1f",
        "fit_session_field": null,
        "processes_fit_messages": false,
        "name": "Matches"
      },
      "usage_count": 0,
      "index": 92,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-09-16T11:41:14.309+00:00",
      "from_athlete": {
        "id": "i62859",
        "name": "OSCAR MARTINEZ",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/c295a232-660c-4a1c-abdb-a7ff5be4aaac",
        "city": "Paterna",
        "state": "Valencia",
        "country": "Spain",
        "timezone": "Europe/Madrid",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 610258
    },
    {
      "id": 772368,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "eFTP",
      "description": "Reading the eFTP value for automatic zone calculations. ",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "EFTP",
        "icon": "",
        "link": "",
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": "w",
        "inline": true,
        "prefix": "",
        "script": "{\ndata = activity.icu_rolling_ftp;\n}",
        "suffix": "w",
        "average": null,
        "convert": "",
        "example": 42,
        "options": [],
        "aggregate": "MAX",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": "",
        "processes_fit_messages": false,
        "name": "eFTP"
      },
      "usage_count": 0,
      "index": 129,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-09-27T16:47:53.004+00:00",
      "from_athlete": {
        "id": "i85346",
        "name": "R2Tom",
        "profile_medium": "https://storage.googleapis.com/intervals-icu-images/profile_pics/9effd3aa-d71f-4dc5-a60b-bd8a7af746e5",
        "city": "Altdorf",
        "state": "Bavaria",
        "country": "Germany",
        "timezone": "Europe/Berlin",
        "sex": "M",
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": 766617
    },
    {
      "id": 839932,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "kJ/kg",
      "description": "",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "KJkg",
        "icon": "mdi-scale-unbalanced",
        "link": "",
        "type": "numeric",
        "color": "#037e65",
        "gauge": true,
        "total": null,
        "units": "",
        "inline": false,
        "prefix": "",
        "script": "(activity.icu_joules/1000)/(activity.icu_weight)",
        "suffix": " kJ/kg",
        "average": null,
        "convert": "",
        "example": 42,
        "options": [],
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".1f",
        "fit_session_field": "",
        "processes_fit_messages": false,
        "name": "kJ/kg"
      },
      "usage_count": 33,
      "index": 130,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-11-24T08:18:59.768+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 839933,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "kJ/kg > CP",
      "description": "",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "KJkgCP",
        "icon": "",
        "link": "",
        "type": "numeric",
        "color": "#ee2c6d",
        "gauge": true,
        "total": null,
        "units": "",
        "inline": false,
        "prefix": "",
        "script": "watts = streams.get(\"fixed_watts\").data\ntime =  streams.get(\"time\").data\nftp = activity.icu_ftp\njoules = 0\nfor (let i = 0; i < watts.length; i++) {\n  let w = watts[i]\n  if (w >= ftp) { \n    let secs = time[i] - (i > 0 ? time[i - 1] : 0)\n    if (secs < 30) joules += w * secs\n  }\n}\njoules/1000\n/(activity.icu_weight)",
        "suffix": " kJ/kg",
        "average": null,
        "convert": "",
        "example": 42,
        "options": [],
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".1f",
        "fit_session_field": "",
        "processes_fit_messages": false,
        "name": "kJ/kg > CP"
      },
      "usage_count": 33,
      "index": 131,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-11-24T08:22:19.393+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 852816,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "tOverCoastFITNESS",
      "description": "",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "TOverCoastFITNESS",
        "icon": "",
        "link": "",
        "type": "numeric",
        "color": "#333333",
        "gauge": false,
        "total": null,
        "units": "",
        "inline": true,
        "prefix": "",
        "script": "watts = streams.get(\"fixed_watts\").data\ntime_above = 0\nfor (let i = 0; i < watts.length; i++) {\n   w = watts[i]\n  if (w >= 50) time_above += 1\n}\n\ntime_above",
        "suffix": "",
        "average": null,
        "convert": "duration",
        "example": 42,
        "options": [],
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": "",
        "processes_fit_messages": false,
        "name": "tOverCoastFITNESS"
      },
      "usage_count": 30,
      "index": 132,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-04T21:40:43.918+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    },
    {
      "id": 879341,
      "athlete_id": "i115436",
      "type": "ACTIVITY_FIELD",
      "visibility": "PRIVATE",
      "name": "CHO/h",
      "description": "",
      "image": null,
      "content": {
        "max": null,
        "min": null,
        "code": "CHOh",
        "icon": "",
        "link": "",
        "type": "numeric",
        "color": "#333333",
        "gauge": true,
        "total": null,
        "units": "",
        "inline": true,
        "prefix": "",
        "script": "activity.carbs_ingested/ (activity. moving_time/3600)",
        "suffix": "",
        "average": null,
        "convert": "",
        "example": 42,
        "options": [],
        "aggregate": "SUM",
        "text_wrap": "no",
        "pace_units": null,
        "text_align": "center",
        "number_format": ".0f",
        "fit_session_field": "",
        "processes_fit_messages": false,
        "name": "CHO/h"
      },
      "usage_count": 27,
      "index": 133,
      "hide_script": false,
      "hidden_by_id": null,
      "updated": "2025-12-26T23:42:11.414+00:00",
      "from_athlete": {
        "id": null,
        "name": null,
        "profile_medium": "/no-profile-pic.png",
        "city": null,
        "state": null,
        "country": null,
        "timezone": null,
        "sex": null,
        "bio": null,
        "website": null,
        "email": null
      },
      "from_id": null
    }
  ]
}